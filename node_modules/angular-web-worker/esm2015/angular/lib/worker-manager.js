import { WorkerClient } from './worker-client';
/**
 * Injectable angular service with a primary responsability of acting as `WorkerClient` factory through its `createClient()` method.
 *
 * **Module**
 *
 * The `WorkerModule` must be imported to provide the service, passing in worker defintions in the `WorkerModule.forWorkers()` function so that the factory method
 * has neccessary details to create new clients
 *
 * @example
 * // module ---
 * imports: [
 *  WorkerModule.forWorkers([
 *    {worker: AppWorker, initFn: () => new Worker('./app.worker.ts', {type: 'module'})},
 *  ])
 * ]
 *
 * // usage ---
 * export class AppComponent implements OnInit {
 *
 *   constructor(private workerManager: WorkerManager) {}
 *
 *   ngOnInit() {
 *      const client: WorkerClient<AppWorker> = this.workerManager.createClient(AppWorker);
 *   }
 *
 * }
 */
export class WorkerManager {
    /**
     * Creates a new `WorkerManager` and called from `WorkerModule.forWorkers()` where the angular provider is created
     * @param workerDefintions List of workers with details to create new worker instances. Passed into `WorkerModule.forWorkers()`
     */
    constructor(workerDefintions) {
        this.workerDefinitions = workerDefintions ? workerDefintions : [];
    }
    /**
     * Factory function that creates a new `WorkerClient`. The worker definitions must first be registered when importing the `WorkerModule.forWorkers()` module, otherwise
     * it will throw an error
     * @param workerType the worker class
     * @param runInApp whether the execution of the worker code is run in the application's "thread". Defaults to run in the worker script
     * @example
     * // module ---
     * imports: [
     *  WorkerModule.forWorkers([
     *    {worker: AppWorker, initFn: () => new Worker('./app.worker.ts', {type: 'module'})},
     *  ])
     * ]
     *
     * // usage ---
     * export class AppComponent implements OnInit {
     *
     *   constructor(private workerManager: WorkerManager) {}
     *
     *   ngOnInit() {
     *      let client: WorkerClient<AppWorker> ;
     *      if(workerManager.isBrowserCompatible) {
     *          client = this.workerManager.createClient(AppWorker);
     *      } else {
     *          // only if worker execution does not have UI blocking code else implement other behaviour
     *          client = this.workerManager.createClient(AppWorker, true);
     *      }
     *   }
     *
     * }
     */
    createClient(workerType, runInApp = false) {
        const definition = this.workerDefinitions.filter(p => p.worker === workerType)[0];
        if (definition) {
            return new WorkerClient(definition, runInApp);
        }
        else {
            throw new Error('WorkerManager: all web workers must be registered in the forWorkers function of the WorkerModule');
        }
    }
    /**
     * Whether the browser supports web workers
     */
    get isBrowserCompatible() {
        return typeof Worker !== 'undefined';
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid29ya2VyLW1hbmFnZXIuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyLXdlYi13b3JrZXIvYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi93b3JrZXItbWFuYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFJL0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBMEJHO0FBQ0gsTUFBTSxPQUFPLGFBQWE7SUFPdEI7OztPQUdHO0lBQ0gsWUFBWSxnQkFBb0M7UUFDNUMsSUFBSSxDQUFDLGlCQUFpQixHQUFHLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQ3RFLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0E2Qkc7SUFDSCxZQUFZLENBQUksVUFBNEIsRUFBRSxXQUFvQixLQUFLO1FBQ25FLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxLQUFLLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2xGLElBQUksVUFBVSxFQUFFO1lBQ1osT0FBTyxJQUFJLFlBQVksQ0FBSSxVQUFVLEVBQUUsUUFBUSxDQUFDLENBQUM7U0FDcEQ7YUFBTTtZQUNILE1BQU0sSUFBSSxLQUFLLENBQUMsa0dBQWtHLENBQUMsQ0FBQztTQUN2SDtJQUNMLENBQUM7SUFFRDs7T0FFRztJQUNILElBQUksbUJBQW1CO1FBQ25CLE9BQU8sT0FBTyxNQUFNLEtBQUssV0FBVyxDQUFDO0lBQ3pDLENBQUM7Q0FJSiIsInNvdXJjZXNDb250ZW50IjpbIlxyXG5pbXBvcnQgeyBXb3JrZXJDbGllbnQgfSBmcm9tICcuL3dvcmtlci1jbGllbnQnO1xyXG5pbXBvcnQgeyBXb3JrZXJEZWZpbml0aW9uIH0gZnJvbSAnLi93b3JrZXIubW9kdWxlJztcclxuaW1wb3J0IHsgV2ViV29ya2VyVHlwZSB9IGZyb20gJ2FuZ3VsYXItd2ViLXdvcmtlci9jb21tb24nO1xyXG5cclxuLyoqXHJcbiAqIEluamVjdGFibGUgYW5ndWxhciBzZXJ2aWNlIHdpdGggYSBwcmltYXJ5IHJlc3BvbnNhYmlsaXR5IG9mIGFjdGluZyBhcyBgV29ya2VyQ2xpZW50YCBmYWN0b3J5IHRocm91Z2ggaXRzIGBjcmVhdGVDbGllbnQoKWAgbWV0aG9kLlxyXG4gKlxyXG4gKiAqKk1vZHVsZSoqXHJcbiAqXHJcbiAqIFRoZSBgV29ya2VyTW9kdWxlYCBtdXN0IGJlIGltcG9ydGVkIHRvIHByb3ZpZGUgdGhlIHNlcnZpY2UsIHBhc3NpbmcgaW4gd29ya2VyIGRlZmludGlvbnMgaW4gdGhlIGBXb3JrZXJNb2R1bGUuZm9yV29ya2VycygpYCBmdW5jdGlvbiBzbyB0aGF0IHRoZSBmYWN0b3J5IG1ldGhvZFxyXG4gKiBoYXMgbmVjY2Vzc2FyeSBkZXRhaWxzIHRvIGNyZWF0ZSBuZXcgY2xpZW50c1xyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBtb2R1bGUgLS0tXHJcbiAqIGltcG9ydHM6IFtcclxuICogIFdvcmtlck1vZHVsZS5mb3JXb3JrZXJzKFtcclxuICogICAge3dvcmtlcjogQXBwV29ya2VyLCBpbml0Rm46ICgpID0+IG5ldyBXb3JrZXIoJy4vYXBwLndvcmtlci50cycsIHt0eXBlOiAnbW9kdWxlJ30pfSxcclxuICogIF0pXHJcbiAqIF1cclxuICpcclxuICogLy8gdXNhZ2UgLS0tXHJcbiAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xyXG4gKlxyXG4gKiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgd29ya2VyTWFuYWdlcjogV29ya2VyTWFuYWdlcikge31cclxuICpcclxuICogICBuZ09uSW5pdCgpIHtcclxuICogICAgICBjb25zdCBjbGllbnQ6IFdvcmtlckNsaWVudDxBcHBXb3JrZXI+ID0gdGhpcy53b3JrZXJNYW5hZ2VyLmNyZWF0ZUNsaWVudChBcHBXb3JrZXIpO1xyXG4gKiAgIH1cclxuICpcclxuICogfVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFdvcmtlck1hbmFnZXIge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGlzdCBvZiB3b3JrZXJzIHdpdGggZGV0YWlscyB0byBjcmVhdGVkIG5ldyB3b3JrZXIgaW5zdGFuY2VzLiBQYXNzZWQgaW50byBgV29ya2VyTW9kdWxlLmZvcldvcmtlcnMoKWBcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB3b3JrZXJEZWZpbml0aW9uczogV29ya2VyRGVmaW5pdGlvbltdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgV29ya2VyTWFuYWdlcmAgYW5kIGNhbGxlZCBmcm9tIGBXb3JrZXJNb2R1bGUuZm9yV29ya2VycygpYCB3aGVyZSB0aGUgYW5ndWxhciBwcm92aWRlciBpcyBjcmVhdGVkXHJcbiAgICAgKiBAcGFyYW0gd29ya2VyRGVmaW50aW9ucyBMaXN0IG9mIHdvcmtlcnMgd2l0aCBkZXRhaWxzIHRvIGNyZWF0ZSBuZXcgd29ya2VyIGluc3RhbmNlcy4gUGFzc2VkIGludG8gYFdvcmtlck1vZHVsZS5mb3JXb3JrZXJzKClgXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHdvcmtlckRlZmludGlvbnM6IFdvcmtlckRlZmluaXRpb25bXSkge1xyXG4gICAgICAgIHRoaXMud29ya2VyRGVmaW5pdGlvbnMgPSB3b3JrZXJEZWZpbnRpb25zID8gd29ya2VyRGVmaW50aW9ucyA6IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmFjdG9yeSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgYFdvcmtlckNsaWVudGAuIFRoZSB3b3JrZXIgZGVmaW5pdGlvbnMgbXVzdCBmaXJzdCBiZSByZWdpc3RlcmVkIHdoZW4gaW1wb3J0aW5nIHRoZSBgV29ya2VyTW9kdWxlLmZvcldvcmtlcnMoKWAgbW9kdWxlLCBvdGhlcndpc2VcclxuICAgICAqIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3JcclxuICAgICAqIEBwYXJhbSB3b3JrZXJUeXBlIHRoZSB3b3JrZXIgY2xhc3NcclxuICAgICAqIEBwYXJhbSBydW5JbkFwcCB3aGV0aGVyIHRoZSBleGVjdXRpb24gb2YgdGhlIHdvcmtlciBjb2RlIGlzIHJ1biBpbiB0aGUgYXBwbGljYXRpb24ncyBcInRocmVhZFwiLiBEZWZhdWx0cyB0byBydW4gaW4gdGhlIHdvcmtlciBzY3JpcHRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBtb2R1bGUgLS0tXHJcbiAgICAgKiBpbXBvcnRzOiBbXHJcbiAgICAgKiAgV29ya2VyTW9kdWxlLmZvcldvcmtlcnMoW1xyXG4gICAgICogICAge3dvcmtlcjogQXBwV29ya2VyLCBpbml0Rm46ICgpID0+IG5ldyBXb3JrZXIoJy4vYXBwLndvcmtlci50cycsIHt0eXBlOiAnbW9kdWxlJ30pfSxcclxuICAgICAqICBdKVxyXG4gICAgICogXVxyXG4gICAgICpcclxuICAgICAqIC8vIHVzYWdlIC0tLVxyXG4gICAgICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XHJcbiAgICAgKlxyXG4gICAgICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIHdvcmtlck1hbmFnZXI6IFdvcmtlck1hbmFnZXIpIHt9XHJcbiAgICAgKlxyXG4gICAgICogICBuZ09uSW5pdCgpIHtcclxuICAgICAqICAgICAgbGV0IGNsaWVudDogV29ya2VyQ2xpZW50PEFwcFdvcmtlcj4gO1xyXG4gICAgICogICAgICBpZih3b3JrZXJNYW5hZ2VyLmlzQnJvd3NlckNvbXBhdGlibGUpIHtcclxuICAgICAqICAgICAgICAgIGNsaWVudCA9IHRoaXMud29ya2VyTWFuYWdlci5jcmVhdGVDbGllbnQoQXBwV29ya2VyKTtcclxuICAgICAqICAgICAgfSBlbHNlIHtcclxuICAgICAqICAgICAgICAgIC8vIG9ubHkgaWYgd29ya2VyIGV4ZWN1dGlvbiBkb2VzIG5vdCBoYXZlIFVJIGJsb2NraW5nIGNvZGUgZWxzZSBpbXBsZW1lbnQgb3RoZXIgYmVoYXZpb3VyXHJcbiAgICAgKiAgICAgICAgICBjbGllbnQgPSB0aGlzLndvcmtlck1hbmFnZXIuY3JlYXRlQ2xpZW50KEFwcFdvcmtlciwgdHJ1ZSk7XHJcbiAgICAgKiAgICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICpcclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgY3JlYXRlQ2xpZW50PFQ+KHdvcmtlclR5cGU6IFdlYldvcmtlclR5cGU8VD4sIHJ1bkluQXBwOiBib29sZWFuID0gZmFsc2UpOiBXb3JrZXJDbGllbnQ8VD4ge1xyXG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSB0aGlzLndvcmtlckRlZmluaXRpb25zLmZpbHRlcihwID0+IHAud29ya2VyID09PSB3b3JrZXJUeXBlKVswXTtcclxuICAgICAgICBpZiAoZGVmaW5pdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdvcmtlckNsaWVudDxUPihkZWZpbml0aW9uLCBydW5JbkFwcCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3JrZXJNYW5hZ2VyOiBhbGwgd2ViIHdvcmtlcnMgbXVzdCBiZSByZWdpc3RlcmVkIGluIHRoZSBmb3JXb3JrZXJzIGZ1bmN0aW9uIG9mIHRoZSBXb3JrZXJNb2R1bGUnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIHdlYiB3b3JrZXJzXHJcbiAgICAgKi9cclxuICAgIGdldCBpc0Jyb3dzZXJDb21wYXRpYmxlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJztcclxuICAgIH1cclxuXHJcblxyXG5cclxufVxyXG4iXX0=