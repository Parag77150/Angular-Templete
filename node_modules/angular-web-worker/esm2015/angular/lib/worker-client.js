import { Subject, Subscription } from 'rxjs';
import { WorkerEvents, WorkerUtils, WorkerAnnotations, WorkerObservableMessageTypes } from 'angular-web-worker/common';
import { ClientWebWorker } from './client-web-worker';
/**
 * Provides functionality for an Angular app to access the properties, call the methods and subscribe to the events in a web worker by managing
 * the communication between the app and the worker. Also provides the option to execute the worker code within the app should the browser not support web workers,
 * although intensive work may then block the UI.
 */
export class WorkerClient {
    /**
     * Creates a new `WorkerClient`
     * @param definition the worker defintion originating from the arguments of the `WorkerModule.forWorkers()` method
     * @param runInApp whether the execution of the worker will occur in the app or within the worker script
     * @param runInApp whether the client is used for unit testing which determines if serialization should be mocked
     */
    constructor(definition, runInApp = false, isTestClient = false) {
        this.definition = definition;
        this.runInApp = runInApp;
        this.isTestClient = isTestClient;
    }
    /**
     * Creates a new worker script in the browser, or within the app, and triggers the `OnWorkerInit` hook, if implemented. If the hook is implemented the promise will only be resolved once `onWorkerInit` method
     * has completed regardless of whether it is async or not
     *
     * This method must called before any worker methods and/or properties can be called/accessed
     */
    connect() {
        if (!this._isConnected) {
            this.secrets = [];
            this.workerSecret = this.generateSecretKey();
            this.worker = WorkerUtils.getAnnotation(this.definition.worker, WorkerAnnotations.Factory)({
                isClient: true,
                clientSecret: this.workerSecret
            });
            if (!this.runInApp) {
                this.workerRef = this.definition.initFn();
            }
            else {
                this.workerRef = new ClientWebWorker(this.definition.worker, this.isTestClient);
            }
            this.registerEvents();
            return this.castPromise(this.sendRequest(WorkerEvents.Init, {
                body: () => null,
                isConnect: true,
                resolve: () => {
                    this._isConnected = true;
                    return undefined;
                },
                secretError: 'Could not initialise worker'
            }));
        }
    }
    /**
     * Terminates the worker and unsubscribes from any subscriptions created from the `subscribe()` method
     */
    destroy() {
        if (this.isConnected) {
            for (const key in this.observables) {
                if (this.observables[key]) {
                    this.removeSubscription(key);
                }
            }
            this.workerRef.terminate();
            this.secrets = [];
            this.observables = {};
            this.worker = null;
            this._isConnected = false;
        }
    }
    /**
     * Whether the worker is active after it is created with the `connect()` method and before it has been terminated by the `destroy()` method
     */
    get isConnected() {
        return this._isConnected;
    }
    /**
     * Returns the value of a worker property that has been decorated with `@Accessable()`. Undecorated properties will cause the promise to be rejected
     * @Serialized
     * @example
     * // async await syntax ---
     * const name: string = await client.get(w => w.name);
     *
     * // promise syntax ---
     * client.get(w => w.name).then((name) => {
     *   console.log(name);
     * }).catch((err) => {
     *   console.log(err);
     * });
     * @param property A lamda expression that returns the targeted property of the worker. The worker argument in the expression only has the properties owned by the worker class (no methods)
     * and only those properties that are not RxJS subjects
     */
    get(property) {
        return this.sendRequest(WorkerEvents.Accessable, {
            workerProperty: property,
            additionalConditions: [{
                    if: (secret) => secret.body.get,
                    reject: (secret) => new Error(`WorkerClient: will not apply the get method to the "${secret.propertyName}" property because the get accessor has been explicity set to false`)
                }],
            secretError: 'WorkerClient: only properties decorated with @Accessable() can be used in the get method',
            body: () => { return { isGet: true }; },
            resolve: (resp) => {
                const metaData = WorkerUtils.getAnnotation(this.definition.worker, WorkerAnnotations.Accessables).filter(x => x.name === resp.propertyName)[0];
                if (metaData.shallowTransfer) {
                    if (metaData.type) {
                        if (metaData.type.prototype && resp.result) {
                            resp.result.__proto__ = metaData.type.prototype;
                        }
                    }
                }
                return resp.result;
            }
        });
    }
    /**
     * Sets value of a worker property that has been decorated with `@Accessable()`. Undecorated properties will cause the promise to be rejected
     * @Serialized

     * @example
     * // async await syntax ---
     * await client.set(w => w.name, 'peter');
     *
     * // promise syntax ---
     * client.set(w => w.name, 'peter').then(() => {
     *   console.log('property has been set');
     * }).catch((err) => {
     *   console.log(err);
     * });
     * @param property A lamda expression that returns the targeted property of the worker. The worker argument in the expression only has the properties owned by the worker class (no methods)
     * and only those properties that are not RxJS subjects
     * @param value the value which the property should be set to
     */
    set(property, value) {
        return this.castPromise(this.sendRequest(WorkerEvents.Accessable, {
            workerProperty: property,
            additionalConditions: [{
                    if: (secret) => secret.body.set,
                    reject: (secret) => new Error(`WorkerClient: will not apply the set method to the "${secret.propertyName}" property because the set accessor has been explicity set to false`)
                }],
            secretError: 'WorkerClient: only properties decorated with @Accessable() can be used in the set method',
            body: () => { return { isGet: false, value: value }; }
        }));
    }
    /**
     * Calls a method in the worker and returns its value. The called method can be either synchronous or asynchronous
     * but must be decorated with `@Callable()` else the promise will be rejected
     * @Serialized Applies to both the function arguments and the returned value
     * @example
     * // async await syntax ---
     * const functionResult: SomeResultType = await client.call(w => w.doSomeWork('someArgument', 2123));
     *
     * // promise syntax ---
     * client.call(w => w.doSomeWork('someArgument', 2123)).then((result) => {
     *    console.log(result);
     * }).catch((err) => {
     *    console.log(err);
     * });
     * @param property A lamda expression that calls the worker method. The worker argument in the expression only has the methods owned by the worker class (not the properties)
     */
    call(callFn) {
        return this.sendRequest(WorkerEvents.Callable, {
            workerProperty: callFn,
            secretError: 'WorkerClient: only methods decorated with @Callable() can be used in the call method',
            body: (secret) => { return { arguments: secret.body.args }; },
            resolve: (resp) => {
                const metaData = WorkerUtils.getAnnotation(this.definition.worker, WorkerAnnotations.Callables, []).filter(x => x.name === resp.propertyName)[0];
                if (metaData.shallowTransfer) {
                    if (metaData.returnType === Promise) {
                        throw new Error('WorkerClient: shallowTransfer will not be true in the @Callable() decorator when the decorated method returns a promise');
                    }
                    if (metaData.returnType && resp.result) {
                        resp.result.__proto__ = metaData.returnType.prototype;
                    }
                }
                return resp.result;
            }
        });
    }
    /**
     * Subscribes to a worker's RxJS subject, which has been decorated with `@Subscribable()`, and then returns this subscription.
     *  Supports all four RxJS subjects being `Subject`,  `BehaviorSubject`, `ReplaySubject` and `AsyncSubject`.
     *
     * **UNSUBSCRIBING**
     *
     * While the returned subscription can be destroyed with `Subscription.unsubscribe()` this is only destroys the client subscription. A subscription is also created in the worker.
     * To release the resources in both the client and the worker the `WorkerClient.unsubscribe(subscription)` method should be used. The `WorkerClient.destroy()` method will
     * dispose of all subscriptions correctly.
     *
     * @Serialized This applies to messages posted through `Subject.next()`
     * @example
     * // async await syntax ---
     * this.workerSubscription = await client.subscribe(w => w.someEventSubject);
     *
     * // promise syntax ---
     * client.subscribe(w => w.someEventSubject).then((subscription) => {
     *    this.workerSubscription = subscription;
     * }).catch((err) => {
     *    console.log(err);
     * });
     *
     * // unsubscribing --------
     * await client.unsubscribe(this.workerSubscription)
     * @param observable A lamda expression that returns the targeted RxJS subject of the worker. The worker argument in the expression only has the properties owned by the worker class (no methods)
     * and only those properties that are RxJS subjects
     * @param next Callback function that is triggered when the subject's `next()` method is called within the worker
     * @param error Callback function that is triggered when the subject throws and error
     * @param complete Callback function that is triggered when the subject's `complete()` method is called within the worker
     */
    subscribe(observable, next, error, complete) {
        return this.castPromise(this.sendRequest(WorkerEvents.Observable, {
            workerProperty: observable,
            secretError: 'WorkerClient: only methods decorated with @Callable() can be used in the call method',
            beforeRequest: (secret) => this.createSubscription(secret.propertyName, next, error, complete),
            body: (secret, key) => { return { isUnsubscribe: false, subscriptionKey: key }; },
            resolve: (resp, secret, key) => this.observables[key].subscription,
            beforeReject: (resp, secret, key) => this.removeSubscription(key)
        }));
    }
    /**
     * Creates and returns a RxJS observable that is in sync with a RxJS subject within a worker. The worker subject must be decorated with `@Subscribable()` otherwise the
     * promise will be rejected. Supports all four RxJS subjects being, `Subject`,  `BehaviorSubject`, `ReplaySubject` and `AsyncSubject`.
     *
     * **UNSUBSCRIBING**
     *
     * While under normal circumstances you don't need to unsubscribe from an RxJS observable, when an observable is created from a worker subject a subscription is also created in the worker.
     * To release the resources in the worker the `WorkerClient.unsubscribe(observable)` method should be used. The `WorkerClient.destroy()` method will
     * dispose of all observables correctly.
     *
     * @Serialized
     * @example
     * // async await syntax ---
     * this.observable$ = await client.observe(w => w.someEventSubject);
     *
     * // promise syntax ---
     * client.observe(w => w.someEventSubject).then((observable) => {
     *   this.observable$ = observable;
     * }).catch((err) => {
     *    console.log(err);
     * });
     *
     * // unsubscribing --------
     * await client.unsubscribe(this.observable$)
     * @param observable A lamda expression that returns the targeted RxJS subject of the worker. The worker argument in the expression only has the properties owned by the worker class (no methods)
     * and only those properties that are RxJS subjects
     */
    observe(observable) {
        return this.castPromise(this.sendRequest(WorkerEvents.Observable, {
            workerProperty: observable,
            secretError: 'WorkerClient: only methods decorated with @Callable() can be used in the call method',
            beforeRequest: (secret) => this.createObservable(secret.propertyName),
            body: (secret, key) => { return { isUnsubscribe: false, subscriptionKey: key }; },
            resolve: (resp, secret, key) => this.observables[key].observable,
            beforeReject: (resp, secret, key) => this.removeSubscription(key)
        }));
    }
    /**
     * Unsubscribes from an RxJS subscription or observable that has been created from the `WorkerClient.subscribe()` or `WorkerClient.observe()` methods respectively.
     *  This method is neccessary to release resources within the worker. Calling `WorkerClient.destory()` will also dispose of all observables/subscriptions
     * @param subscriptionOrObservable The observable or subscription that must be disposed of
     */
    unsubscribe(subscriptionOrObservable) {
        const key = this.findObservableKey(subscriptionOrObservable);
        if (key) {
            const propertyName = this.observables[key].propertyName;
            this.removeSubscription(key);
            return this.castPromise(this.sendRequest(WorkerEvents.Observable, {
                workerProperty: propertyName,
                secretError: '',
                body: (secret) => { return { isUnsubscribe: true, subscriptionKey: key }; },
            }));
        }
        else {
            return new Promise((resolve) => resolve());
        }
    }
    /**
     * A generic utility function for sending requests to, and handling the responses from a `WorkerController` used when the `runInApp` property is set to `false`
     * @param type the type of worker event
     * @param opts Configurable options that defines how the request is sent and how the response is handled
     */
    sendRequest(type, opts) {
        const promise = new Promise((resolve, reject) => {
            if (this._isConnected || opts.isConnect) {
                try {
                    const noProperty = opts.workerProperty === undefined;
                    const secretResult = noProperty ? null : this.isSecret(typeof opts.workerProperty === 'string' ? this.worker[opts.workerProperty] : opts.workerProperty(this.worker), type);
                    if (secretResult || noProperty) {
                        // additional checks ---
                        if (opts.additionalConditions) {
                            for (const opt of opts.additionalConditions) {
                                if (!opt.if(secretResult)) {
                                    reject(opt.reject(secretResult));
                                    return;
                                }
                            }
                        }
                        // additional functionality ---
                        let additionalContext;
                        if (opts.beforeRequest) {
                            additionalContext = opts.beforeRequest(secretResult);
                        }
                        // response ----
                        const requestSecret = this.generateSecretKey();
                        const repsonseSubscription = this.responseEvent.subscribe((resp) => {
                            try {
                                let isValidReponse = resp.type === type && resp.requestSecret === requestSecret;
                                isValidReponse = noProperty ? isValidReponse : (isValidReponse && secretResult.propertyName === resp.propertyName);
                                if (isValidReponse) {
                                    if (!resp.isError) {
                                        // resolve ----
                                        this.removeSecretKey(requestSecret);
                                        if (opts.resolve) {
                                            resolve(opts.resolve(resp, secretResult, additionalContext));
                                        }
                                        else {
                                            resolve();
                                        }
                                        repsonseSubscription.unsubscribe();
                                    }
                                    else {
                                        // reject -----
                                        this.removeSecretKey(requestSecret);
                                        if (opts.beforeReject) {
                                            opts.beforeReject(resp, secretResult, additionalContext);
                                        }
                                        repsonseSubscription.unsubscribe();
                                        reject(JSON.parse(resp.error));
                                    }
                                }
                            }
                            catch (e) {
                                reject(e);
                            }
                        });
                        // send request -----
                        const req = {
                            requestSecret: requestSecret,
                            propertyName: noProperty ? null : secretResult.propertyName,
                            type: type,
                            body: opts.body ? opts.body(secretResult, additionalContext) : null
                        };
                        this.postMessage(req);
                    }
                    else {
                        reject(new Error(opts.secretError));
                    }
                }
                catch (e) {
                    reject(e);
                }
            }
            else {
                reject(new Error('WorkerClient: the WorkerClient.connect() method must be called before a worker can be accessed'));
            }
        });
        return promise;
    }
    /**
     * A wrapper function around the `Worker.postMessage()` method to catch any serialization errors should they occur
     * @param request the request to be sent to the worker
     */
    postMessage(request) {
        try {
            this.workerRef.postMessage(request);
        }
        catch (e) {
            throw new Error('Unable to serialize the request from the client to the worker');
        }
    }
    /**
     * A utility function to cast promises
     * @param promise promise to cast
     */
    castPromise(promise) {
        return promise;
    }
    /**
     * Creates client subscription reference with a subscription and an RxJS subject, adds it to the `observables` dictionary with unique key and then returns the key. Called from the `subscribe()` method.
     * @param propertyName the property name of the worker's RxJS subject that was subscribed to
     * @param next Callback function that is triggered when the subject's `next()` method is called
     * @param error Callback function that is triggered when the subject throws and error
     * @param complete Callback function that is triggered when the subject's `complete()` method is called
     */
    createSubscription(propertyName, next, error, complete) {
        const key = this.generateSubscriptionKey(propertyName);
        const subject = new Subject();
        const subscription = subject.subscribe(next, error, complete);
        this.observables[key] = { subject: subject, subscription: subscription, propertyName: propertyName, observable: null };
        return key;
    }
    /**
     * Creates client observable reference with a RxJS observable and subject, adds it to the `observables` dictionary with unique key and then returns the key. Called from the `observe()` method.
     * @param propertyName the property name of the worker's RxJS subject that was subscribed to
     */
    createObservable(propertyName) {
        const key = this.generateSubscriptionKey(propertyName);
        const subject = new Subject();
        this.observables[key] = { subject: subject, subscription: null, propertyName: propertyName, observable: subject.asObservable() };
        return key;
    }
    /**
     * Iterates through the `observables` dictionary to find the associated key for a particular subscription or observable. Returns null if no match is found
     * @param value Subscription or observable for which the dictionary key must be found
     */
    findObservableKey(value) {
        for (const key in this.observables) {
            if (value instanceof Subscription) {
                if (this.observables[key].subscription === value) {
                    return key;
                }
            }
            else {
                if (this.observables[key].observable === value) {
                    return key;
                }
            }
        }
        return null;
    }
    /**
     * Remove a subscription or observable reference from `observables` dictionary. Removed subscriptions are unsubsribed before destroyed
     * @param subscriptionKey unique key in the `observables` dictionary
     */
    removeSubscription(subscriptionKey) {
        if (this.observables[subscriptionKey]) {
            if (this.observables[subscriptionKey].subscription) {
                this.observables[subscriptionKey].subscription.unsubscribe();
            }
        }
        delete this.observables[subscriptionKey];
    }
    /**
     * Generates a random key
     * @param propertyName appended as the prefix to the key
     * @param length length of the randomly generated characters
     */
    generateKey(propertyName, length) {
        return `${propertyName.toUpperCase()}_${Array(length).fill(null).map(() => (Math.round(Math.random() * 16)).toString(16)).join('')}`;
    }
    /**
     * Creates a unique key for a subscription/observable reference for use in the `observables` dictionary. This key allows messages from the worker to be correctly mapped and handled in the client
     * @param propertyName property name of the worker's RxJS subject which is subscribed to. This is attached as a prefix to the unique key
     */
    generateSubscriptionKey(propertyName) {
        let key = this.generateKey(propertyName, 6);
        while (this.observables[key]) {
            key = this.generateKey(propertyName, 6);
        }
        return key;
    }
    /**
     * Creates a unique key for worker requests ensuring no two keys are avaliable at any time through the `secrets` array. Allows requests to be mapped to responses from
     * the worker
     * @param propertyName property name of the worker's property/method that is being called. This is attached as a prefix to the unique key
     */
    generateSecretKey(propertyName) {
        propertyName = propertyName ? propertyName : 'client';
        let key = this.generateKey(propertyName, 16);
        while (this.secrets.indexOf(key) !== -1) {
            key = this.generateKey(propertyName, 16);
        }
        this.secrets.push(key);
        return key;
    }
    /**
     * Removes a key from the `secrets` array if it exists
     * @param secret unqiue key to be removed
     */
    removeSecretKey(secret) {
        if (this.secrets.indexOf(secret) !== -1) {
            this.secrets.splice(this.secrets.indexOf(secret), 1);
        }
    }
    /**
     * Checks if a valid `SecretResult` is returned when a decorated property and/or method of the client instance of the worker class is called.
     *  Returns the secret when valid otherwise returns null
     * @param secretResult the returned value from calling the property or method of a client instance of a worker
     * @param type the worker event type that originated the request
     */
    isSecret(secretResult, type) {
        if (secretResult) {
            if (secretResult['clientSecret'] && secretResult['propertyName'] && secretResult['type']) {
                if (secretResult['clientSecret'] === this.workerSecret && secretResult['type'] === type) {
                    return secretResult;
                }
            }
        }
        return null;
    }
    /**
     * Creates the event listeners to listen for, and handle, messages recieved through `Worker.onmessage`
     */
    registerEvents() {
        this.responseEvent = new Subject();
        this.observables = {};
        this.workerRef.onmessage = (ev) => {
            switch (ev.data.type) {
                case WorkerEvents.ObservableMessage:
                    const body = ev.data.result;
                    if (this.observables[body.key]) {
                        switch (body.type) {
                            case WorkerObservableMessageTypes.Next:
                                this.observables[body.key].subject.next(body.value);
                                break;
                            case WorkerObservableMessageTypes.Error:
                                this.observables[body.key].subject.error(body.error);
                                break;
                            case WorkerObservableMessageTypes.Complete:
                                this.observables[body.key].subject.complete();
                        }
                    }
                    break;
                default:
                    this.responseEvent.next(ev.data);
            }
        };
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid29ya2VyLWNsaWVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItd2ViLXdvcmtlci9hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL3dvcmtlci1jbGllbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE9BQU8sRUFBRSxZQUFZLEVBQWMsTUFBTSxNQUFNLENBQUM7QUFFekQsT0FBTyxFQUNrQixZQUFZLEVBQUUsV0FBVyxFQUM5QyxpQkFBaUIsRUFLakIsNEJBQTRCLEVBQy9CLE1BQU0sMkJBQTJCLENBQUM7QUFFbkMsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBR3REOzs7O0dBSUc7QUFDSCxNQUFNLE9BQU8sWUFBWTtJQStCckI7Ozs7O09BS0c7SUFDSCxZQUFvQixVQUE0QixFQUFVLFdBQW9CLEtBQUssRUFBVSxlQUF3QixLQUFLO1FBQXRHLGVBQVUsR0FBVixVQUFVLENBQWtCO1FBQVUsYUFBUSxHQUFSLFFBQVEsQ0FBaUI7UUFBVSxpQkFBWSxHQUFaLFlBQVksQ0FBaUI7SUFDMUgsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsT0FBTztRQUNILElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ3BCLElBQUksQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO1lBQ2xCLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7WUFDN0MsSUFBSSxDQUFDLE1BQU0sR0FBRyxXQUFXLENBQUMsYUFBYSxDQUFXLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUNqRyxRQUFRLEVBQUUsSUFBSTtnQkFDZCxZQUFZLEVBQUUsSUFBSSxDQUFDLFlBQVk7YUFDbEMsQ0FBQyxDQUFDO1lBRUgsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUU7Z0JBQ2hCLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFD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QUFFO3dCQUM1QixRQUFRLElBQUksQ0FBQyxJQUFJLEVBQUU7NEJBQ2YsS0FBSyw0QkFBNEIsQ0FBQyxJQUFJO2dDQUNsQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztnQ0FDcEQsTUFBTTs0QkFDVixLQUFLLDRCQUE0QixDQUFDLEtBQUs7Z0NBQ25DLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dDQUNyRCxNQUFNOzRCQUNWLEtBQUssNEJBQTRCLENBQUMsUUFBUTtnQ0FDdEMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDO3lCQUNyRDtxQkFDSjtvQkFDRCxNQUFNO2dCQUNWO29CQUNJLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUN4QztRQUNMLENBQUMsQ0FBQztJQUdOLENBQUM7Q0FHSiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFN1YmplY3QsIFN1YnNjcmlwdGlvbiwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBXb3JrZXJDbGllbnRPYnNlcnZhYmxlc0RpY3QsIFdvcmtlckNsaWVudFJlcXVlc3RPcHRzIH0gZnJvbSAnLi93b3JrZXItY2xpZW50LXR5cGVzJztcclxuaW1wb3J0IHtcclxuICAgIFdvcmtlclJlc3BvbnNlRXZlbnQsIFdvcmtlckV2ZW50cywgV29ya2VyVXRpbHMsXHJcbiAgICBXb3JrZXJBbm5vdGF0aW9ucywgTm9uT2JzZXJ2YWJsZXNPbmx5LCBBY2Nlc3NhYmxlTWV0YURhdGEsIEZ1bmN0aW9uc09ubHksXHJcbiAgICBDYWxsYWJsZU1ldGFEYXRhLCBPYnNlcnZhYmxlc09ubHksIFdvcmtlck9ic2VydmFibGVUeXBlLCBXb3JrZXJSZXF1ZXN0RXZlbnQsXHJcbiAgICBTZWNyZXRSZXN1bHQsXHJcbiAgICBXb3JrZXJFdmVudCxcclxuICAgIFdvcmtlck9ic2VydmFibGVNZXNzYWdlLFxyXG4gICAgV29ya2VyT2JzZXJ2YWJsZU1lc3NhZ2VUeXBlc1xyXG59IGZyb20gJ2FuZ3VsYXItd2ViLXdvcmtlci9jb21tb24nO1xyXG5pbXBvcnQgeyBXb3JrZXJEZWZpbml0aW9uIH0gZnJvbSAnLi93b3JrZXIubW9kdWxlJztcclxuaW1wb3J0IHsgQ2xpZW50V2ViV29ya2VyIH0gZnJvbSAnLi9jbGllbnQtd2ViLXdvcmtlcic7XHJcblxyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGFuIEFuZ3VsYXIgYXBwIHRvIGFjY2VzcyB0aGUgcHJvcGVydGllcywgY2FsbCB0aGUgbWV0aG9kcyBhbmQgc3Vic2NyaWJlIHRvIHRoZSBldmVudHMgaW4gYSB3ZWIgd29ya2VyIGJ5IG1hbmFnaW5nXHJcbiAqIHRoZSBjb21tdW5pY2F0aW9uIGJldHdlZW4gdGhlIGFwcCBhbmQgdGhlIHdvcmtlci4gQWxzbyBwcm92aWRlcyB0aGUgb3B0aW9uIHRvIGV4ZWN1dGUgdGhlIHdvcmtlciBjb2RlIHdpdGhpbiB0aGUgYXBwIHNob3VsZCB0aGUgYnJvd3NlciBub3Qgc3VwcG9ydCB3ZWIgd29ya2VycyxcclxuICogYWx0aG91Z2ggaW50ZW5zaXZlIHdvcmsgbWF5IHRoZW4gYmxvY2sgdGhlIFVJLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFdvcmtlckNsaWVudDxUPiB7XHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgYnJvd3NlcidzIHdvcmtlciBjbGFzcyBmb3IgcG9zdGluZyBtZXNzYWdlcyBhbmQgdGVybWluYXRpbmcgdGhlIHdvcmtlclxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHdvcmtlclJlZjogV29ya2VyIHwgQ2xpZW50V2ViV29ya2VyPFQ+O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY2xpZW50IGluc3RhbmNlIG9mIHRoZSB3b3JrZXIgY2xhc3NcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB3b3JrZXI6IFQ7XHJcbiAgICAvKipcclxuICAgICAqIEEgc2VjcmV0IGtleSB0aGF0IG11c3QgYmUgcmV0dXJuZWQgd2hlbiBkZWNvcmF0ZWQgcHJvcGVydGllcyBhbmQvb3IgbWV0aG9kcyBhcmUgY2FsbGVkIGZyb20gdGhlIGNsaWVudCBpbnN0YW5jZSBvZiB0aGUgd29ya2VyIGNsYXNzXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgd29ya2VyU2VjcmV0Pzogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcnJheSBvZiBzZWNyZXQga2V5cyBjb250YWluaW5nIHRoZSBgd29ya2VyU2VjcmV0YCBhbmQgYFdvcmtlclJlcXVlc3RFdmVudC5yZXF1ZXN0U2VjcmV0YHMgZW5zdXJpbmcgdGhhdCB0aGVyZSBhcmUgbmV2ZXIgdHdvIG9mIHRoZSBzYW1lIGtleXMgYXQgYW55IHBvaW50IGluIHRpbWVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzZWNyZXRzOiBzdHJpbmdbXTtcclxuICAgIC8qKlxyXG4gICAgICogQW4gZXZlbnQgc3ViamVjdCB0aGF0IGlzIHRyaWdnZXJlZCBlYWNoIHRpbWUgYSByZXNwb25zZSBpcyByZWNpZXZlZCBmcm9tIGEgYFdvcmtlckNvbnRyb2xsZXJgLiBUaGlzIGlzIHN1YnNjcmliZWQgdG8gaW1tZWRpYXRlbHkgYmVmb3JlIGFueSByZXF1ZXN0IGlzIG1hZGUgaW4gdGhlIGBzZW5kUmVxdWVzdCgpYCBtZXRob2QuXHJcbiAgICAgKiBUaGlzIGFsbG93cyB0aGUgYFdvcmtlci5vbm1lc3NhZ2VgIGxpc3RlbmVyIHRvIGJlIG1hcHBlZCBiYWNrIHRvIGFuIGFzeW5jIGZ1bmN0aW9uIGNhbGwgZnJvbSB3aGVyZSB0aGUgcmVxdWVzdCBvcmlnaW5hdGVkXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVzcG9uc2VFdmVudDogU3ViamVjdDxXb3JrZXJSZXNwb25zZUV2ZW50PFdvcmtlckV2ZW50cy5DYWxsYWJsZSB8IFdvcmtlckV2ZW50cy5BY2Nlc3NhYmxlIHwgV29ya2VyRXZlbnRzLk9ic2VydmFibGUgfCBXb3JrZXJFdmVudHMuT2JzZXJ2YWJsZU1lc3NhZ2U+PjtcclxuICAgIC8qKlxyXG4gICAgICogQSBkaWN0aW9uYXJ5IG9mIG9ic2VydmFibGUgcmVmZXJlbmNlcyB0aGF0IGxpc3RlbiBmb3IgZXZlbnRzIHRyaWdnZXJlZCBieSB0aGUgd29ya2VyIGFmdGVyIHRoZXkgaGF2ZSBiZWVuIHN1YnNjcmliZWQgb3Igb2JzZXJ2ZWQgdGhyb3VnaCB0aGUgdXNlIG9mIGVpdGhlciB0aGUgYHN1YnNjcmliZSgpYCBvciBgb2JzZXJ2ZWAgbWV0aG9kc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIG9ic2VydmFibGVzOiBXb3JrZXJDbGllbnRPYnNlcnZhYmxlc0RpY3Q7XHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhlIHdvcmtlciBpcyBhY3RpdmUgYWZ0ZXIgaXQgaXMgY3JlYXRlZCB3aXRoIHRoZSBgY29ubmVjdCgpYCBtZXRob2QgYW5kIGJlZm9yZSBpdCBoYXMgYmVlbiB0ZXJtaW5hdGVkIGJ5IHRoZSBgZGVzdHJveSgpYCBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfaXNDb25uZWN0ZWQ6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBXb3JrZXJDbGllbnRgXHJcbiAgICAgKiBAcGFyYW0gZGVmaW5pdGlvbiB0aGUgd29ya2VyIGRlZmludGlvbiBvcmlnaW5hdGluZyBmcm9tIHRoZSBhcmd1bWVudHMgb2YgdGhlIGBXb3JrZXJNb2R1bGUuZm9yV29ya2VycygpYCBtZXRob2RcclxuICAgICAqIEBwYXJhbSBydW5JbkFwcCB3aGV0aGVyIHRoZSBleGVjdXRpb24gb2YgdGhlIHdvcmtlciB3aWxsIG9jY3VyIGluIHRoZSBhcHAgb3Igd2l0aGluIHRoZSB3b3JrZXIgc2NyaXB0XHJcbiAgICAgKiBAcGFyYW0gcnVuSW5BcHAgd2hldGhlciB0aGUgY2xpZW50IGlzIHVzZWQgZm9yIHVuaXQgdGVzdGluZyB3aGljaCBkZXRlcm1pbmVzIGlmIHNlcmlhbGl6YXRpb24gc2hvdWxkIGJlIG1vY2tlZFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRlZmluaXRpb246IFdvcmtlckRlZmluaXRpb24sIHByaXZhdGUgcnVuSW5BcHA6IGJvb2xlYW4gPSBmYWxzZSwgcHJpdmF0ZSBpc1Rlc3RDbGllbnQ6IGJvb2xlYW4gPSBmYWxzZSkge1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyB3b3JrZXIgc2NyaXB0IGluIHRoZSBicm93c2VyLCBvciB3aXRoaW4gdGhlIGFwcCwgYW5kIHRyaWdnZXJzIHRoZSBgT25Xb3JrZXJJbml0YCBob29rLCBpZiBpbXBsZW1lbnRlZC4gSWYgdGhlIGhvb2sgaXMgaW1wbGVtZW50ZWQgdGhlIHByb21pc2Ugd2lsbCBvbmx5IGJlIHJlc29sdmVkIG9uY2UgYG9uV29ya2VySW5pdGAgbWV0aG9kXHJcbiAgICAgKiBoYXMgY29tcGxldGVkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBpdCBpcyBhc3luYyBvciBub3RcclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBtdXN0IGNhbGxlZCBiZWZvcmUgYW55IHdvcmtlciBtZXRob2RzIGFuZC9vciBwcm9wZXJ0aWVzIGNhbiBiZSBjYWxsZWQvYWNjZXNzZWRcclxuICAgICAqL1xyXG4gICAgY29ubmVjdCgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBpZiAoIXRoaXMuX2lzQ29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VjcmV0cyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLndvcmtlclNlY3JldCA9IHRoaXMuZ2VuZXJhdGVTZWNyZXRLZXkoKTtcclxuICAgICAgICAgICAgdGhpcy53b3JrZXIgPSBXb3JrZXJVdGlscy5nZXRBbm5vdGF0aW9uPEZ1bmN0aW9uPih0aGlzLmRlZmluaXRpb24ud29ya2VyLCBXb3JrZXJBbm5vdGF0aW9ucy5GYWN0b3J5KSh7XHJcbiAgICAgICAgICAgICAgICBpc0NsaWVudDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNsaWVudFNlY3JldDogdGhpcy53b3JrZXJTZWNyZXRcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMucnVuSW5BcHApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud29ya2VyUmVmID0gdGhpcy5kZWZpbml0aW9uLmluaXRGbigpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53b3JrZXJSZWYgPSBuZXcgQ2xpZW50V2ViV29ya2VyKHRoaXMuZGVmaW5pdGlvbi53b3JrZXIsIHRoaXMuaXNUZXN0Q2xpZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyRXZlbnRzKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYXN0UHJvbWlzZTx2b2lkPih0aGlzLnNlbmRSZXF1ZXN0KFdvcmtlckV2ZW50cy5Jbml0LCB7XHJcbiAgICAgICAgICAgICAgICBib2R5OiAoKSA9PiBudWxsLFxyXG4gICAgICAgICAgICAgICAgaXNDb25uZWN0OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzQ29ubmVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNlY3JldEVycm9yOiAnQ291bGQgbm90IGluaXRpYWxpc2Ugd29ya2VyJ1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVybWluYXRlcyB0aGUgd29ya2VyIGFuZCB1bnN1YnNjcmliZXMgZnJvbSBhbnkgc3Vic2NyaXB0aW9ucyBjcmVhdGVkIGZyb20gdGhlIGBzdWJzY3JpYmUoKWAgbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5vYnNlcnZhYmxlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub2JzZXJ2YWJsZXNba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlU3Vic2NyaXB0aW9uKGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy53b3JrZXJSZWYudGVybWluYXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2VjcmV0cyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmFibGVzID0ge307XHJcbiAgICAgICAgICAgIHRoaXMud29ya2VyID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5faXNDb25uZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSB3b3JrZXIgaXMgYWN0aXZlIGFmdGVyIGl0IGlzIGNyZWF0ZWQgd2l0aCB0aGUgYGNvbm5lY3QoKWAgbWV0aG9kIGFuZCBiZWZvcmUgaXQgaGFzIGJlZW4gdGVybWluYXRlZCBieSB0aGUgYGRlc3Ryb3koKWAgbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIGdldCBpc0Nvbm5lY3RlZCgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNDb25uZWN0ZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIHdvcmtlciBwcm9wZXJ0eSB0aGF0IGhhcyBiZWVuIGRlY29yYXRlZCB3aXRoIGBAQWNjZXNzYWJsZSgpYC4gVW5kZWNvcmF0ZWQgcHJvcGVydGllcyB3aWxsIGNhdXNlIHRoZSBwcm9taXNlIHRvIGJlIHJlamVjdGVkXHJcbiAgICAgKiBAU2VyaWFsaXplZFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGFzeW5jIGF3YWl0IHN5bnRheCAtLS1cclxuICAgICAqIGNvbnN0IG5hbWU6IHN0cmluZyA9IGF3YWl0IGNsaWVudC5nZXQodyA9PiB3Lm5hbWUpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHByb21pc2Ugc3ludGF4IC0tLVxyXG4gICAgICogY2xpZW50LmdldCh3ID0+IHcubmFtZSkudGhlbigobmFtZSkgPT4ge1xyXG4gICAgICogICBjb25zb2xlLmxvZyhuYW1lKTtcclxuICAgICAqIH0pLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAqICAgY29uc29sZS5sb2coZXJyKTtcclxuICAgICAqIH0pO1xyXG4gICAgICogQHBhcmFtIHByb3BlcnR5IEEgbGFtZGEgZXhwcmVzc2lvbiB0aGF0IHJldHVybnMgdGhlIHRhcmdldGVkIHByb3BlcnR5IG9mIHRoZSB3b3JrZXIuIFRoZSB3b3JrZXIgYXJndW1lbnQgaW4gdGhlIGV4cHJlc3Npb24gb25seSBoYXMgdGhlIHByb3BlcnRpZXMgb3duZWQgYnkgdGhlIHdvcmtlciBjbGFzcyAobm8gbWV0aG9kcylcclxuICAgICAqIGFuZCBvbmx5IHRob3NlIHByb3BlcnRpZXMgdGhhdCBhcmUgbm90IFJ4SlMgc3ViamVjdHNcclxuICAgICAqL1xyXG4gICAgZ2V0PFByb3BlcnR5VHlwZT4oXHJcbiAgICAgICAgcHJvcGVydHk6ICh3b3JrZXJQcm9wZXJ0aWVzOiBOb25PYnNlcnZhYmxlc09ubHk8VD4pID0+IFByb3BlcnR5VHlwZVxyXG4gICAgKTogUHJvbWlzZTxQcm9wZXJ0eVR5cGU+IHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3QoV29ya2VyRXZlbnRzLkFjY2Vzc2FibGUsIHtcclxuICAgICAgICAgICAgd29ya2VyUHJvcGVydHk6IHByb3BlcnR5LFxyXG4gICAgICAgICAgICBhZGRpdGlvbmFsQ29uZGl0aW9uczogW3tcclxuICAgICAgICAgICAgICAgIGlmOiAoc2VjcmV0KSA9PiBzZWNyZXQuYm9keS5nZXQsXHJcbiAgICAgICAgICAgICAgICByZWplY3Q6IChzZWNyZXQpID0+IG5ldyBFcnJvcihgV29ya2VyQ2xpZW50OiB3aWxsIG5vdCBhcHBseSB0aGUgZ2V0IG1ldGhvZCB0byB0aGUgXCIke3NlY3JldC5wcm9wZXJ0eU5hbWV9XCIgcHJvcGVydHkgYmVjYXVzZSB0aGUgZ2V0IGFjY2Vzc29yIGhhcyBiZWVuIGV4cGxpY2l0eSBzZXQgdG8gZmFsc2VgKVxyXG4gICAgICAgICAgICB9XSxcclxuICAgICAgICAgICAgc2VjcmV0RXJyb3I6ICdXb3JrZXJDbGllbnQ6IG9ubHkgcHJvcGVydGllcyBkZWNvcmF0ZWQgd2l0aCBAQWNjZXNzYWJsZSgpIGNhbiBiZSB1c2VkIGluIHRoZSBnZXQgbWV0aG9kJyxcclxuICAgICAgICAgICAgYm9keTogKCkgPT4geyByZXR1cm4geyBpc0dldDogdHJ1ZSB9OyB9LFxyXG4gICAgICAgICAgICByZXNvbHZlOiAocmVzcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YURhdGEgPSBXb3JrZXJVdGlscy5nZXRBbm5vdGF0aW9uPEFjY2Vzc2FibGVNZXRhRGF0YVtdPih0aGlzLmRlZmluaXRpb24ud29ya2VyLCBXb3JrZXJBbm5vdGF0aW9ucy5BY2Nlc3NhYmxlcykuZmlsdGVyKHggPT4geC5uYW1lID09PSByZXNwLnByb3BlcnR5TmFtZSlbMF07XHJcbiAgICAgICAgICAgICAgICBpZiAobWV0YURhdGEuc2hhbGxvd1RyYW5zZmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFEYXRhLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFEYXRhLnR5cGUucHJvdG90eXBlICYmIHJlc3AucmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwLnJlc3VsdC5fX3Byb3RvX18gPSBtZXRhRGF0YS50eXBlLnByb3RvdHlwZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcC5yZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHZhbHVlIG9mIGEgd29ya2VyIHByb3BlcnR5IHRoYXQgaGFzIGJlZW4gZGVjb3JhdGVkIHdpdGggYEBBY2Nlc3NhYmxlKClgLiBVbmRlY29yYXRlZCBwcm9wZXJ0aWVzIHdpbGwgY2F1c2UgdGhlIHByb21pc2UgdG8gYmUgcmVqZWN0ZWRcclxuICAgICAqIEBTZXJpYWxpemVkXHJcblxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGFzeW5jIGF3YWl0IHN5bnRheCAtLS1cclxuICAgICAqIGF3YWl0IGNsaWVudC5zZXQodyA9PiB3Lm5hbWUsICdwZXRlcicpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHByb21pc2Ugc3ludGF4IC0tLVxyXG4gICAgICogY2xpZW50LnNldCh3ID0+IHcubmFtZSwgJ3BldGVyJykudGhlbigoKSA9PiB7XHJcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdwcm9wZXJ0eSBoYXMgYmVlbiBzZXQnKTtcclxuICAgICAqIH0pLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAqICAgY29uc29sZS5sb2coZXJyKTtcclxuICAgICAqIH0pO1xyXG4gICAgICogQHBhcmFtIHByb3BlcnR5IEEgbGFtZGEgZXhwcmVzc2lvbiB0aGF0IHJldHVybnMgdGhlIHRhcmdldGVkIHByb3BlcnR5IG9mIHRoZSB3b3JrZXIuIFRoZSB3b3JrZXIgYXJndW1lbnQgaW4gdGhlIGV4cHJlc3Npb24gb25seSBoYXMgdGhlIHByb3BlcnRpZXMgb3duZWQgYnkgdGhlIHdvcmtlciBjbGFzcyAobm8gbWV0aG9kcylcclxuICAgICAqIGFuZCBvbmx5IHRob3NlIHByb3BlcnRpZXMgdGhhdCBhcmUgbm90IFJ4SlMgc3ViamVjdHNcclxuICAgICAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgd2hpY2ggdGhlIHByb3BlcnR5IHNob3VsZCBiZSBzZXQgdG9cclxuICAgICAqL1xyXG4gICAgc2V0PFByb3BlcnR5VHlwZT4oXHJcbiAgICAgICAgcHJvcGVydHk6ICh3b3JrZXJQcm9wZXJ0aWVzOiBOb25PYnNlcnZhYmxlc09ubHk8VD4pID0+IFByb3BlcnR5VHlwZSxcclxuICAgICAgICB2YWx1ZTogUHJvcGVydHlUeXBlXHJcbiAgICApOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYXN0UHJvbWlzZTx2b2lkPih0aGlzLnNlbmRSZXF1ZXN0KFdvcmtlckV2ZW50cy5BY2Nlc3NhYmxlLCB7XHJcbiAgICAgICAgICAgIHdvcmtlclByb3BlcnR5OiBwcm9wZXJ0eSxcclxuICAgICAgICAgICAgYWRkaXRpb25hbENvbmRpdGlvbnM6IFt7XHJcbiAgICAgICAgICAgICAgICBpZjogKHNlY3JldCkgPT4gc2VjcmV0LmJvZHkuc2V0LFxyXG4gICAgICAgICAgICAgICAgcmVqZWN0OiAoc2VjcmV0KSA9PiBuZXcgRXJyb3IoYFdvcmtlckNsaWVudDogd2lsbCBub3QgYXBwbHkgdGhlIHNldCBtZXRob2QgdG8gdGhlIFwiJHtzZWNyZXQucHJvcGVydHlOYW1lfVwiIHByb3BlcnR5IGJlY2F1c2UgdGhlIHNldCBhY2Nlc3NvciBoYXMgYmVlbiBleHBsaWNpdHkgc2V0IHRvIGZhbHNlYClcclxuICAgICAgICAgICAgfV0sXHJcbiAgICAgICAgICAgIHNlY3JldEVycm9yOiAnV29ya2VyQ2xpZW50OiBvbmx5IHByb3BlcnRpZXMgZGVjb3JhdGVkIHdpdGggQEFjY2Vzc2FibGUoKSBjYW4gYmUgdXNlZCBpbiB0aGUgc2V0IG1ldGhvZCcsXHJcbiAgICAgICAgICAgIGJvZHk6ICgpID0+IHsgcmV0dXJuIHsgaXNHZXQ6IGZhbHNlLCB2YWx1ZTogdmFsdWUgfTsgfVxyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxzIGEgbWV0aG9kIGluIHRoZSB3b3JrZXIgYW5kIHJldHVybnMgaXRzIHZhbHVlLiBUaGUgY2FsbGVkIG1ldGhvZCBjYW4gYmUgZWl0aGVyIHN5bmNocm9ub3VzIG9yIGFzeW5jaHJvbm91c1xyXG4gICAgICogYnV0IG11c3QgYmUgZGVjb3JhdGVkIHdpdGggYEBDYWxsYWJsZSgpYCBlbHNlIHRoZSBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWRcclxuICAgICAqIEBTZXJpYWxpemVkIEFwcGxpZXMgdG8gYm90aCB0aGUgZnVuY3Rpb24gYXJndW1lbnRzIGFuZCB0aGUgcmV0dXJuZWQgdmFsdWVcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBhc3luYyBhd2FpdCBzeW50YXggLS0tXHJcbiAgICAgKiBjb25zdCBmdW5jdGlvblJlc3VsdDogU29tZVJlc3VsdFR5cGUgPSBhd2FpdCBjbGllbnQuY2FsbCh3ID0+IHcuZG9Tb21lV29yaygnc29tZUFyZ3VtZW50JywgMjEyMykpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHByb21pc2Ugc3ludGF4IC0tLVxyXG4gICAgICogY2xpZW50LmNhbGwodyA9PiB3LmRvU29tZVdvcmsoJ3NvbWVBcmd1bWVudCcsIDIxMjMpKS50aGVuKChyZXN1bHQpID0+IHtcclxuICAgICAqICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XHJcbiAgICAgKiB9KS5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgKiAgICBjb25zb2xlLmxvZyhlcnIpO1xyXG4gICAgICogfSk7XHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydHkgQSBsYW1kYSBleHByZXNzaW9uIHRoYXQgY2FsbHMgdGhlIHdvcmtlciBtZXRob2QuIFRoZSB3b3JrZXIgYXJndW1lbnQgaW4gdGhlIGV4cHJlc3Npb24gb25seSBoYXMgdGhlIG1ldGhvZHMgb3duZWQgYnkgdGhlIHdvcmtlciBjbGFzcyAobm90IHRoZSBwcm9wZXJ0aWVzKVxyXG4gICAgICovXHJcbiAgICBjYWxsPFJldHVyblR5cGU+KFxyXG4gICAgICAgIGNhbGxGbjogKHdvcmtlckZ1bmN0aW9uczogRnVuY3Rpb25zT25seTxUPikgPT4gUmV0dXJuVHlwZVxyXG4gICAgKTogUmV0dXJuVHlwZSBleHRlbmRzIFByb21pc2U8YW55PiA/IFJldHVyblR5cGUgOiBQcm9taXNlPFJldHVyblR5cGU+IHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3QoV29ya2VyRXZlbnRzLkNhbGxhYmxlLCB7XHJcbiAgICAgICAgICAgIHdvcmtlclByb3BlcnR5OiBjYWxsRm4sXHJcbiAgICAgICAgICAgIHNlY3JldEVycm9yOiAnV29ya2VyQ2xpZW50OiBvbmx5IG1ldGhvZHMgZGVjb3JhdGVkIHdpdGggQENhbGxhYmxlKCkgY2FuIGJlIHVzZWQgaW4gdGhlIGNhbGwgbWV0aG9kJyxcclxuICAgICAgICAgICAgYm9keTogKHNlY3JldCkgPT4geyByZXR1cm4geyBhcmd1bWVudHM6IHNlY3JldC5ib2R5LmFyZ3MgfTsgfSxcclxuICAgICAgICAgICAgcmVzb2x2ZTogKHJlc3ApID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFEYXRhID0gV29ya2VyVXRpbHMuZ2V0QW5ub3RhdGlvbjxDYWxsYWJsZU1ldGFEYXRhW10+KHRoaXMuZGVmaW5pdGlvbi53b3JrZXIsIFdvcmtlckFubm90YXRpb25zLkNhbGxhYmxlcywgW10pLmZpbHRlcih4ID0+IHgubmFtZSA9PT0gcmVzcC5wcm9wZXJ0eU5hbWUpWzBdO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1ldGFEYXRhLnNoYWxsb3dUcmFuc2Zlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhRGF0YS5yZXR1cm5UeXBlID09PSBQcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya2VyQ2xpZW50OiBzaGFsbG93VHJhbnNmZXIgd2lsbCBub3QgYmUgdHJ1ZSBpbiB0aGUgQENhbGxhYmxlKCkgZGVjb3JhdG9yIHdoZW4gdGhlIGRlY29yYXRlZCBtZXRob2QgcmV0dXJucyBhIHByb21pc2UnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFEYXRhLnJldHVyblR5cGUgJiYgcmVzcC5yZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcC5yZXN1bHQuX19wcm90b19fID0gbWV0YURhdGEucmV0dXJuVHlwZS5wcm90b3R5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3AucmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlcyB0byBhIHdvcmtlcidzIFJ4SlMgc3ViamVjdCwgd2hpY2ggaGFzIGJlZW4gZGVjb3JhdGVkIHdpdGggYEBTdWJzY3JpYmFibGUoKWAsIGFuZCB0aGVuIHJldHVybnMgdGhpcyBzdWJzY3JpcHRpb24uXHJcbiAgICAgKiAgU3VwcG9ydHMgYWxsIGZvdXIgUnhKUyBzdWJqZWN0cyBiZWluZyBgU3ViamVjdGAsICBgQmVoYXZpb3JTdWJqZWN0YCwgYFJlcGxheVN1YmplY3RgIGFuZCBgQXN5bmNTdWJqZWN0YC5cclxuICAgICAqXHJcbiAgICAgKiAqKlVOU1VCU0NSSUJJTkcqKlxyXG4gICAgICpcclxuICAgICAqIFdoaWxlIHRoZSByZXR1cm5lZCBzdWJzY3JpcHRpb24gY2FuIGJlIGRlc3Ryb3llZCB3aXRoIGBTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKWAgdGhpcyBpcyBvbmx5IGRlc3Ryb3lzIHRoZSBjbGllbnQgc3Vic2NyaXB0aW9uLiBBIHN1YnNjcmlwdGlvbiBpcyBhbHNvIGNyZWF0ZWQgaW4gdGhlIHdvcmtlci5cclxuICAgICAqIFRvIHJlbGVhc2UgdGhlIHJlc291cmNlcyBpbiBib3RoIHRoZSBjbGllbnQgYW5kIHRoZSB3b3JrZXIgdGhlIGBXb3JrZXJDbGllbnQudW5zdWJzY3JpYmUoc3Vic2NyaXB0aW9uKWAgbWV0aG9kIHNob3VsZCBiZSB1c2VkLiBUaGUgYFdvcmtlckNsaWVudC5kZXN0cm95KClgIG1ldGhvZCB3aWxsXHJcbiAgICAgKiBkaXNwb3NlIG9mIGFsbCBzdWJzY3JpcHRpb25zIGNvcnJlY3RseS5cclxuICAgICAqXHJcbiAgICAgKiBAU2VyaWFsaXplZCBUaGlzIGFwcGxpZXMgdG8gbWVzc2FnZXMgcG9zdGVkIHRocm91Z2ggYFN1YmplY3QubmV4dCgpYFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGFzeW5jIGF3YWl0IHN5bnRheCAtLS1cclxuICAgICAqIHRoaXMud29ya2VyU3Vic2NyaXB0aW9uID0gYXdhaXQgY2xpZW50LnN1YnNjcmliZSh3ID0+IHcuc29tZUV2ZW50U3ViamVjdCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gcHJvbWlzZSBzeW50YXggLS0tXHJcbiAgICAgKiBjbGllbnQuc3Vic2NyaWJlKHcgPT4gdy5zb21lRXZlbnRTdWJqZWN0KS50aGVuKChzdWJzY3JpcHRpb24pID0+IHtcclxuICAgICAqICAgIHRoaXMud29ya2VyU3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uO1xyXG4gICAgICogfSkuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICogICAgY29uc29sZS5sb2coZXJyKTtcclxuICAgICAqIH0pO1xyXG4gICAgICpcclxuICAgICAqIC8vIHVuc3Vic2NyaWJpbmcgLS0tLS0tLS1cclxuICAgICAqIGF3YWl0IGNsaWVudC51bnN1YnNjcmliZSh0aGlzLndvcmtlclN1YnNjcmlwdGlvbilcclxuICAgICAqIEBwYXJhbSBvYnNlcnZhYmxlIEEgbGFtZGEgZXhwcmVzc2lvbiB0aGF0IHJldHVybnMgdGhlIHRhcmdldGVkIFJ4SlMgc3ViamVjdCBvZiB0aGUgd29ya2VyLiBUaGUgd29ya2VyIGFyZ3VtZW50IGluIHRoZSBleHByZXNzaW9uIG9ubHkgaGFzIHRoZSBwcm9wZXJ0aWVzIG93bmVkIGJ5IHRoZSB3b3JrZXIgY2xhc3MgKG5vIG1ldGhvZHMpXHJcbiAgICAgKiBhbmQgb25seSB0aG9zZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIFJ4SlMgc3ViamVjdHNcclxuICAgICAqIEBwYXJhbSBuZXh0IENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIHN1YmplY3QncyBgbmV4dCgpYCBtZXRob2QgaXMgY2FsbGVkIHdpdGhpbiB0aGUgd29ya2VyXHJcbiAgICAgKiBAcGFyYW0gZXJyb3IgQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgc3ViamVjdCB0aHJvd3MgYW5kIGVycm9yXHJcbiAgICAgKiBAcGFyYW0gY29tcGxldGUgQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgc3ViamVjdCdzIGBjb21wbGV0ZSgpYCBtZXRob2QgaXMgY2FsbGVkIHdpdGhpbiB0aGUgd29ya2VyXHJcbiAgICAgKi9cclxuICAgIHN1YnNjcmliZTxPYnNlcnZhYmxlVHlwZT4oXHJcbiAgICAgICAgb2JzZXJ2YWJsZTogKHdvcmtlck9ic2VydmFibGVzOiBPYnNlcnZhYmxlc09ubHk8VD4pID0+IFdvcmtlck9ic2VydmFibGVUeXBlPE9ic2VydmFibGVUeXBlPixcclxuICAgICAgICBuZXh0OiAodmFsdWU6IE9ic2VydmFibGVUeXBlKSA9PiB2b2lkLFxyXG4gICAgICAgIGVycm9yPzogKGVycm9yOiBhbnkpID0+IHZvaWQsXHJcbiAgICAgICAgY29tcGxldGU/OiAoKSA9PiB2b2lkXHJcbiAgICApOiBQcm9taXNlPFN1YnNjcmlwdGlvbj4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhc3RQcm9taXNlPFN1YnNjcmlwdGlvbj4odGhpcy5zZW5kUmVxdWVzdChXb3JrZXJFdmVudHMuT2JzZXJ2YWJsZSwge1xyXG4gICAgICAgICAgICB3b3JrZXJQcm9wZXJ0eTogb2JzZXJ2YWJsZSxcclxuICAgICAgICAgICAgc2VjcmV0RXJyb3I6ICdXb3JrZXJDbGllbnQ6IG9ubHkgbWV0aG9kcyBkZWNvcmF0ZWQgd2l0aCBAQ2FsbGFibGUoKSBjYW4gYmUgdXNlZCBpbiB0aGUgY2FsbCBtZXRob2QnLFxyXG4gICAgICAgICAgICBiZWZvcmVSZXF1ZXN0OiAoc2VjcmV0KSA9PiB0aGlzLmNyZWF0ZVN1YnNjcmlwdGlvbihzZWNyZXQucHJvcGVydHlOYW1lLCBuZXh0LCBlcnJvciwgY29tcGxldGUpLFxyXG4gICAgICAgICAgICBib2R5OiAoc2VjcmV0LCBrZXkpID0+IHsgcmV0dXJuIHsgaXNVbnN1YnNjcmliZTogZmFsc2UsIHN1YnNjcmlwdGlvbktleToga2V5IH07IH0sXHJcbiAgICAgICAgICAgIHJlc29sdmU6IChyZXNwLCBzZWNyZXQsIGtleSkgPT4gdGhpcy5vYnNlcnZhYmxlc1trZXldLnN1YnNjcmlwdGlvbixcclxuICAgICAgICAgICAgYmVmb3JlUmVqZWN0OiAocmVzcCwgc2VjcmV0LCBrZXkpID0+IHRoaXMucmVtb3ZlU3Vic2NyaXB0aW9uKGtleSlcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgUnhKUyBvYnNlcnZhYmxlIHRoYXQgaXMgaW4gc3luYyB3aXRoIGEgUnhKUyBzdWJqZWN0IHdpdGhpbiBhIHdvcmtlci4gVGhlIHdvcmtlciBzdWJqZWN0IG11c3QgYmUgZGVjb3JhdGVkIHdpdGggYEBTdWJzY3JpYmFibGUoKWAgb3RoZXJ3aXNlIHRoZVxyXG4gICAgICogcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkLiBTdXBwb3J0cyBhbGwgZm91ciBSeEpTIHN1YmplY3RzIGJlaW5nLCBgU3ViamVjdGAsICBgQmVoYXZpb3JTdWJqZWN0YCwgYFJlcGxheVN1YmplY3RgIGFuZCBgQXN5bmNTdWJqZWN0YC5cclxuICAgICAqXHJcbiAgICAgKiAqKlVOU1VCU0NSSUJJTkcqKlxyXG4gICAgICpcclxuICAgICAqIFdoaWxlIHVuZGVyIG5vcm1hbCBjaXJjdW1zdGFuY2VzIHlvdSBkb24ndCBuZWVkIHRvIHVuc3Vic2NyaWJlIGZyb20gYW4gUnhKUyBvYnNlcnZhYmxlLCB3aGVuIGFuIG9ic2VydmFibGUgaXMgY3JlYXRlZCBmcm9tIGEgd29ya2VyIHN1YmplY3QgYSBzdWJzY3JpcHRpb24gaXMgYWxzbyBjcmVhdGVkIGluIHRoZSB3b3JrZXIuXHJcbiAgICAgKiBUbyByZWxlYXNlIHRoZSByZXNvdXJjZXMgaW4gdGhlIHdvcmtlciB0aGUgYFdvcmtlckNsaWVudC51bnN1YnNjcmliZShvYnNlcnZhYmxlKWAgbWV0aG9kIHNob3VsZCBiZSB1c2VkLiBUaGUgYFdvcmtlckNsaWVudC5kZXN0cm95KClgIG1ldGhvZCB3aWxsXHJcbiAgICAgKiBkaXNwb3NlIG9mIGFsbCBvYnNlcnZhYmxlcyBjb3JyZWN0bHkuXHJcbiAgICAgKlxyXG4gICAgICogQFNlcmlhbGl6ZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBhc3luYyBhd2FpdCBzeW50YXggLS0tXHJcbiAgICAgKiB0aGlzLm9ic2VydmFibGUkID0gYXdhaXQgY2xpZW50Lm9ic2VydmUodyA9PiB3LnNvbWVFdmVudFN1YmplY3QpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHByb21pc2Ugc3ludGF4IC0tLVxyXG4gICAgICogY2xpZW50Lm9ic2VydmUodyA9PiB3LnNvbWVFdmVudFN1YmplY3QpLnRoZW4oKG9ic2VydmFibGUpID0+IHtcclxuICAgICAqICAgdGhpcy5vYnNlcnZhYmxlJCA9IG9ic2VydmFibGU7XHJcbiAgICAgKiB9KS5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgKiAgICBjb25zb2xlLmxvZyhlcnIpO1xyXG4gICAgICogfSk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gdW5zdWJzY3JpYmluZyAtLS0tLS0tLVxyXG4gICAgICogYXdhaXQgY2xpZW50LnVuc3Vic2NyaWJlKHRoaXMub2JzZXJ2YWJsZSQpXHJcbiAgICAgKiBAcGFyYW0gb2JzZXJ2YWJsZSBBIGxhbWRhIGV4cHJlc3Npb24gdGhhdCByZXR1cm5zIHRoZSB0YXJnZXRlZCBSeEpTIHN1YmplY3Qgb2YgdGhlIHdvcmtlci4gVGhlIHdvcmtlciBhcmd1bWVudCBpbiB0aGUgZXhwcmVzc2lvbiBvbmx5IGhhcyB0aGUgcHJvcGVydGllcyBvd25lZCBieSB0aGUgd29ya2VyIGNsYXNzIChubyBtZXRob2RzKVxyXG4gICAgICogYW5kIG9ubHkgdGhvc2UgcHJvcGVydGllcyB0aGF0IGFyZSBSeEpTIHN1YmplY3RzXHJcbiAgICAgKi9cclxuICAgIG9ic2VydmU8T2JzZXJ2YWJsZVR5cGU+KFxyXG4gICAgICAgIG9ic2VydmFibGU6ICh3b3JrZXJPYnNlcnZhYmxlczogT2JzZXJ2YWJsZXNPbmx5PFQ+KSA9PiBXb3JrZXJPYnNlcnZhYmxlVHlwZTxPYnNlcnZhYmxlVHlwZT4sXHJcbiAgICApOiBQcm9taXNlPE9ic2VydmFibGU8T2JzZXJ2YWJsZVR5cGU+PiB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmNhc3RQcm9taXNlPE9ic2VydmFibGU8T2JzZXJ2YWJsZVR5cGU+Pih0aGlzLnNlbmRSZXF1ZXN0KFdvcmtlckV2ZW50cy5PYnNlcnZhYmxlLCB7XHJcbiAgICAgICAgICAgIHdvcmtlclByb3BlcnR5OiBvYnNlcnZhYmxlLFxyXG4gICAgICAgICAgICBzZWNyZXRFcnJvcjogJ1dvcmtlckNsaWVudDogb25seSBtZXRob2RzIGRlY29yYXRlZCB3aXRoIEBDYWxsYWJsZSgpIGNhbiBiZSB1c2VkIGluIHRoZSBjYWxsIG1ldGhvZCcsXHJcbiAgICAgICAgICAgIGJlZm9yZVJlcXVlc3Q6IChzZWNyZXQpID0+IHRoaXMuY3JlYXRlT2JzZXJ2YWJsZShzZWNyZXQucHJvcGVydHlOYW1lKSxcclxuICAgICAgICAgICAgYm9keTogKHNlY3JldCwga2V5KSA9PiB7IHJldHVybiB7IGlzVW5zdWJzY3JpYmU6IGZhbHNlLCBzdWJzY3JpcHRpb25LZXk6IGtleSB9OyB9LFxyXG4gICAgICAgICAgICByZXNvbHZlOiAocmVzcCwgc2VjcmV0LCBrZXkpID0+IHRoaXMub2JzZXJ2YWJsZXNba2V5XS5vYnNlcnZhYmxlLFxyXG4gICAgICAgICAgICBiZWZvcmVSZWplY3Q6IChyZXNwLCBzZWNyZXQsIGtleSkgPT4gdGhpcy5yZW1vdmVTdWJzY3JpcHRpb24oa2V5KVxyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVuc3Vic2NyaWJlcyBmcm9tIGFuIFJ4SlMgc3Vic2NyaXB0aW9uIG9yIG9ic2VydmFibGUgdGhhdCBoYXMgYmVlbiBjcmVhdGVkIGZyb20gdGhlIGBXb3JrZXJDbGllbnQuc3Vic2NyaWJlKClgIG9yIGBXb3JrZXJDbGllbnQub2JzZXJ2ZSgpYCBtZXRob2RzIHJlc3BlY3RpdmVseS5cclxuICAgICAqICBUaGlzIG1ldGhvZCBpcyBuZWNjZXNzYXJ5IHRvIHJlbGVhc2UgcmVzb3VyY2VzIHdpdGhpbiB0aGUgd29ya2VyLiBDYWxsaW5nIGBXb3JrZXJDbGllbnQuZGVzdG9yeSgpYCB3aWxsIGFsc28gZGlzcG9zZSBvZiBhbGwgb2JzZXJ2YWJsZXMvc3Vic2NyaXB0aW9uc1xyXG4gICAgICogQHBhcmFtIHN1YnNjcmlwdGlvbk9yT2JzZXJ2YWJsZSBUaGUgb2JzZXJ2YWJsZSBvciBzdWJzY3JpcHRpb24gdGhhdCBtdXN0IGJlIGRpc3Bvc2VkIG9mXHJcbiAgICAgKi9cclxuICAgIHVuc3Vic2NyaWJlKFxyXG4gICAgICAgIHN1YnNjcmlwdGlvbk9yT2JzZXJ2YWJsZTogU3Vic2NyaXB0aW9uIHwgT2JzZXJ2YWJsZTxhbnk+XHJcbiAgICApOiBQcm9taXNlPHZvaWQ+IHtcclxuXHJcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5maW5kT2JzZXJ2YWJsZUtleShzdWJzY3JpcHRpb25Pck9ic2VydmFibGUpO1xyXG4gICAgICAgIGlmIChrZXkpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvcGVydHlOYW1lOiBzdHJpbmcgPSB0aGlzLm9ic2VydmFibGVzW2tleV0ucHJvcGVydHlOYW1lO1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVN1YnNjcmlwdGlvbihrZXkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYXN0UHJvbWlzZTx2b2lkPih0aGlzLnNlbmRSZXF1ZXN0KFdvcmtlckV2ZW50cy5PYnNlcnZhYmxlLCB7XHJcbiAgICAgICAgICAgICAgICB3b3JrZXJQcm9wZXJ0eTogcHJvcGVydHlOYW1lLFxyXG4gICAgICAgICAgICAgICAgc2VjcmV0RXJyb3I6ICcnLFxyXG4gICAgICAgICAgICAgICAgYm9keTogKHNlY3JldCkgPT4geyByZXR1cm4geyBpc1Vuc3Vic2NyaWJlOiB0cnVlLCBzdWJzY3JpcHRpb25LZXk6IGtleSB9OyB9LFxyXG4gICAgICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcmVzb2x2ZSgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGdlbmVyaWMgdXRpbGl0eSBmdW5jdGlvbiBmb3Igc2VuZGluZyByZXF1ZXN0cyB0bywgYW5kIGhhbmRsaW5nIHRoZSByZXNwb25zZXMgZnJvbSBhIGBXb3JrZXJDb250cm9sbGVyYCB1c2VkIHdoZW4gdGhlIGBydW5JbkFwcGAgcHJvcGVydHkgaXMgc2V0IHRvIGBmYWxzZWBcclxuICAgICAqIEBwYXJhbSB0eXBlIHRoZSB0eXBlIG9mIHdvcmtlciBldmVudFxyXG4gICAgICogQHBhcmFtIG9wdHMgQ29uZmlndXJhYmxlIG9wdGlvbnMgdGhhdCBkZWZpbmVzIGhvdyB0aGUgcmVxdWVzdCBpcyBzZW50IGFuZCBob3cgdGhlIHJlc3BvbnNlIGlzIGhhbmRsZWRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzZW5kUmVxdWVzdDxFdmVudFR5cGUgZXh0ZW5kcyBudW1iZXIsIFJldHVyblR5cGU+KFxyXG4gICAgICAgIHR5cGU6IEV2ZW50VHlwZSxcclxuICAgICAgICBvcHRzOiBXb3JrZXJDbGllbnRSZXF1ZXN0T3B0czxULCBFdmVudFR5cGUsIFJldHVyblR5cGU+XHJcbiAgICApOiBSZXR1cm5UeXBlIGV4dGVuZHMgUHJvbWlzZTxhbnk+ID8gUmV0dXJuVHlwZSA6IFByb21pc2U8UmV0dXJuVHlwZT4ge1xyXG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0Nvbm5lY3RlZCB8fCBvcHRzLmlzQ29ubmVjdCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBub1Byb3BlcnR5ID0gb3B0cy53b3JrZXJQcm9wZXJ0eSA9PT0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlY3JldFJlc3VsdCA9IG5vUHJvcGVydHkgPyBudWxsIDogdGhpcy5pc1NlY3JldCh0eXBlb2Ygb3B0cy53b3JrZXJQcm9wZXJ0eSA9PT0gJ3N0cmluZycgPyB0aGlzLndvcmtlcltvcHRzLndvcmtlclByb3BlcnR5XSA6IG9wdHMud29ya2VyUHJvcGVydHkodGhpcy53b3JrZXIpLCB0eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VjcmV0UmVzdWx0IHx8IG5vUHJvcGVydHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkaXRpb25hbCBjaGVja3MgLS0tXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLmFkZGl0aW9uYWxDb25kaXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG9wdCBvZiBvcHRzLmFkZGl0aW9uYWxDb25kaXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHQuaWYoc2VjcmV0UmVzdWx0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qob3B0LnJlamVjdChzZWNyZXRSZXN1bHQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkaXRpb25hbCBmdW5jdGlvbmFsaXR5IC0tLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYWRkaXRpb25hbENvbnRleHQ6IGFueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuYmVmb3JlUmVxdWVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbENvbnRleHQgPSBvcHRzLmJlZm9yZVJlcXVlc3Qoc2VjcmV0UmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzcG9uc2UgLS0tLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0U2VjcmV0ID0gdGhpcy5nZW5lcmF0ZVNlY3JldEtleSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXBzb25zZVN1YnNjcmlwdGlvbiA9IHRoaXMucmVzcG9uc2VFdmVudC5zdWJzY3JpYmUoKHJlc3ApID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlzVmFsaWRSZXBvbnNlID0gcmVzcC50eXBlID09PSB0eXBlICYmIHJlc3AucmVxdWVzdFNlY3JldCA9PT0gcmVxdWVzdFNlY3JldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkUmVwb25zZSA9IG5vUHJvcGVydHkgPyBpc1ZhbGlkUmVwb25zZSA6IChpc1ZhbGlkUmVwb25zZSAmJiBzZWNyZXRSZXN1bHQucHJvcGVydHlOYW1lID09PSByZXNwLnByb3BlcnR5TmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkUmVwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3AuaXNFcnJvcikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc29sdmUgLS0tLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVTZWNyZXRLZXkocmVxdWVzdFNlY3JldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5yZXNvbHZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvcHRzLnJlc29sdmUocmVzcCwgc2VjcmV0UmVzdWx0LCBhZGRpdGlvbmFsQ29udGV4dCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBzb25zZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWplY3QgLS0tLS1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlU2VjcmV0S2V5KHJlcXVlc3RTZWNyZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuYmVmb3JlUmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5iZWZvcmVSZWplY3QocmVzcCwgc2VjcmV0UmVzdWx0LCBhZGRpdGlvbmFsQ29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBzb25zZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KEpTT04ucGFyc2UocmVzcC5lcnJvcikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VuZCByZXF1ZXN0IC0tLS0tXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcTogV29ya2VyUmVxdWVzdEV2ZW50PEV2ZW50VHlwZT4gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0U2VjcmV0OiByZXF1ZXN0U2VjcmV0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lOiBub1Byb3BlcnR5ID8gbnVsbCA6IHNlY3JldFJlc3VsdC5wcm9wZXJ0eU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogb3B0cy5ib2R5ID8gb3B0cy5ib2R5KHNlY3JldFJlc3VsdCwgYWRkaXRpb25hbENvbnRleHQpIDogbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc3RNZXNzYWdlKHJlcSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihvcHRzLnNlY3JldEVycm9yKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1dvcmtlckNsaWVudDogdGhlIFdvcmtlckNsaWVudC5jb25uZWN0KCkgbWV0aG9kIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBhIHdvcmtlciBjYW4gYmUgYWNjZXNzZWQnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gPGFueT5wcm9taXNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSB3cmFwcGVyIGZ1bmN0aW9uIGFyb3VuZCB0aGUgYFdvcmtlci5wb3N0TWVzc2FnZSgpYCBtZXRob2QgdG8gY2F0Y2ggYW55IHNlcmlhbGl6YXRpb24gZXJyb3JzIHNob3VsZCB0aGV5IG9jY3VyXHJcbiAgICAgKiBAcGFyYW0gcmVxdWVzdCB0aGUgcmVxdWVzdCB0byBiZSBzZW50IHRvIHRoZSB3b3JrZXJcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBwb3N0TWVzc2FnZTxFdmVudFR5cGUgZXh0ZW5kcyBudW1iZXI+KFxyXG4gICAgICAgIHJlcXVlc3Q6IFdvcmtlclJlcXVlc3RFdmVudDxFdmVudFR5cGU+XHJcbiAgICApIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB0aGlzLndvcmtlclJlZi5wb3N0TWVzc2FnZShyZXF1ZXN0KTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHNlcmlhbGl6ZSB0aGUgcmVxdWVzdCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHdvcmtlcicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHV0aWxpdHkgZnVuY3Rpb24gdG8gY2FzdCBwcm9taXNlc1xyXG4gICAgICogQHBhcmFtIHByb21pc2UgcHJvbWlzZSB0byBjYXN0XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2FzdFByb21pc2U8UHJvbWlzZVR5cGU+KFxyXG4gICAgICAgIHByb21pc2U6IFByb21pc2U8YW55PlxyXG4gICAgKTogUHJvbWlzZTxQcm9taXNlVHlwZT4ge1xyXG4gICAgICAgIHJldHVybiA8UHJvbWlzZTxQcm9taXNlVHlwZT4+cHJvbWlzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgY2xpZW50IHN1YnNjcmlwdGlvbiByZWZlcmVuY2Ugd2l0aCBhIHN1YnNjcmlwdGlvbiBhbmQgYW4gUnhKUyBzdWJqZWN0LCBhZGRzIGl0IHRvIHRoZSBgb2JzZXJ2YWJsZXNgIGRpY3Rpb25hcnkgd2l0aCB1bmlxdWUga2V5IGFuZCB0aGVuIHJldHVybnMgdGhlIGtleS4gQ2FsbGVkIGZyb20gdGhlIGBzdWJzY3JpYmUoKWAgbWV0aG9kLlxyXG4gICAgICogQHBhcmFtIHByb3BlcnR5TmFtZSB0aGUgcHJvcGVydHkgbmFtZSBvZiB0aGUgd29ya2VyJ3MgUnhKUyBzdWJqZWN0IHRoYXQgd2FzIHN1YnNjcmliZWQgdG9cclxuICAgICAqIEBwYXJhbSBuZXh0IENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIHN1YmplY3QncyBgbmV4dCgpYCBtZXRob2QgaXMgY2FsbGVkXHJcbiAgICAgKiBAcGFyYW0gZXJyb3IgQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgc3ViamVjdCB0aHJvd3MgYW5kIGVycm9yXHJcbiAgICAgKiBAcGFyYW0gY29tcGxldGUgQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgc3ViamVjdCdzIGBjb21wbGV0ZSgpYCBtZXRob2QgaXMgY2FsbGVkXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY3JlYXRlU3Vic2NyaXB0aW9uKFxyXG4gICAgICAgIHByb3BlcnR5TmFtZTogc3RyaW5nLFxyXG4gICAgICAgIG5leHQ/OiAodmFsdWU6IGFueSkgPT4gdm9pZCxcclxuICAgICAgICBlcnJvcj86IChlcnJvcjogYW55KSA9PiB2b2lkLFxyXG4gICAgICAgIGNvbXBsZXRlPzogKCkgPT4gdm9pZFxyXG4gICAgKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmdlbmVyYXRlU3Vic2NyaXB0aW9uS2V5KHByb3BlcnR5TmFtZSk7XHJcbiAgICAgICAgY29uc3Qgc3ViamVjdCA9IG5ldyBTdWJqZWN0PGFueT4oKTtcclxuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzdWJqZWN0LnN1YnNjcmliZShuZXh0LCBlcnJvciwgY29tcGxldGUpO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZXNba2V5XSA9IHsgc3ViamVjdDogc3ViamVjdCwgc3Vic2NyaXB0aW9uOiBzdWJzY3JpcHRpb24sIHByb3BlcnR5TmFtZTogcHJvcGVydHlOYW1lLCBvYnNlcnZhYmxlOiBudWxsIH07XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgY2xpZW50IG9ic2VydmFibGUgcmVmZXJlbmNlIHdpdGggYSBSeEpTIG9ic2VydmFibGUgYW5kIHN1YmplY3QsIGFkZHMgaXQgdG8gdGhlIGBvYnNlcnZhYmxlc2AgZGljdGlvbmFyeSB3aXRoIHVuaXF1ZSBrZXkgYW5kIHRoZW4gcmV0dXJucyB0aGUga2V5LiBDYWxsZWQgZnJvbSB0aGUgYG9ic2VydmUoKWAgbWV0aG9kLlxyXG4gICAgICogQHBhcmFtIHByb3BlcnR5TmFtZSB0aGUgcHJvcGVydHkgbmFtZSBvZiB0aGUgd29ya2VyJ3MgUnhKUyBzdWJqZWN0IHRoYXQgd2FzIHN1YnNjcmliZWQgdG9cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjcmVhdGVPYnNlcnZhYmxlKFxyXG4gICAgICAgIHByb3BlcnR5TmFtZTogc3RyaW5nLFxyXG4gICAgKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmdlbmVyYXRlU3Vic2NyaXB0aW9uS2V5KHByb3BlcnR5TmFtZSk7XHJcbiAgICAgICAgY29uc3Qgc3ViamVjdCA9IG5ldyBTdWJqZWN0PGFueT4oKTtcclxuICAgICAgICB0aGlzLm9ic2VydmFibGVzW2tleV0gPSB7IHN1YmplY3Q6IHN1YmplY3QsIHN1YnNjcmlwdGlvbjogbnVsbCwgcHJvcGVydHlOYW1lOiBwcm9wZXJ0eU5hbWUsIG9ic2VydmFibGU6IHN1YmplY3QuYXNPYnNlcnZhYmxlKCkgfTtcclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXRlcmF0ZXMgdGhyb3VnaCB0aGUgYG9ic2VydmFibGVzYCBkaWN0aW9uYXJ5IHRvIGZpbmQgdGhlIGFzc29jaWF0ZWQga2V5IGZvciBhIHBhcnRpY3VsYXIgc3Vic2NyaXB0aW9uIG9yIG9ic2VydmFibGUuIFJldHVybnMgbnVsbCBpZiBubyBtYXRjaCBpcyBmb3VuZFxyXG4gICAgICogQHBhcmFtIHZhbHVlIFN1YnNjcmlwdGlvbiBvciBvYnNlcnZhYmxlIGZvciB3aGljaCB0aGUgZGljdGlvbmFyeSBrZXkgbXVzdCBiZSBmb3VuZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGZpbmRPYnNlcnZhYmxlS2V5KFxyXG4gICAgICAgIHZhbHVlOiBTdWJzY3JpcHRpb24gfCBPYnNlcnZhYmxlPGFueT5cclxuICAgICk6IHN0cmluZyB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5vYnNlcnZhYmxlcykge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTdWJzY3JpcHRpb24pIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9ic2VydmFibGVzW2tleV0uc3Vic2NyaXB0aW9uID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vYnNlcnZhYmxlc1trZXldLm9ic2VydmFibGUgPT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhIHN1YnNjcmlwdGlvbiBvciBvYnNlcnZhYmxlIHJlZmVyZW5jZSBmcm9tIGBvYnNlcnZhYmxlc2AgZGljdGlvbmFyeS4gUmVtb3ZlZCBzdWJzY3JpcHRpb25zIGFyZSB1bnN1YnNyaWJlZCBiZWZvcmUgZGVzdHJveWVkXHJcbiAgICAgKiBAcGFyYW0gc3Vic2NyaXB0aW9uS2V5IHVuaXF1ZSBrZXkgaW4gdGhlIGBvYnNlcnZhYmxlc2AgZGljdGlvbmFyeVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlbW92ZVN1YnNjcmlwdGlvbihcclxuICAgICAgICBzdWJzY3JpcHRpb25LZXk6IHN0cmluZ1xyXG4gICAgKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2YWJsZXNbc3Vic2NyaXB0aW9uS2V5XSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vYnNlcnZhYmxlc1tzdWJzY3JpcHRpb25LZXldLnN1YnNjcmlwdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZhYmxlc1tzdWJzY3JpcHRpb25LZXldLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLm9ic2VydmFibGVzW3N1YnNjcmlwdGlvbktleV07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYSByYW5kb20ga2V5XHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydHlOYW1lIGFwcGVuZGVkIGFzIHRoZSBwcmVmaXggdG8gdGhlIGtleVxyXG4gICAgICogQHBhcmFtIGxlbmd0aCBsZW5ndGggb2YgdGhlIHJhbmRvbWx5IGdlbmVyYXRlZCBjaGFyYWN0ZXJzXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2VuZXJhdGVLZXkoXHJcbiAgICAgICAgcHJvcGVydHlOYW1lOiBzdHJpbmcsXHJcbiAgICAgICAgbGVuZ3RoOiBudW1iZXJcclxuICAgICkge1xyXG4gICAgICAgIHJldHVybiBgJHtwcm9wZXJ0eU5hbWUudG9VcHBlckNhc2UoKX1fJHtBcnJheShsZW5ndGgpLmZpbGwobnVsbCkubWFwKCgpID0+IChNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxNikpLnRvU3RyaW5nKDE2KSkuam9pbignJyl9YDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSB1bmlxdWUga2V5IGZvciBhIHN1YnNjcmlwdGlvbi9vYnNlcnZhYmxlIHJlZmVyZW5jZSBmb3IgdXNlIGluIHRoZSBgb2JzZXJ2YWJsZXNgIGRpY3Rpb25hcnkuIFRoaXMga2V5IGFsbG93cyBtZXNzYWdlcyBmcm9tIHRoZSB3b3JrZXIgdG8gYmUgY29ycmVjdGx5IG1hcHBlZCBhbmQgaGFuZGxlZCBpbiB0aGUgY2xpZW50XHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydHlOYW1lIHByb3BlcnR5IG5hbWUgb2YgdGhlIHdvcmtlcidzIFJ4SlMgc3ViamVjdCB3aGljaCBpcyBzdWJzY3JpYmVkIHRvLiBUaGlzIGlzIGF0dGFjaGVkIGFzIGEgcHJlZml4IHRvIHRoZSB1bmlxdWUga2V5XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2VuZXJhdGVTdWJzY3JpcHRpb25LZXkoXHJcbiAgICAgICAgcHJvcGVydHlOYW1lOiBzdHJpbmdcclxuICAgICk6IHN0cmluZyB7XHJcbiAgICAgICAgbGV0IGtleSA9IHRoaXMuZ2VuZXJhdGVLZXkocHJvcGVydHlOYW1lLCA2KTtcclxuICAgICAgICB3aGlsZSAodGhpcy5vYnNlcnZhYmxlc1trZXldKSB7XHJcbiAgICAgICAgICAgIGtleSA9IHRoaXMuZ2VuZXJhdGVLZXkocHJvcGVydHlOYW1lLCA2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSB1bmlxdWUga2V5IGZvciB3b3JrZXIgcmVxdWVzdHMgZW5zdXJpbmcgbm8gdHdvIGtleXMgYXJlIGF2YWxpYWJsZSBhdCBhbnkgdGltZSB0aHJvdWdoIHRoZSBgc2VjcmV0c2AgYXJyYXkuIEFsbG93cyByZXF1ZXN0cyB0byBiZSBtYXBwZWQgdG8gcmVzcG9uc2VzIGZyb21cclxuICAgICAqIHRoZSB3b3JrZXJcclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eU5hbWUgcHJvcGVydHkgbmFtZSBvZiB0aGUgd29ya2VyJ3MgcHJvcGVydHkvbWV0aG9kIHRoYXQgaXMgYmVpbmcgY2FsbGVkLiBUaGlzIGlzIGF0dGFjaGVkIGFzIGEgcHJlZml4IHRvIHRoZSB1bmlxdWUga2V5XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2VuZXJhdGVTZWNyZXRLZXkoXHJcbiAgICAgICAgcHJvcGVydHlOYW1lPzogc3RyaW5nXHJcbiAgICApOiBzdHJpbmcge1xyXG4gICAgICAgIHByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZSA/IHByb3BlcnR5TmFtZSA6ICdjbGllbnQnO1xyXG4gICAgICAgIGxldCBrZXkgPSB0aGlzLmdlbmVyYXRlS2V5KHByb3BlcnR5TmFtZSwgMTYpO1xyXG4gICAgICAgIHdoaWxlICh0aGlzLnNlY3JldHMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xyXG4gICAgICAgICAgICBrZXkgPSB0aGlzLmdlbmVyYXRlS2V5KHByb3BlcnR5TmFtZSwgMTYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlY3JldHMucHVzaChrZXkpO1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEga2V5IGZyb20gdGhlIGBzZWNyZXRzYCBhcnJheSBpZiBpdCBleGlzdHNcclxuICAgICAqIEBwYXJhbSBzZWNyZXQgdW5xaXVlIGtleSB0byBiZSByZW1vdmVkXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVtb3ZlU2VjcmV0S2V5KFxyXG4gICAgICAgIHNlY3JldDogc3RyaW5nXHJcbiAgICApIHtcclxuICAgICAgICBpZiAodGhpcy5zZWNyZXRzLmluZGV4T2Yoc2VjcmV0KSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWNyZXRzLnNwbGljZSh0aGlzLnNlY3JldHMuaW5kZXhPZihzZWNyZXQpLCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYSB2YWxpZCBgU2VjcmV0UmVzdWx0YCBpcyByZXR1cm5lZCB3aGVuIGEgZGVjb3JhdGVkIHByb3BlcnR5IGFuZC9vciBtZXRob2Qgb2YgdGhlIGNsaWVudCBpbnN0YW5jZSBvZiB0aGUgd29ya2VyIGNsYXNzIGlzIGNhbGxlZC5cclxuICAgICAqICBSZXR1cm5zIHRoZSBzZWNyZXQgd2hlbiB2YWxpZCBvdGhlcndpc2UgcmV0dXJucyBudWxsXHJcbiAgICAgKiBAcGFyYW0gc2VjcmV0UmVzdWx0IHRoZSByZXR1cm5lZCB2YWx1ZSBmcm9tIGNhbGxpbmcgdGhlIHByb3BlcnR5IG9yIG1ldGhvZCBvZiBhIGNsaWVudCBpbnN0YW5jZSBvZiBhIHdvcmtlclxyXG4gICAgICogQHBhcmFtIHR5cGUgdGhlIHdvcmtlciBldmVudCB0eXBlIHRoYXQgb3JpZ2luYXRlZCB0aGUgcmVxdWVzdFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGlzU2VjcmV0PFNlY3JldFR5cGUgZXh0ZW5kcyBudW1iZXI+KFxyXG4gICAgICAgIHNlY3JldFJlc3VsdDogYW55LFxyXG4gICAgICAgIHR5cGU6IFNlY3JldFR5cGVcclxuICAgICk6IFNlY3JldFJlc3VsdDxTZWNyZXRUeXBlPiB7XHJcbiAgICAgICAgaWYgKHNlY3JldFJlc3VsdCkge1xyXG4gICAgICAgICAgICBpZiAoc2VjcmV0UmVzdWx0WydjbGllbnRTZWNyZXQnXSAmJiBzZWNyZXRSZXN1bHRbJ3Byb3BlcnR5TmFtZSddICYmIHNlY3JldFJlc3VsdFsndHlwZSddKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VjcmV0UmVzdWx0WydjbGllbnRTZWNyZXQnXSA9PT0gdGhpcy53b3JrZXJTZWNyZXQgJiYgc2VjcmV0UmVzdWx0Wyd0eXBlJ10gPT09IHR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gPFNlY3JldFJlc3VsdDxTZWNyZXRUeXBlPj5zZWNyZXRSZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSBldmVudCBsaXN0ZW5lcnMgdG8gbGlzdGVuIGZvciwgYW5kIGhhbmRsZSwgbWVzc2FnZXMgcmVjaWV2ZWQgdGhyb3VnaCBgV29ya2VyLm9ubWVzc2FnZWBcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZWdpc3RlckV2ZW50cygpIHtcclxuXHJcbiAgICAgICAgdGhpcy5yZXNwb25zZUV2ZW50ID0gbmV3IFN1YmplY3Q8V29ya2VyUmVzcG9uc2VFdmVudDxXb3JrZXJFdmVudHMuQ2FsbGFibGU+PigpO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZXMgPSB7fTtcclxuXHJcbiAgICAgICAgdGhpcy53b3JrZXJSZWYub25tZXNzYWdlID0gKGV2OiBXb3JrZXJFdmVudDxXb3JrZXJSZXNwb25zZUV2ZW50PGFueT4+KSA9PiB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZXYuZGF0YS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFdvcmtlckV2ZW50cy5PYnNlcnZhYmxlTWVzc2FnZTpcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBib2R5OiBXb3JrZXJPYnNlcnZhYmxlTWVzc2FnZSA9IGV2LmRhdGEucmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9ic2VydmFibGVzW2JvZHkua2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGJvZHkudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBXb3JrZXJPYnNlcnZhYmxlTWVzc2FnZVR5cGVzLk5leHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZhYmxlc1tib2R5LmtleV0uc3ViamVjdC5uZXh0KGJvZHkudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBXb3JrZXJPYnNlcnZhYmxlTWVzc2FnZVR5cGVzLkVycm9yOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2YWJsZXNbYm9keS5rZXldLnN1YmplY3QuZXJyb3IoYm9keS5lcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFdvcmtlck9ic2VydmFibGVNZXNzYWdlVHlwZXMuQ29tcGxldGU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZhYmxlc1tib2R5LmtleV0uc3ViamVjdC5jb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlRXZlbnQubmV4dChldi5kYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgIH1cclxuXHJcblxyXG59XHJcbiJdfQ==