import { WorkerAnnotations, WorkerUtils, WorkerEvents, WorkerObservableMessageTypes } from 'angular-web-worker/common';
import { __awaiter, __generator, __spread } from 'tslib';
import 'reflect-metadata';

var ɵ0 = function (instance, config) {
    Object.defineProperty(instance, WorkerAnnotations.Config, {
        get: function () {
            return config;
        },
        enumerable: true,
        configurable: true
    });
}, ɵ1 = function (instance) {
    var accessables = WorkerUtils.getAnnotation(instance.__proto__.constructor, WorkerAnnotations.Accessables, []);
    if (accessables) {
        accessables.forEach(function (item) {
            var _val = instance[item.name];
            var getter = function () {
                var config = this.__worker_config__;
                if (config) {
                    if (config.isClient) {
                        var secret = {
                            clientSecret: config.clientSecret,
                            type: WorkerEvents.Accessable,
                            propertyName: item.name,
                            body: {
                                get: item.get,
                                set: item.set
                            }
                        };
                        return secret;
                    }
                    else {
                        return _val;
                    }
                }
                else {
                    return _val;
                }
            };
            var setter = function (newVal) {
                _val = newVal;
            };
            delete instance[item.name];
            Object.defineProperty(instance, item.name, {
                get: getter,
                set: setter,
                enumerable: true,
                configurable: true
            });
        });
    }
}, ɵ2 = function (instance) {
    var observables = WorkerUtils.getAnnotation(instance.__proto__.constructor, WorkerAnnotations.Observables, []);
    if (observables) {
        observables.forEach(function (item) {
            var _val = instance[item.name];
            var getter = function () {
                var config = this.__worker_config__;
                if (config) {
                    if (config.isClient) {
                        var secret = {
                            clientSecret: config.clientSecret,
                            type: WorkerEvents.Observable,
                            propertyName: item.name,
                            body: null
                        };
                        return secret;
                    }
                    else {
                        return _val;
                    }
                }
                else {
                    return _val;
                }
            };
            var setter = function (newVal) {
                _val = newVal;
            };
            delete instance[item.name];
            Object.defineProperty(instance, item.name, {
                get: getter,
                set: setter,
                enumerable: true,
                configurable: true
            });
        });
    }
};
var WorkerFactoryFunctions = {
    /*
     * Attaches a worker configuration to an instance of a worker class
     * @param instance instance of the worker class
     * @param config configuration
     */
    setWorkerConfig: ɵ0,
    configureAccessables: ɵ1,
    configureSubscribables: ɵ2
};
/**
 * Class decorator allowing the class to be bootstrapped into a web worker script, and allowing communication with a `WorkerClient`
 */
function AngularWebWorker() {
    return function (target) {
        WorkerUtils.setAnnotation(target, WorkerAnnotations.IsWorker, true);
        WorkerUtils.setAnnotation(target, WorkerAnnotations.Factory, function create(config) {
            var instance = new target();
            WorkerFactoryFunctions.setWorkerConfig(instance, config);
            WorkerFactoryFunctions.configureAccessables(instance);
            WorkerFactoryFunctions.configureSubscribables(instance);
            return instance;
        });
    };
}

/**
 * Handles communication to and from a `WorkerClient` and triggers work with the worker class.
 */
var WorkerController = /** @class */ (function () {
    /**
     * Creates a new `WorkerController`
     * @param workerClass the worker class,
     * @param postMessageFn the worker postMessage function passed into constuctor allowing this to be mocked when running within the app (not the worker script)
     * @param onMessageFn the worker onmessage event function passed into constructor allowing this to be mocked when running within the app (not the worker script)
     */
    function WorkerController(workerClass, messageBus) {
        this.workerClass = workerClass;
        this.messageBus = messageBus;
        try {
            this.worker = WorkerUtils.getAnnotation(workerClass, WorkerAnnotations.Factory)({
                isClient: false
            });
            this.subscriptions = {};
            this.registerEvents();
        }
        catch (e) { }
    }
    Object.defineProperty(WorkerController.prototype, "workerInstance", {
        /**
         * Returns instance of worker class
         */
        get: function () {
            return this.worker;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates the event listeners to correctly handle and respond to messages recieved from a `WorkerClient`
     */
    WorkerController.prototype.registerEvents = function () {
        var _this = this;
        this.messageBus.onmessage = function (ev) {
            switch (ev.data.type) {
                case WorkerEvents.Callable:
                    _this.handleCallable(ev.data);
                    break;
                case WorkerEvents.Accessable:
                    _this.handleAccessable(ev.data);
                    break;
                case WorkerEvents.Observable:
                    _this.handleSubscription(ev.data);
                    break;
                case WorkerEvents.Init:
                    _this.handleInit(ev.data);
                    break;
            }
        };
    };
    /**
     * A utility function to create a new `WorkerResponseEvent` from the details provided by the `WorkerRequestEvent`, as well as the result to be returned
     * @param type The type of worker event
     * @param request The request that the response relates to
     * @param result data to return with the response
     */
    WorkerController.prototype.response = function (type, request, result) {
        return {
            type: type,
            isError: false,
            requestSecret: request.requestSecret,
            propertyName: request.propertyName,
            result: result
        };
    };
    /**
     * A utility function to create a new error in the form of a `WorkerResponseEvent` from the details provided by the `WorkerRequestEvent`, as well as the error to be returned
     * @param type The type of worker event
     * @param request The request that the error relates to
     * @param result the error to be returned
     */
    WorkerController.prototype.error = function (type, request, error) {
        return {
            type: type,
            isError: true,
            requestSecret: request.requestSecret,
            propertyName: request.propertyName,
            error: JSON.stringify(error, this.replaceErrors),
            result: null
        };
    };
    /**
     * A utility function as the replacer for the `JSON.stringify()` function to make the native browser `Error` class serializable to JSON
     */
    WorkerController.prototype.replaceErrors = function (key, value) {
        if (value instanceof Error) {
            var error_1 = {};
            // tslint:disable-next-line: no-shadowed-variable
            Object.getOwnPropertyNames(value).forEach(function (key) {
                error_1[key] = value[key];
            });
            return error_1;
        }
        return value;
    };
    /**
     * Handles `WorkerEvents.Init` requests from a client by calling the `onWorkerInit` hook if implemented and only responding once the hook has been completed, regardless of whether it is
     * async or not
     * @param request request recieved from the `WorkerClient`
     */
    WorkerController.prototype.handleInit = function (request) {
        return __awaiter(this, void 0, void 0, function () {
            var result, isPromise;
            var _this = this;
            return __generator(this, function (_a) {
                if (this.worker['onWorkerInit']) {
                    try {
                        result = this.worker['onWorkerInit']();
                        isPromise = false;
                        if (result) {
                            isPromise = result.__proto__.constructor === Promise;
                        }
                        if (isPromise) {
                            result.then(function () {
                                _this.postMessage(_this.response(WorkerEvents.Init, request, null));
                            }).catch(function (err) {
                                _this.postMessage(_this.error(WorkerEvents.Init, request, err));
                            });
                        }
                        else {
                            this.postMessage(this.response(WorkerEvents.Init, request, null));
                        }
                    }
                    catch (e) {
                        this.postMessage(this.error(WorkerEvents.Init, request, null));
                    }
                }
                else {
                    this.postMessage(this.response(WorkerEvents.Init, request, null));
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Handles `WorkerEvents.Callable` requests from a client by calling the targeted method and responding with the method's return value
     * @param request request recieved from the `WorkerClient`
     */
    WorkerController.prototype.handleCallable = function (request) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, response, result, e_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, 3, 4]);
                        request.body.arguments = this.applyShallowTransferToCallableArgs(request, request.body.arguments);
                        return [4 /*yield*/, (_a = this.worker)[request.propertyName].apply(_a, __spread(request.body.arguments))];
                    case 1:
                        result = _b.sent();
                        response = this.response(WorkerEvents.Callable, request, result);
                        return [3 /*break*/, 4];
                    case 2:
                        e_1 = _b.sent();
                        response = this.error(WorkerEvents.Callable, request, e_1);
                        return [3 /*break*/, 4];
                    case 3:
                        this.postMessage(response);
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Transfers the prototype of any function arguments decorated with `@ShallowTransfer()` which have been serialized and recieved from a `WorkerEvents.Callable` request.
     *  This occurs before the arguments are used to call the worker function.
     * @param request request recieved from the `WorkerClient`
     * @param args array of function arguments
     */
    WorkerController.prototype.applyShallowTransferToCallableArgs = function (request, args) {
        var metaData = WorkerUtils.getAnnotation(this.workerClass, WorkerAnnotations.ShallowTransferArgs, []);
        if (metaData) {
            var shallowTransferMeta = metaData.filter(function (x) { return x.name === request.propertyName; });
            var _loop_1 = function (i) {
                var meta = shallowTransferMeta.filter(function (x) { return x.argIndex === i; })[0];
                if (meta) {
                    if (meta.type && args[i]) {
                        args[i].__proto__ = meta.type.prototype;
                    }
                }
            };
            for (var i = 0; i < args.length; i++) {
                _loop_1(i);
            }
        }
        return args;
    };
    /**
     * Handles `WorkerEvents.Accessable` requests from a client by either setting the target property of the worker or responding with the target property's value
     * @param request request recieved from the `WorkerClient`
     */
    WorkerController.prototype.handleAccessable = function (request) {
        var response;
        try {
            var metaData = WorkerUtils.getAnnotation(this.workerClass, 'accessables', []).filter(function (x) { return x.name === request.propertyName; })[0];
            if (request.body.isGet) {
                response = this.response(WorkerEvents.Accessable, request, this.worker[request.propertyName]);
            }
            else {
                this.worker[request.propertyName] = request.body.value;
                if (metaData.shallowTransfer) {
                    if (metaData.type && this.worker[request.propertyName]) {
                        this.worker[request.propertyName].__proto__ = metaData.type.prototype;
                    }
                }
                response = this.response(WorkerEvents.Accessable, request, null);
            }
        }
        catch (e) {
            response = this.error(WorkerEvents.Accessable, request, e);
        }
        finally {
            this.postMessage(response);
        }
    };
    /**
     * Handles `WorkerEvents.Subscribable` requests from a client by creating a new subscription to the targeted observable which will send messages to the client each time
     * an event is triggered by the observable. The function may also unsubscribe from a subscription depending on the details of the request
     * @param request request recieved from the `WorkerClient`
     */
    WorkerController.prototype.handleSubscription = function (request) {
        var response;
        if (!request.body.isUnsubscribe) {
            try {
                this.createSubscription(request);
                response = this.response(WorkerEvents.Observable, request, request.body.subscriptionKey);
            }
            catch (e) {
                this.removeSubscription(request.body.subscriptionKey);
                response = this.error(WorkerEvents.Observable, request, e);
            }
            finally {
                this.postMessage(response);
            }
        }
        else {
            try {
                this.removeSubscription(request.body.subscriptionKey);
                response = this.response(WorkerEvents.Observable, request, null);
            }
            catch (e) {
                response = this.error(WorkerEvents.Observable, request, e);
            }
            finally {
                this.postMessage(response);
            }
        }
    };
    /**
     * Creates a new subscription to a worker observable and adds it to the `subscriptions` dictionary. The subscriptions will send messages to the client each time
     *  and event is triggered by the observable
     * @param request request recieved from the `WorkerClient`
     */
    WorkerController.prototype.createSubscription = function (request) {
        var _this = this;
        this.removeSubscription(request.body.subscriptionKey);
        this.subscriptions[request.body.subscriptionKey] = this.worker[request.propertyName].subscribe(function (val) {
            var response = {
                type: WorkerEvents.ObservableMessage,
                propertyName: request.propertyName,
                isError: false,
                requestSecret: null,
                result: {
                    key: request.body.subscriptionKey,
                    type: WorkerObservableMessageTypes.Next,
                    value: val
                }
            };
            _this.postSubscriptionMessage(response);
        }, function (err) {
            var response = {
                type: WorkerEvents.ObservableMessage,
                propertyName: request.propertyName,
                isError: true,
                requestSecret: null,
                result: {
                    key: request.body.subscriptionKey,
                    type: WorkerObservableMessageTypes.Error,
                    error: JSON.parse(JSON.stringify(err, _this.replaceErrors))
                }
            };
            _this.postSubscriptionMessage(response);
        }, function () {
            var response = {
                type: WorkerEvents.ObservableMessage,
                propertyName: request.propertyName,
                isError: false,
                requestSecret: null,
                result: {
                    key: request.body.subscriptionKey,
                    type: WorkerObservableMessageTypes.Complete,
                }
            };
            _this.postSubscriptionMessage(response);
        });
    };
    /**
     * Removes a subscription from the `subscriptions` dictionary, unsubscribing before it is deleted
     * @param subscriptionKey key in dictionary
     */
    WorkerController.prototype.removeSubscription = function (subscriptionKey) {
        if (this.subscriptions[subscriptionKey]) {
            this.subscriptions[subscriptionKey].unsubscribe();
        }
        delete this.subscriptions[subscriptionKey];
    };
    /**
     * Unsubscribes from all subscriptions
     */
    WorkerController.prototype.removeAllSubscriptions = function () {
        for (var key in this.subscriptions) {
            if (this.subscriptions[key]) {
                this.subscriptions[key].unsubscribe();
                delete this.subscriptions[key];
            }
        }
    };
    /**
     * A wrapper function around the `postMessage()` method allowing serialization errors to be caught and sent to the client as a `WorkerResponseEvent`.
     * Only used when the response is triggered by a request, which is not the case when the event type is `WorkerEvents.ObservableMessage`.
     * @param response reponse to send to the client
     */
    WorkerController.prototype.postMessage = function (response) {
        try {
            this.messageBus.postMessage(response);
        }
        catch (e) {
            var errorResponse = {
                type: response.type,
                isError: true,
                requestSecret: response.requestSecret,
                propertyName: response.propertyName,
                error: JSON.parse(JSON.stringify(new Error('Unable to serialize response from worker to client'), this.replaceErrors)),
                result: null
            };
            this.messageBus.postMessage(errorResponse);
        }
    };
    /**
     * A wrapper function around the `postMessage()` method allowing serialization errors to be caught and sent to the client as a `WorkerResponseEvent`.
     * Only used when the response type is `WorkerEvents.ObservableMessage` which requires a different implementation to the `WorkerController.postMessage` wrapper as it
     * is one-way communication which is not triggered by a request
     */
    WorkerController.prototype.postSubscriptionMessage = function (response) {
        try {
            this.messageBus.postMessage(response);
        }
        catch (e) {
            var errorResponse = {
                type: response.type,
                isError: true,
                requestSecret: response.requestSecret,
                propertyName: response.propertyName,
                result: {
                    key: response.result.key,
                    type: WorkerObservableMessageTypes.Error,
                    error: JSON.parse(JSON.stringify(new Error('Unable to serialize subscribable response from worker to client'), this.replaceErrors))
                },
            };
            this.messageBus.postMessage(errorResponse);
        }
    };
    return WorkerController;
}());

/**
 * Bootstraps the worker class when a new worker script is created in the browser. The class must be decorated with `@AngularWebWorker()`
 * @param worker worker class to bootstrap
 */
function bootstrapWorker(worker) {
    var messageBus = {
        onmessage: function (ev) {
        },
        postMessage: function (msg) {
            postMessage(msg);
        }
    };
    var workerController = new WorkerController(worker, messageBus);
    onmessage = function (ev) {
        messageBus.onmessage(ev);
    };
}

/**
 * Allows the decorated worker method to be called, and its value returned, from the `WorkerClient.call()` method.
 * Can be used on both asynchronous and synchronous methods.
 * @Serialized Functions will not be copied and circular referencing structures will cause errors. This applies to both the function arguments and the value returned by the function
 * @param options Configurable options defining how the decorated method is called from a `WorkerClient`
 */
function Callable(options) {
    return function (target, propertyKey, descriptor) {
        var opts = { shallowTransfer: false };
        if (options) {
            opts.shallowTransfer = options.shallowTransfer ? true : false;
        }
        WorkerUtils.pushAnnotation(target.constructor, WorkerAnnotations.Callables, {
            name: propertyKey,
            shallowTransfer: opts.shallowTransfer,
            returnType: Reflect.getMetadata('design:returntype', target, propertyKey)
        });
        var originalMethod = descriptor.value;
        descriptor.value = function () {
            var context = this;
            var args = Array.prototype.slice.call(arguments);
            var config = context.__worker_config__;
            if (config) {
                if (config.isClient) {
                    var secret = {
                        clientSecret: context.__worker_config__.clientSecret,
                        type: WorkerEvents.Callable,
                        propertyName: propertyKey,
                        body: {
                            args: args
                        }
                    };
                    return secret;
                }
                else {
                    return originalMethod.call.apply(originalMethod, __spread([context], args));
                }
            }
            else {
                return originalMethod.call.apply(originalMethod, __spread([context], args));
            }
        };
        return descriptor;
    };
}

/**
 * Allows the decorated worker property to be accessed from the `WorkerClient.get()` and `WorkerClient.set()` methods
 * @Serialized Functions will not be copied and circular referencing structures will cause errors
 * @param options configurable options defining how the decorated property can be interacted with from a `WorkerClient`
 */
function Accessable(options) {
    var opts = { get: true, set: true, shallowTransfer: false };
    if (options) {
        opts.get = options.get === false ? false : true;
        opts.set = options.set === false ? false : true;
        opts.shallowTransfer = options.shallowTransfer ? true : false;
    }
    return function (target, propertyKey) {
        WorkerUtils.pushAnnotation(target.constructor, WorkerAnnotations.Accessables, {
            name: propertyKey,
            type: Reflect.getMetadata('design:type', target, propertyKey),
            get: opts.get,
            set: opts.set,
            shallowTransfer: opts.shallowTransfer
        });
    };
}

/**
 * Allows the decorated worker property to be subscribed to, or observed through the `WorkerClient.subscribe()` and `WorkerClient.observe()` methods.
 *
 * Can only be used on multicasted RxJS observables being a `Subject`,  `BehaviorSubject`, `ReplaySubject` or `AsyncSubject`.
 * @Serialized When data is transferred through `Subject.next()`, functions will not be copied and circular referencing structures will cause errors
 */
function Subscribable() {
    return function (target, propertyKey) {
        WorkerUtils.pushAnnotation(target.constructor, WorkerAnnotations.Observables, {
            name: propertyKey,
            type: Reflect.getMetadata('design:type', target, propertyKey)
        });
    };
}

/**
 * Transfers the decorated argument's prototype when it is serialized and unserialized when the method is called from `WorkerClient.call()`. This will only have an effect if
 * the method is decorated with `@Callable()`
 * @Experimental has limitations
 */
function ShallowTransfer() {
    return function (target, propertyKey, parameterIndex) {
        var argTypes = Reflect.getMetadata('design:paramtypes', target, propertyKey);
        WorkerUtils.pushAnnotation(target.constructor, WorkerAnnotations.ShallowTransferArgs, {
            name: propertyKey,
            type: argTypes[parameterIndex],
            argIndex: parameterIndex
        });
    };
}

export { Accessable, AngularWebWorker, Callable, ShallowTransfer, Subscribable, WorkerController, WorkerFactoryFunctions, bootstrapWorker, ɵ0, ɵ1, ɵ2 };
//# sourceMappingURL=angular-web-worker.js.map
