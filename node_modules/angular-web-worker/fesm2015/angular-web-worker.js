import { WorkerAnnotations, WorkerUtils, WorkerEvents, WorkerObservableMessageTypes } from 'angular-web-worker/common';
import { __awaiter } from 'tslib';
import 'reflect-metadata';

const ɵ0 = (instance, config) => {
    Object.defineProperty(instance, WorkerAnnotations.Config, {
        get: function () {
            return config;
        },
        enumerable: true,
        configurable: true
    });
}, ɵ1 = (instance) => {
    const accessables = WorkerUtils.getAnnotation(instance.__proto__.constructor, WorkerAnnotations.Accessables, []);
    if (accessables) {
        accessables.forEach((item) => {
            let _val = instance[item.name];
            const getter = function () {
                const config = this.__worker_config__;
                if (config) {
                    if (config.isClient) {
                        const secret = {
                            clientSecret: config.clientSecret,
                            type: WorkerEvents.Accessable,
                            propertyName: item.name,
                            body: {
                                get: item.get,
                                set: item.set
                            }
                        };
                        return secret;
                    }
                    else {
                        return _val;
                    }
                }
                else {
                    return _val;
                }
            };
            const setter = newVal => {
                _val = newVal;
            };
            delete instance[item.name];
            Object.defineProperty(instance, item.name, {
                get: getter,
                set: setter,
                enumerable: true,
                configurable: true
            });
        });
    }
}, ɵ2 = (instance) => {
    const observables = WorkerUtils.getAnnotation(instance.__proto__.constructor, WorkerAnnotations.Observables, []);
    if (observables) {
        observables.forEach((item) => {
            let _val = instance[item.name];
            const getter = function () {
                const config = this.__worker_config__;
                if (config) {
                    if (config.isClient) {
                        const secret = {
                            clientSecret: config.clientSecret,
                            type: WorkerEvents.Observable,
                            propertyName: item.name,
                            body: null
                        };
                        return secret;
                    }
                    else {
                        return _val;
                    }
                }
                else {
                    return _val;
                }
            };
            const setter = newVal => {
                _val = newVal;
            };
            delete instance[item.name];
            Object.defineProperty(instance, item.name, {
                get: getter,
                set: setter,
                enumerable: true,
                configurable: true
            });
        });
    }
};
const WorkerFactoryFunctions = {
    /*
     * Attaches a worker configuration to an instance of a worker class
     * @param instance instance of the worker class
     * @param config configuration
     */
    setWorkerConfig: ɵ0,
    configureAccessables: ɵ1,
    configureSubscribables: ɵ2
};
/**
 * Class decorator allowing the class to be bootstrapped into a web worker script, and allowing communication with a `WorkerClient`
 */
function AngularWebWorker() {
    return function (target) {
        WorkerUtils.setAnnotation(target, WorkerAnnotations.IsWorker, true);
        WorkerUtils.setAnnotation(target, WorkerAnnotations.Factory, function create(config) {
            const instance = new target();
            WorkerFactoryFunctions.setWorkerConfig(instance, config);
            WorkerFactoryFunctions.configureAccessables(instance);
            WorkerFactoryFunctions.configureSubscribables(instance);
            return instance;
        });
    };
}

/**
 * Handles communication to and from a `WorkerClient` and triggers work with the worker class.
 */
class WorkerController {
    /**
     * Creates a new `WorkerController`
     * @param workerClass the worker class,
     * @param postMessageFn the worker postMessage function passed into constuctor allowing this to be mocked when running within the app (not the worker script)
     * @param onMessageFn the worker onmessage event function passed into constructor allowing this to be mocked when running within the app (not the worker script)
     */
    constructor(workerClass, messageBus) {
        this.workerClass = workerClass;
        this.messageBus = messageBus;
        try {
            this.worker = WorkerUtils.getAnnotation(workerClass, WorkerAnnotations.Factory)({
                isClient: false
            });
            this.subscriptions = {};
            this.registerEvents();
        }
        catch (e) { }
    }
    /**
     * Returns instance of worker class
     */
    get workerInstance() {
        return this.worker;
    }
    /**
     * Creates the event listeners to correctly handle and respond to messages recieved from a `WorkerClient`
     */
    registerEvents() {
        this.messageBus.onmessage = (ev) => {
            switch (ev.data.type) {
                case WorkerEvents.Callable:
                    this.handleCallable(ev.data);
                    break;
                case WorkerEvents.Accessable:
                    this.handleAccessable(ev.data);
                    break;
                case WorkerEvents.Observable:
                    this.handleSubscription(ev.data);
                    break;
                case WorkerEvents.Init:
                    this.handleInit(ev.data);
                    break;
            }
        };
    }
    /**
     * A utility function to create a new `WorkerResponseEvent` from the details provided by the `WorkerRequestEvent`, as well as the result to be returned
     * @param type The type of worker event
     * @param request The request that the response relates to
     * @param result data to return with the response
     */
    response(type, request, result) {
        return {
            type: type,
            isError: false,
            requestSecret: request.requestSecret,
            propertyName: request.propertyName,
            result: result
        };
    }
    /**
     * A utility function to create a new error in the form of a `WorkerResponseEvent` from the details provided by the `WorkerRequestEvent`, as well as the error to be returned
     * @param type The type of worker event
     * @param request The request that the error relates to
     * @param result the error to be returned
     */
    error(type, request, error) {
        return {
            type: type,
            isError: true,
            requestSecret: request.requestSecret,
            propertyName: request.propertyName,
            error: JSON.stringify(error, this.replaceErrors),
            result: null
        };
    }
    /**
     * A utility function as the replacer for the `JSON.stringify()` function to make the native browser `Error` class serializable to JSON
     */
    replaceErrors(key, value) {
        if (value instanceof Error) {
            const error = {};
            // tslint:disable-next-line: no-shadowed-variable
            Object.getOwnPropertyNames(value).forEach(function (key) {
                error[key] = value[key];
            });
            return error;
        }
        return value;
    }
    /**
     * Handles `WorkerEvents.Init` requests from a client by calling the `onWorkerInit` hook if implemented and only responding once the hook has been completed, regardless of whether it is
     * async or not
     * @param request request recieved from the `WorkerClient`
     */
    handleInit(request) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.worker['onWorkerInit']) {
                try {
                    const result = this.worker['onWorkerInit']();
                    let isPromise = false;
                    if (result) {
                        isPromise = result.__proto__.constructor === Promise;
                    }
                    if (isPromise) {
                        result.then(() => {
                            this.postMessage(this.response(WorkerEvents.Init, request, null));
                        }).catch((err) => {
                            this.postMessage(this.error(WorkerEvents.Init, request, err));
                        });
                    }
                    else {
                        this.postMessage(this.response(WorkerEvents.Init, request, null));
                    }
                }
                catch (e) {
                    this.postMessage(this.error(WorkerEvents.Init, request, null));
                }
            }
            else {
                this.postMessage(this.response(WorkerEvents.Init, request, null));
            }
        });
    }
    /**
     * Handles `WorkerEvents.Callable` requests from a client by calling the targeted method and responding with the method's return value
     * @param request request recieved from the `WorkerClient`
     */
    handleCallable(request) {
        return __awaiter(this, void 0, void 0, function* () {
            let response;
            try {
                request.body.arguments = this.applyShallowTransferToCallableArgs(request, request.body.arguments);
                const result = yield this.worker[request.propertyName](...request.body.arguments);
                response = this.response(WorkerEvents.Callable, request, result);
            }
            catch (e) {
                response = this.error(WorkerEvents.Callable, request, e);
            }
            finally {
                this.postMessage(response);
            }
        });
    }
    /**
     * Transfers the prototype of any function arguments decorated with `@ShallowTransfer()` which have been serialized and recieved from a `WorkerEvents.Callable` request.
     *  This occurs before the arguments are used to call the worker function.
     * @param request request recieved from the `WorkerClient`
     * @param args array of function arguments
     */
    applyShallowTransferToCallableArgs(request, args) {
        const metaData = WorkerUtils.getAnnotation(this.workerClass, WorkerAnnotations.ShallowTransferArgs, []);
        if (metaData) {
            const shallowTransferMeta = metaData.filter(x => x.name === request.propertyName);
            for (let i = 0; i < args.length; i++) {
                const meta = shallowTransferMeta.filter(x => x.argIndex === i)[0];
                if (meta) {
                    if (meta.type && args[i]) {
                        args[i].__proto__ = meta.type.prototype;
                    }
                }
            }
        }
        return args;
    }
    /**
     * Handles `WorkerEvents.Accessable` requests from a client by either setting the target property of the worker or responding with the target property's value
     * @param request request recieved from the `WorkerClient`
     */
    handleAccessable(request) {
        let response;
        try {
            const metaData = WorkerUtils.getAnnotation(this.workerClass, 'accessables', []).filter(x => x.name === request.propertyName)[0];
            if (request.body.isGet) {
                response = this.response(WorkerEvents.Accessable, request, this.worker[request.propertyName]);
            }
            else {
                this.worker[request.propertyName] = request.body.value;
                if (metaData.shallowTransfer) {
                    if (metaData.type && this.worker[request.propertyName]) {
                        this.worker[request.propertyName].__proto__ = metaData.type.prototype;
                    }
                }
                response = this.response(WorkerEvents.Accessable, request, null);
            }
        }
        catch (e) {
            response = this.error(WorkerEvents.Accessable, request, e);
        }
        finally {
            this.postMessage(response);
        }
    }
    /**
     * Handles `WorkerEvents.Subscribable` requests from a client by creating a new subscription to the targeted observable which will send messages to the client each time
     * an event is triggered by the observable. The function may also unsubscribe from a subscription depending on the details of the request
     * @param request request recieved from the `WorkerClient`
     */
    handleSubscription(request) {
        let response;
        if (!request.body.isUnsubscribe) {
            try {
                this.createSubscription(request);
                response = this.response(WorkerEvents.Observable, request, request.body.subscriptionKey);
            }
            catch (e) {
                this.removeSubscription(request.body.subscriptionKey);
                response = this.error(WorkerEvents.Observable, request, e);
            }
            finally {
                this.postMessage(response);
            }
        }
        else {
            try {
                this.removeSubscription(request.body.subscriptionKey);
                response = this.response(WorkerEvents.Observable, request, null);
            }
            catch (e) {
                response = this.error(WorkerEvents.Observable, request, e);
            }
            finally {
                this.postMessage(response);
            }
        }
    }
    /**
     * Creates a new subscription to a worker observable and adds it to the `subscriptions` dictionary. The subscriptions will send messages to the client each time
     *  and event is triggered by the observable
     * @param request request recieved from the `WorkerClient`
     */
    createSubscription(request) {
        this.removeSubscription(request.body.subscriptionKey);
        this.subscriptions[request.body.subscriptionKey] = this.worker[request.propertyName].subscribe((val) => {
            const response = {
                type: WorkerEvents.ObservableMessage,
                propertyName: request.propertyName,
                isError: false,
                requestSecret: null,
                result: {
                    key: request.body.subscriptionKey,
                    type: WorkerObservableMessageTypes.Next,
                    value: val
                }
            };
            this.postSubscriptionMessage(response);
        }, err => {
            const response = {
                type: WorkerEvents.ObservableMessage,
                propertyName: request.propertyName,
                isError: true,
                requestSecret: null,
                result: {
                    key: request.body.subscriptionKey,
                    type: WorkerObservableMessageTypes.Error,
                    error: JSON.parse(JSON.stringify(err, this.replaceErrors))
                }
            };
            this.postSubscriptionMessage(response);
        }, () => {
            const response = {
                type: WorkerEvents.ObservableMessage,
                propertyName: request.propertyName,
                isError: false,
                requestSecret: null,
                result: {
                    key: request.body.subscriptionKey,
                    type: WorkerObservableMessageTypes.Complete,
                }
            };
            this.postSubscriptionMessage(response);
        });
    }
    /**
     * Removes a subscription from the `subscriptions` dictionary, unsubscribing before it is deleted
     * @param subscriptionKey key in dictionary
     */
    removeSubscription(subscriptionKey) {
        if (this.subscriptions[subscriptionKey]) {
            this.subscriptions[subscriptionKey].unsubscribe();
        }
        delete this.subscriptions[subscriptionKey];
    }
    /**
     * Unsubscribes from all subscriptions
     */
    removeAllSubscriptions() {
        for (const key in this.subscriptions) {
            if (this.subscriptions[key]) {
                this.subscriptions[key].unsubscribe();
                delete this.subscriptions[key];
            }
        }
    }
    /**
     * A wrapper function around the `postMessage()` method allowing serialization errors to be caught and sent to the client as a `WorkerResponseEvent`.
     * Only used when the response is triggered by a request, which is not the case when the event type is `WorkerEvents.ObservableMessage`.
     * @param response reponse to send to the client
     */
    postMessage(response) {
        try {
            this.messageBus.postMessage(response);
        }
        catch (e) {
            const errorResponse = {
                type: response.type,
                isError: true,
                requestSecret: response.requestSecret,
                propertyName: response.propertyName,
                error: JSON.parse(JSON.stringify(new Error('Unable to serialize response from worker to client'), this.replaceErrors)),
                result: null
            };
            this.messageBus.postMessage(errorResponse);
        }
    }
    /**
     * A wrapper function around the `postMessage()` method allowing serialization errors to be caught and sent to the client as a `WorkerResponseEvent`.
     * Only used when the response type is `WorkerEvents.ObservableMessage` which requires a different implementation to the `WorkerController.postMessage` wrapper as it
     * is one-way communication which is not triggered by a request
     */
    postSubscriptionMessage(response) {
        try {
            this.messageBus.postMessage(response);
        }
        catch (e) {
            const errorResponse = {
                type: response.type,
                isError: true,
                requestSecret: response.requestSecret,
                propertyName: response.propertyName,
                result: {
                    key: response.result.key,
                    type: WorkerObservableMessageTypes.Error,
                    error: JSON.parse(JSON.stringify(new Error('Unable to serialize subscribable response from worker to client'), this.replaceErrors))
                },
            };
            this.messageBus.postMessage(errorResponse);
        }
    }
}

/**
 * Bootstraps the worker class when a new worker script is created in the browser. The class must be decorated with `@AngularWebWorker()`
 * @param worker worker class to bootstrap
 */
function bootstrapWorker(worker) {
    const messageBus = {
        onmessage: (ev) => {
        },
        postMessage: (msg) => {
            postMessage(msg);
        }
    };
    const workerController = new WorkerController(worker, messageBus);
    onmessage = (ev) => {
        messageBus.onmessage(ev);
    };
}

/**
 * Allows the decorated worker method to be called, and its value returned, from the `WorkerClient.call()` method.
 * Can be used on both asynchronous and synchronous methods.
 * @Serialized Functions will not be copied and circular referencing structures will cause errors. This applies to both the function arguments and the value returned by the function
 * @param options Configurable options defining how the decorated method is called from a `WorkerClient`
 */
function Callable(options) {
    return function (target, propertyKey, descriptor) {
        const opts = { shallowTransfer: false };
        if (options) {
            opts.shallowTransfer = options.shallowTransfer ? true : false;
        }
        WorkerUtils.pushAnnotation(target.constructor, WorkerAnnotations.Callables, {
            name: propertyKey,
            shallowTransfer: opts.shallowTransfer,
            returnType: Reflect.getMetadata('design:returntype', target, propertyKey)
        });
        const originalMethod = descriptor.value;
        descriptor.value = function () {
            const context = this;
            const args = Array.prototype.slice.call(arguments);
            const config = context.__worker_config__;
            if (config) {
                if (config.isClient) {
                    const secret = {
                        clientSecret: context.__worker_config__.clientSecret,
                        type: WorkerEvents.Callable,
                        propertyName: propertyKey,
                        body: {
                            args: args
                        }
                    };
                    return secret;
                }
                else {
                    return originalMethod.call(context, ...args);
                }
            }
            else {
                return originalMethod.call(context, ...args);
            }
        };
        return descriptor;
    };
}

/**
 * Allows the decorated worker property to be accessed from the `WorkerClient.get()` and `WorkerClient.set()` methods
 * @Serialized Functions will not be copied and circular referencing structures will cause errors
 * @param options configurable options defining how the decorated property can be interacted with from a `WorkerClient`
 */
function Accessable(options) {
    const opts = { get: true, set: true, shallowTransfer: false };
    if (options) {
        opts.get = options.get === false ? false : true;
        opts.set = options.set === false ? false : true;
        opts.shallowTransfer = options.shallowTransfer ? true : false;
    }
    return function (target, propertyKey) {
        WorkerUtils.pushAnnotation(target.constructor, WorkerAnnotations.Accessables, {
            name: propertyKey,
            type: Reflect.getMetadata('design:type', target, propertyKey),
            get: opts.get,
            set: opts.set,
            shallowTransfer: opts.shallowTransfer
        });
    };
}

/**
 * Allows the decorated worker property to be subscribed to, or observed through the `WorkerClient.subscribe()` and `WorkerClient.observe()` methods.
 *
 * Can only be used on multicasted RxJS observables being a `Subject`,  `BehaviorSubject`, `ReplaySubject` or `AsyncSubject`.
 * @Serialized When data is transferred through `Subject.next()`, functions will not be copied and circular referencing structures will cause errors
 */
function Subscribable() {
    return function (target, propertyKey) {
        WorkerUtils.pushAnnotation(target.constructor, WorkerAnnotations.Observables, {
            name: propertyKey,
            type: Reflect.getMetadata('design:type', target, propertyKey)
        });
    };
}

/**
 * Transfers the decorated argument's prototype when it is serialized and unserialized when the method is called from `WorkerClient.call()`. This will only have an effect if
 * the method is decorated with `@Callable()`
 * @Experimental has limitations
 */
function ShallowTransfer() {
    return function (target, propertyKey, parameterIndex) {
        const argTypes = Reflect.getMetadata('design:paramtypes', target, propertyKey);
        WorkerUtils.pushAnnotation(target.constructor, WorkerAnnotations.ShallowTransferArgs, {
            name: propertyKey,
            type: argTypes[parameterIndex],
            argIndex: parameterIndex
        });
    };
}

export { Accessable, AngularWebWorker, Callable, ShallowTransfer, Subscribable, WorkerController, WorkerFactoryFunctions, bootstrapWorker, ɵ0, ɵ1, ɵ2 };
//# sourceMappingURL=angular-web-worker.js.map
