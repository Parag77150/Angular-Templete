{"version":3,"file":"angular-web-worker-angular.js","sources":["ng://angular-web-worker/angular/lib/client-web-worker.ts","ng://angular-web-worker/angular/lib/worker-client.ts","ng://angular-web-worker/angular/lib/worker-manager.ts","ng://angular-web-worker/angular/lib/worker.module.ts"],"sourcesContent":["import { WorkerController } from 'angular-web-worker';\r\nimport { WebWorkerType, WorkerMessageBus } from 'angular-web-worker/common';\r\n\r\n/**\r\n * Used to mock the behaviour of the native `Worker` class when a `WorkerClient` is set to run in the app and not in the worker script.\r\n * Controls the flow of messages to and from a `WorkerClient` and a `WorkerController`\r\n */\r\nexport class ClientWebWorker<T> implements Partial<Worker> {\r\n\r\n    /**\r\n     * Handles execution of code in a worker\r\n     */\r\n    private controller: WorkerController<T>;\r\n\r\n    /**\r\n     * Interface for message bus provided into a `WorkerController` allowing the communication mechanism to be interchanged between in-app, and native worker\r\n     * communication mechansims\r\n     */\r\n    private messageBus: WorkerMessageBus;\r\n\r\n    /**\r\n     * Creates a new instance of a `ClientWebWorker`\r\n     * @param workerType the worker class\r\n     * @param isTestClient whether the instance is used for testing which will then mock serialization\r\n     */\r\n    constructor(workerType: WebWorkerType<T>, private isTestClient: boolean) {\r\n        this.messageBus = {\r\n            onmessage: () => { },\r\n            postMessage: (resp: any) => {\r\n                this.onmessage(new MessageEvent('ClientWebWorker', { data: this.isTestClient ? this.serialize(resp) : resp }));\r\n            }\r\n        };\r\n        this.controller = new WorkerController(workerType, this.messageBus);\r\n    }\r\n\r\n    /**\r\n     * Returns instance of worker class\r\n     */\r\n    get workerInstance(): T {\r\n        return this.controller.workerInstance;\r\n    }\r\n\r\n    /**\r\n     * Message listener for a `WorkerClient`\r\n     */\r\n    onmessage(ev: MessageEvent) {\r\n    }\r\n\r\n    /**\r\n     * Sends messages triggered from a `WorkerClient` to a `WorkerController`\r\n     */\r\n    postMessage(resp: any) {\r\n        this.messageBus.onmessage(new MessageEvent('ClientWebWorker', { data: this.isTestClient ? this.serialize(resp) : resp }));\r\n    }\r\n\r\n    /**\r\n     * Unsubscribes from all subscriptions in the `WorkerController` and then destroys the controller\r\n     */\r\n    terminate() {\r\n        this.controller.removeAllSubscriptions();\r\n        this.controller = null;\r\n    }\r\n\r\n    /**\r\n     * Used for testing to mock the serialization that occurs when native the postMessage or onmessage are used to communicate with a worker script\r\n     * @param obj object to be serialised\r\n     */\r\n    private serialize(obj: any): any {\r\n        return JSON.parse(JSON.stringify(obj));\r\n    }\r\n\r\n\r\n    /**\r\n     * Ensures class conforms to the native `Worker` class\r\n     * @NotImplemented\r\n     */\r\n    onerror(err: any) {\r\n    }\r\n\r\n    /**\r\n     * Ensures class conforms to the native `Worker` class\r\n     * @NotImplemented\r\n     */\r\n    addEventListener() {\r\n    }\r\n\r\n    /**\r\n     * Ensures class conforms to the native `Worker` class\r\n     * @NotImplemented\r\n     */\r\n    removeEventListener() {\r\n    }\r\n\r\n\r\n    /**\r\n     * Ensures class conforms to the native `Worker` class\r\n     * @NotImplemented\r\n     */\r\n    dispatchEvent(evt: Event): boolean {\r\n        return true;\r\n    }\r\n\r\n\r\n}\r\n","import { Subject, Subscription, Observable } from 'rxjs';\r\nimport { WorkerClientObservablesDict, WorkerClientRequestOpts } from './worker-client-types';\r\nimport {\r\n    WorkerResponseEvent, WorkerEvents, WorkerUtils,\r\n    WorkerAnnotations, NonObservablesOnly, AccessableMetaData, FunctionsOnly,\r\n    CallableMetaData, ObservablesOnly, WorkerObservableType, WorkerRequestEvent,\r\n    SecretResult,\r\n    WorkerEvent,\r\n    WorkerObservableMessage,\r\n    WorkerObservableMessageTypes\r\n} from 'angular-web-worker/common';\r\nimport { WorkerDefinition } from './worker.module';\r\nimport { ClientWebWorker } from './client-web-worker';\r\n\r\n\r\n/**\r\n * Provides functionality for an Angular app to access the properties, call the methods and subscribe to the events in a web worker by managing\r\n * the communication between the app and the worker. Also provides the option to execute the worker code within the app should the browser not support web workers,\r\n * although intensive work may then block the UI.\r\n */\r\nexport class WorkerClient<T> {\r\n    /**\r\n     * Reference to the browser's worker class for posting messages and terminating the worker\r\n     */\r\n    private workerRef: Worker | ClientWebWorker<T>;\r\n    /**\r\n     * The client instance of the worker class\r\n     */\r\n    private worker: T;\r\n    /**\r\n     * A secret key that must be returned when decorated properties and/or methods are called from the client instance of the worker class\r\n     */\r\n    private workerSecret?: string;\r\n    /**\r\n     * Array of secret keys containing the `workerSecret` and `WorkerRequestEvent.requestSecret`s ensuring that there are never two of the same keys at any point in time\r\n     */\r\n    private secrets: string[];\r\n    /**\r\n     * An event subject that is triggered each time a response is recieved from a `WorkerController`. This is subscribed to immediately before any request is made in the `sendRequest()` method.\r\n     * This allows the `Worker.onmessage` listener to be mapped back to an async function call from where the request originated\r\n     */\r\n    private responseEvent: Subject<WorkerResponseEvent<WorkerEvents.Callable | WorkerEvents.Accessable | WorkerEvents.Observable | WorkerEvents.ObservableMessage>>;\r\n    /**\r\n     * A dictionary of observable references that listen for events triggered by the worker after they have been subscribed or observed through the use of either the `subscribe()` or `observe` methods\r\n     */\r\n    private observables: WorkerClientObservablesDict;\r\n    /**\r\n     * Whether the worker is active after it is created with the `connect()` method and before it has been terminated by the `destroy()` method\r\n     */\r\n    private _isConnected: boolean;\r\n\r\n    /**\r\n     * Creates a new `WorkerClient`\r\n     * @param definition the worker defintion originating from the arguments of the `WorkerModule.forWorkers()` method\r\n     * @param runInApp whether the execution of the worker will occur in the app or within the worker script\r\n     * @param runInApp whether the client is used for unit testing which determines if serialization should be mocked\r\n     */\r\n    constructor(private definition: WorkerDefinition, private runInApp: boolean = false, private isTestClient: boolean = false) {\r\n    }\r\n\r\n    /**\r\n     * Creates a new worker script in the browser, or within the app, and triggers the `OnWorkerInit` hook, if implemented. If the hook is implemented the promise will only be resolved once `onWorkerInit` method\r\n     * has completed regardless of whether it is async or not\r\n     *\r\n     * This method must called before any worker methods and/or properties can be called/accessed\r\n     */\r\n    connect(): Promise<void> {\r\n        if (!this._isConnected) {\r\n            this.secrets = [];\r\n            this.workerSecret = this.generateSecretKey();\r\n            this.worker = WorkerUtils.getAnnotation<Function>(this.definition.worker, WorkerAnnotations.Factory)({\r\n                isClient: true,\r\n                clientSecret: this.workerSecret\r\n            });\r\n\r\n            if (!this.runInApp) {\r\n                this.workerRef = this.definition.initFn();\r\n            } else {\r\n                this.workerRef = new ClientWebWorker(this.definition.worker, this.isTestClient);\r\n            }\r\n            this.registerEvents();\r\n\r\n            return this.castPromise<void>(this.sendRequest(WorkerEvents.Init, {\r\n                body: () => null,\r\n                isConnect: true,\r\n                resolve: () => {\r\n                    this._isConnected = true;\r\n                    return undefined;\r\n                },\r\n                secretError: 'Could not initialise worker'\r\n            }));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Terminates the worker and unsubscribes from any subscriptions created from the `subscribe()` method\r\n     */\r\n    destroy(): void {\r\n        if (this.isConnected) {\r\n            for (const key in this.observables) {\r\n                if (this.observables[key]) {\r\n                    this.removeSubscription(key);\r\n                }\r\n            }\r\n            this.workerRef.terminate();\r\n            this.secrets = [];\r\n            this.observables = {};\r\n            this.worker = null;\r\n            this._isConnected = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Whether the worker is active after it is created with the `connect()` method and before it has been terminated by the `destroy()` method\r\n     */\r\n    get isConnected(): boolean {\r\n        return this._isConnected;\r\n    }\r\n\r\n    /**\r\n     * Returns the value of a worker property that has been decorated with `@Accessable()`. Undecorated properties will cause the promise to be rejected\r\n     * @Serialized\r\n     * @example\r\n     * // async await syntax ---\r\n     * const name: string = await client.get(w => w.name);\r\n     *\r\n     * // promise syntax ---\r\n     * client.get(w => w.name).then((name) => {\r\n     *   console.log(name);\r\n     * }).catch((err) => {\r\n     *   console.log(err);\r\n     * });\r\n     * @param property A lamda expression that returns the targeted property of the worker. The worker argument in the expression only has the properties owned by the worker class (no methods)\r\n     * and only those properties that are not RxJS subjects\r\n     */\r\n    get<PropertyType>(\r\n        property: (workerProperties: NonObservablesOnly<T>) => PropertyType\r\n    ): Promise<PropertyType> {\r\n\r\n        return this.sendRequest(WorkerEvents.Accessable, {\r\n            workerProperty: property,\r\n            additionalConditions: [{\r\n                if: (secret) => secret.body.get,\r\n                reject: (secret) => new Error(`WorkerClient: will not apply the get method to the \"${secret.propertyName}\" property because the get accessor has been explicity set to false`)\r\n            }],\r\n            secretError: 'WorkerClient: only properties decorated with @Accessable() can be used in the get method',\r\n            body: () => { return { isGet: true }; },\r\n            resolve: (resp) => {\r\n                const metaData = WorkerUtils.getAnnotation<AccessableMetaData[]>(this.definition.worker, WorkerAnnotations.Accessables).filter(x => x.name === resp.propertyName)[0];\r\n                if (metaData.shallowTransfer) {\r\n                    if (metaData.type) {\r\n                        if (metaData.type.prototype && resp.result) {\r\n                            resp.result.__proto__ = metaData.type.prototype;\r\n                        }\r\n                    }\r\n\r\n                }\r\n                return resp.result;\r\n            }\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Sets value of a worker property that has been decorated with `@Accessable()`. Undecorated properties will cause the promise to be rejected\r\n     * @Serialized\r\n\r\n     * @example\r\n     * // async await syntax ---\r\n     * await client.set(w => w.name, 'peter');\r\n     *\r\n     * // promise syntax ---\r\n     * client.set(w => w.name, 'peter').then(() => {\r\n     *   console.log('property has been set');\r\n     * }).catch((err) => {\r\n     *   console.log(err);\r\n     * });\r\n     * @param property A lamda expression that returns the targeted property of the worker. The worker argument in the expression only has the properties owned by the worker class (no methods)\r\n     * and only those properties that are not RxJS subjects\r\n     * @param value the value which the property should be set to\r\n     */\r\n    set<PropertyType>(\r\n        property: (workerProperties: NonObservablesOnly<T>) => PropertyType,\r\n        value: PropertyType\r\n    ): Promise<void> {\r\n        return this.castPromise<void>(this.sendRequest(WorkerEvents.Accessable, {\r\n            workerProperty: property,\r\n            additionalConditions: [{\r\n                if: (secret) => secret.body.set,\r\n                reject: (secret) => new Error(`WorkerClient: will not apply the set method to the \"${secret.propertyName}\" property because the set accessor has been explicity set to false`)\r\n            }],\r\n            secretError: 'WorkerClient: only properties decorated with @Accessable() can be used in the set method',\r\n            body: () => { return { isGet: false, value: value }; }\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Calls a method in the worker and returns its value. The called method can be either synchronous or asynchronous\r\n     * but must be decorated with `@Callable()` else the promise will be rejected\r\n     * @Serialized Applies to both the function arguments and the returned value\r\n     * @example\r\n     * // async await syntax ---\r\n     * const functionResult: SomeResultType = await client.call(w => w.doSomeWork('someArgument', 2123));\r\n     *\r\n     * // promise syntax ---\r\n     * client.call(w => w.doSomeWork('someArgument', 2123)).then((result) => {\r\n     *    console.log(result);\r\n     * }).catch((err) => {\r\n     *    console.log(err);\r\n     * });\r\n     * @param property A lamda expression that calls the worker method. The worker argument in the expression only has the methods owned by the worker class (not the properties)\r\n     */\r\n    call<ReturnType>(\r\n        callFn: (workerFunctions: FunctionsOnly<T>) => ReturnType\r\n    ): ReturnType extends Promise<any> ? ReturnType : Promise<ReturnType> {\r\n\r\n        return this.sendRequest(WorkerEvents.Callable, {\r\n            workerProperty: callFn,\r\n            secretError: 'WorkerClient: only methods decorated with @Callable() can be used in the call method',\r\n            body: (secret) => { return { arguments: secret.body.args }; },\r\n            resolve: (resp) => {\r\n                const metaData = WorkerUtils.getAnnotation<CallableMetaData[]>(this.definition.worker, WorkerAnnotations.Callables, []).filter(x => x.name === resp.propertyName)[0];\r\n                if (metaData.shallowTransfer) {\r\n                    if (metaData.returnType === Promise) {\r\n                        throw new Error('WorkerClient: shallowTransfer will not be true in the @Callable() decorator when the decorated method returns a promise');\r\n                    }\r\n                    if (metaData.returnType && resp.result) {\r\n                        resp.result.__proto__ = metaData.returnType.prototype;\r\n                    }\r\n                }\r\n                return resp.result;\r\n            }\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Subscribes to a worker's RxJS subject, which has been decorated with `@Subscribable()`, and then returns this subscription.\r\n     *  Supports all four RxJS subjects being `Subject`,  `BehaviorSubject`, `ReplaySubject` and `AsyncSubject`.\r\n     *\r\n     * **UNSUBSCRIBING**\r\n     *\r\n     * While the returned subscription can be destroyed with `Subscription.unsubscribe()` this is only destroys the client subscription. A subscription is also created in the worker.\r\n     * To release the resources in both the client and the worker the `WorkerClient.unsubscribe(subscription)` method should be used. The `WorkerClient.destroy()` method will\r\n     * dispose of all subscriptions correctly.\r\n     *\r\n     * @Serialized This applies to messages posted through `Subject.next()`\r\n     * @example\r\n     * // async await syntax ---\r\n     * this.workerSubscription = await client.subscribe(w => w.someEventSubject);\r\n     *\r\n     * // promise syntax ---\r\n     * client.subscribe(w => w.someEventSubject).then((subscription) => {\r\n     *    this.workerSubscription = subscription;\r\n     * }).catch((err) => {\r\n     *    console.log(err);\r\n     * });\r\n     *\r\n     * // unsubscribing --------\r\n     * await client.unsubscribe(this.workerSubscription)\r\n     * @param observable A lamda expression that returns the targeted RxJS subject of the worker. The worker argument in the expression only has the properties owned by the worker class (no methods)\r\n     * and only those properties that are RxJS subjects\r\n     * @param next Callback function that is triggered when the subject's `next()` method is called within the worker\r\n     * @param error Callback function that is triggered when the subject throws and error\r\n     * @param complete Callback function that is triggered when the subject's `complete()` method is called within the worker\r\n     */\r\n    subscribe<ObservableType>(\r\n        observable: (workerObservables: ObservablesOnly<T>) => WorkerObservableType<ObservableType>,\r\n        next: (value: ObservableType) => void,\r\n        error?: (error: any) => void,\r\n        complete?: () => void\r\n    ): Promise<Subscription> {\r\n        return this.castPromise<Subscription>(this.sendRequest(WorkerEvents.Observable, {\r\n            workerProperty: observable,\r\n            secretError: 'WorkerClient: only methods decorated with @Callable() can be used in the call method',\r\n            beforeRequest: (secret) => this.createSubscription(secret.propertyName, next, error, complete),\r\n            body: (secret, key) => { return { isUnsubscribe: false, subscriptionKey: key }; },\r\n            resolve: (resp, secret, key) => this.observables[key].subscription,\r\n            beforeReject: (resp, secret, key) => this.removeSubscription(key)\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Creates and returns a RxJS observable that is in sync with a RxJS subject within a worker. The worker subject must be decorated with `@Subscribable()` otherwise the\r\n     * promise will be rejected. Supports all four RxJS subjects being, `Subject`,  `BehaviorSubject`, `ReplaySubject` and `AsyncSubject`.\r\n     *\r\n     * **UNSUBSCRIBING**\r\n     *\r\n     * While under normal circumstances you don't need to unsubscribe from an RxJS observable, when an observable is created from a worker subject a subscription is also created in the worker.\r\n     * To release the resources in the worker the `WorkerClient.unsubscribe(observable)` method should be used. The `WorkerClient.destroy()` method will\r\n     * dispose of all observables correctly.\r\n     *\r\n     * @Serialized\r\n     * @example\r\n     * // async await syntax ---\r\n     * this.observable$ = await client.observe(w => w.someEventSubject);\r\n     *\r\n     * // promise syntax ---\r\n     * client.observe(w => w.someEventSubject).then((observable) => {\r\n     *   this.observable$ = observable;\r\n     * }).catch((err) => {\r\n     *    console.log(err);\r\n     * });\r\n     *\r\n     * // unsubscribing --------\r\n     * await client.unsubscribe(this.observable$)\r\n     * @param observable A lamda expression that returns the targeted RxJS subject of the worker. The worker argument in the expression only has the properties owned by the worker class (no methods)\r\n     * and only those properties that are RxJS subjects\r\n     */\r\n    observe<ObservableType>(\r\n        observable: (workerObservables: ObservablesOnly<T>) => WorkerObservableType<ObservableType>,\r\n    ): Promise<Observable<ObservableType>> {\r\n\r\n        return this.castPromise<Observable<ObservableType>>(this.sendRequest(WorkerEvents.Observable, {\r\n            workerProperty: observable,\r\n            secretError: 'WorkerClient: only methods decorated with @Callable() can be used in the call method',\r\n            beforeRequest: (secret) => this.createObservable(secret.propertyName),\r\n            body: (secret, key) => { return { isUnsubscribe: false, subscriptionKey: key }; },\r\n            resolve: (resp, secret, key) => this.observables[key].observable,\r\n            beforeReject: (resp, secret, key) => this.removeSubscription(key)\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Unsubscribes from an RxJS subscription or observable that has been created from the `WorkerClient.subscribe()` or `WorkerClient.observe()` methods respectively.\r\n     *  This method is neccessary to release resources within the worker. Calling `WorkerClient.destory()` will also dispose of all observables/subscriptions\r\n     * @param subscriptionOrObservable The observable or subscription that must be disposed of\r\n     */\r\n    unsubscribe(\r\n        subscriptionOrObservable: Subscription | Observable<any>\r\n    ): Promise<void> {\r\n\r\n        const key = this.findObservableKey(subscriptionOrObservable);\r\n        if (key) {\r\n            const propertyName: string = this.observables[key].propertyName;\r\n            this.removeSubscription(key);\r\n            return this.castPromise<void>(this.sendRequest(WorkerEvents.Observable, {\r\n                workerProperty: propertyName,\r\n                secretError: '',\r\n                body: (secret) => { return { isUnsubscribe: true, subscriptionKey: key }; },\r\n            }));\r\n\r\n        } else {\r\n            return new Promise((resolve) => resolve());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * A generic utility function for sending requests to, and handling the responses from a `WorkerController` used when the `runInApp` property is set to `false`\r\n     * @param type the type of worker event\r\n     * @param opts Configurable options that defines how the request is sent and how the response is handled\r\n     */\r\n    private sendRequest<EventType extends number, ReturnType>(\r\n        type: EventType,\r\n        opts: WorkerClientRequestOpts<T, EventType, ReturnType>\r\n    ): ReturnType extends Promise<any> ? ReturnType : Promise<ReturnType> {\r\n        const promise = new Promise((resolve, reject) => {\r\n            if (this._isConnected || opts.isConnect) {\r\n                try {\r\n                    const noProperty = opts.workerProperty === undefined;\r\n                    const secretResult = noProperty ? null : this.isSecret(typeof opts.workerProperty === 'string' ? this.worker[opts.workerProperty] : opts.workerProperty(this.worker), type);\r\n                    if (secretResult || noProperty) {\r\n                        // additional checks ---\r\n                        if (opts.additionalConditions) {\r\n                            for (const opt of opts.additionalConditions) {\r\n                                if (!opt.if(secretResult)) {\r\n                                    reject(opt.reject(secretResult));\r\n                                    return;\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // additional functionality ---\r\n                        let additionalContext: any;\r\n                        if (opts.beforeRequest) {\r\n                            additionalContext = opts.beforeRequest(secretResult);\r\n                        }\r\n\r\n                        // response ----\r\n                        const requestSecret = this.generateSecretKey();\r\n                        const repsonseSubscription = this.responseEvent.subscribe((resp) => {\r\n                            try {\r\n                                let isValidReponse = resp.type === type && resp.requestSecret === requestSecret;\r\n                                isValidReponse = noProperty ? isValidReponse : (isValidReponse && secretResult.propertyName === resp.propertyName);\r\n\r\n                                if (isValidReponse) {\r\n                                    if (!resp.isError) {\r\n\r\n                                        // resolve ----\r\n                                        this.removeSecretKey(requestSecret);\r\n                                        if (opts.resolve) {\r\n                                            resolve(opts.resolve(resp, secretResult, additionalContext));\r\n                                        } else {\r\n                                            resolve();\r\n                                        }\r\n                                        repsonseSubscription.unsubscribe();\r\n\r\n                                    } else {\r\n\r\n                                        // reject -----\r\n                                        this.removeSecretKey(requestSecret);\r\n                                        if (opts.beforeReject) {\r\n                                            opts.beforeReject(resp, secretResult, additionalContext);\r\n                                        }\r\n                                        repsonseSubscription.unsubscribe();\r\n                                        reject(JSON.parse(resp.error));\r\n                                    }\r\n\r\n                                }\r\n                            } catch (e) {\r\n                                reject(e);\r\n                            }\r\n                        });\r\n\r\n                        // send request -----\r\n                        const req: WorkerRequestEvent<EventType> = {\r\n                            requestSecret: requestSecret,\r\n                            propertyName: noProperty ? null : secretResult.propertyName,\r\n                            type: type,\r\n                            body: opts.body ? opts.body(secretResult, additionalContext) : null\r\n                        };\r\n                        this.postMessage(req);\r\n                    } else {\r\n                        reject(new Error(opts.secretError));\r\n                    }\r\n                } catch (e) {\r\n                    reject(e);\r\n                }\r\n            } else {\r\n                reject(new Error('WorkerClient: the WorkerClient.connect() method must be called before a worker can be accessed'));\r\n            }\r\n        });\r\n        return <any>promise;\r\n    }\r\n\r\n    /**\r\n     * A wrapper function around the `Worker.postMessage()` method to catch any serialization errors should they occur\r\n     * @param request the request to be sent to the worker\r\n     */\r\n    private postMessage<EventType extends number>(\r\n        request: WorkerRequestEvent<EventType>\r\n    ) {\r\n        try {\r\n            this.workerRef.postMessage(request);\r\n        } catch (e) {\r\n            throw new Error('Unable to serialize the request from the client to the worker');\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * A utility function to cast promises\r\n     * @param promise promise to cast\r\n     */\r\n    private castPromise<PromiseType>(\r\n        promise: Promise<any>\r\n    ): Promise<PromiseType> {\r\n        return <Promise<PromiseType>>promise;\r\n    }\r\n\r\n    /**\r\n     * Creates client subscription reference with a subscription and an RxJS subject, adds it to the `observables` dictionary with unique key and then returns the key. Called from the `subscribe()` method.\r\n     * @param propertyName the property name of the worker's RxJS subject that was subscribed to\r\n     * @param next Callback function that is triggered when the subject's `next()` method is called\r\n     * @param error Callback function that is triggered when the subject throws and error\r\n     * @param complete Callback function that is triggered when the subject's `complete()` method is called\r\n     */\r\n    private createSubscription(\r\n        propertyName: string,\r\n        next?: (value: any) => void,\r\n        error?: (error: any) => void,\r\n        complete?: () => void\r\n    ): string {\r\n        const key = this.generateSubscriptionKey(propertyName);\r\n        const subject = new Subject<any>();\r\n        const subscription = subject.subscribe(next, error, complete);\r\n        this.observables[key] = { subject: subject, subscription: subscription, propertyName: propertyName, observable: null };\r\n        return key;\r\n    }\r\n\r\n    /**\r\n     * Creates client observable reference with a RxJS observable and subject, adds it to the `observables` dictionary with unique key and then returns the key. Called from the `observe()` method.\r\n     * @param propertyName the property name of the worker's RxJS subject that was subscribed to\r\n     */\r\n    private createObservable(\r\n        propertyName: string,\r\n    ): string {\r\n        const key = this.generateSubscriptionKey(propertyName);\r\n        const subject = new Subject<any>();\r\n        this.observables[key] = { subject: subject, subscription: null, propertyName: propertyName, observable: subject.asObservable() };\r\n        return key;\r\n    }\r\n\r\n    /**\r\n     * Iterates through the `observables` dictionary to find the associated key for a particular subscription or observable. Returns null if no match is found\r\n     * @param value Subscription or observable for which the dictionary key must be found\r\n     */\r\n    private findObservableKey(\r\n        value: Subscription | Observable<any>\r\n    ): string {\r\n        for (const key in this.observables) {\r\n            if (value instanceof Subscription) {\r\n                if (this.observables[key].subscription === value) {\r\n                    return key;\r\n                }\r\n            } else {\r\n                if (this.observables[key].observable === value) {\r\n                    return key;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Remove a subscription or observable reference from `observables` dictionary. Removed subscriptions are unsubsribed before destroyed\r\n     * @param subscriptionKey unique key in the `observables` dictionary\r\n     */\r\n    private removeSubscription(\r\n        subscriptionKey: string\r\n    ) {\r\n        if (this.observables[subscriptionKey]) {\r\n            if (this.observables[subscriptionKey].subscription) {\r\n                this.observables[subscriptionKey].subscription.unsubscribe();\r\n            }\r\n        }\r\n        delete this.observables[subscriptionKey];\r\n    }\r\n\r\n    /**\r\n     * Generates a random key\r\n     * @param propertyName appended as the prefix to the key\r\n     * @param length length of the randomly generated characters\r\n     */\r\n    private generateKey(\r\n        propertyName: string,\r\n        length: number\r\n    ) {\r\n        return `${propertyName.toUpperCase()}_${Array(length).fill(null).map(() => (Math.round(Math.random() * 16)).toString(16)).join('')}`;\r\n    }\r\n\r\n    /**\r\n     * Creates a unique key for a subscription/observable reference for use in the `observables` dictionary. This key allows messages from the worker to be correctly mapped and handled in the client\r\n     * @param propertyName property name of the worker's RxJS subject which is subscribed to. This is attached as a prefix to the unique key\r\n     */\r\n    private generateSubscriptionKey(\r\n        propertyName: string\r\n    ): string {\r\n        let key = this.generateKey(propertyName, 6);\r\n        while (this.observables[key]) {\r\n            key = this.generateKey(propertyName, 6);\r\n        }\r\n        return key;\r\n    }\r\n\r\n    /**\r\n     * Creates a unique key for worker requests ensuring no two keys are avaliable at any time through the `secrets` array. Allows requests to be mapped to responses from\r\n     * the worker\r\n     * @param propertyName property name of the worker's property/method that is being called. This is attached as a prefix to the unique key\r\n     */\r\n    private generateSecretKey(\r\n        propertyName?: string\r\n    ): string {\r\n        propertyName = propertyName ? propertyName : 'client';\r\n        let key = this.generateKey(propertyName, 16);\r\n        while (this.secrets.indexOf(key) !== -1) {\r\n            key = this.generateKey(propertyName, 16);\r\n        }\r\n        this.secrets.push(key);\r\n        return key;\r\n    }\r\n\r\n    /**\r\n     * Removes a key from the `secrets` array if it exists\r\n     * @param secret unqiue key to be removed\r\n     */\r\n    private removeSecretKey(\r\n        secret: string\r\n    ) {\r\n        if (this.secrets.indexOf(secret) !== -1) {\r\n            this.secrets.splice(this.secrets.indexOf(secret), 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if a valid `SecretResult` is returned when a decorated property and/or method of the client instance of the worker class is called.\r\n     *  Returns the secret when valid otherwise returns null\r\n     * @param secretResult the returned value from calling the property or method of a client instance of a worker\r\n     * @param type the worker event type that originated the request\r\n     */\r\n    private isSecret<SecretType extends number>(\r\n        secretResult: any,\r\n        type: SecretType\r\n    ): SecretResult<SecretType> {\r\n        if (secretResult) {\r\n            if (secretResult['clientSecret'] && secretResult['propertyName'] && secretResult['type']) {\r\n                if (secretResult['clientSecret'] === this.workerSecret && secretResult['type'] === type) {\r\n                    return <SecretResult<SecretType>>secretResult;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Creates the event listeners to listen for, and handle, messages recieved through `Worker.onmessage`\r\n     */\r\n    private registerEvents() {\r\n\r\n        this.responseEvent = new Subject<WorkerResponseEvent<WorkerEvents.Callable>>();\r\n        this.observables = {};\r\n\r\n        this.workerRef.onmessage = (ev: WorkerEvent<WorkerResponseEvent<any>>) => {\r\n            switch (ev.data.type) {\r\n                case WorkerEvents.ObservableMessage:\r\n                    const body: WorkerObservableMessage = ev.data.result;\r\n                    if (this.observables[body.key]) {\r\n                        switch (body.type) {\r\n                            case WorkerObservableMessageTypes.Next:\r\n                                this.observables[body.key].subject.next(body.value);\r\n                                break;\r\n                            case WorkerObservableMessageTypes.Error:\r\n                                this.observables[body.key].subject.error(body.error);\r\n                                break;\r\n                            case WorkerObservableMessageTypes.Complete:\r\n                                this.observables[body.key].subject.complete();\r\n                        }\r\n                    }\r\n                    break;\r\n                default:\r\n                    this.responseEvent.next(ev.data);\r\n            }\r\n        };\r\n\r\n\r\n    }\r\n\r\n\r\n}\r\n","\r\nimport { WorkerClient } from './worker-client';\r\nimport { WorkerDefinition } from './worker.module';\r\nimport { WebWorkerType } from 'angular-web-worker/common';\r\n\r\n/**\r\n * Injectable angular service with a primary responsability of acting as `WorkerClient` factory through its `createClient()` method.\r\n *\r\n * **Module**\r\n *\r\n * The `WorkerModule` must be imported to provide the service, passing in worker defintions in the `WorkerModule.forWorkers()` function so that the factory method\r\n * has neccessary details to create new clients\r\n *\r\n * @example\r\n * // module ---\r\n * imports: [\r\n *  WorkerModule.forWorkers([\r\n *    {worker: AppWorker, initFn: () => new Worker('./app.worker.ts', {type: 'module'})},\r\n *  ])\r\n * ]\r\n *\r\n * // usage ---\r\n * export class AppComponent implements OnInit {\r\n *\r\n *   constructor(private workerManager: WorkerManager) {}\r\n *\r\n *   ngOnInit() {\r\n *      const client: WorkerClient<AppWorker> = this.workerManager.createClient(AppWorker);\r\n *   }\r\n *\r\n * }\r\n */\r\nexport class WorkerManager {\r\n\r\n    /**\r\n     * List of workers with details to created new worker instances. Passed into `WorkerModule.forWorkers()`\r\n     */\r\n    private workerDefinitions: WorkerDefinition[];\r\n\r\n    /**\r\n     * Creates a new `WorkerManager` and called from `WorkerModule.forWorkers()` where the angular provider is created\r\n     * @param workerDefintions List of workers with details to create new worker instances. Passed into `WorkerModule.forWorkers()`\r\n     */\r\n    constructor(workerDefintions: WorkerDefinition[]) {\r\n        this.workerDefinitions = workerDefintions ? workerDefintions : [];\r\n    }\r\n\r\n    /**\r\n     * Factory function that creates a new `WorkerClient`. The worker definitions must first be registered when importing the `WorkerModule.forWorkers()` module, otherwise\r\n     * it will throw an error\r\n     * @param workerType the worker class\r\n     * @param runInApp whether the execution of the worker code is run in the application's \"thread\". Defaults to run in the worker script\r\n     * @example\r\n     * // module ---\r\n     * imports: [\r\n     *  WorkerModule.forWorkers([\r\n     *    {worker: AppWorker, initFn: () => new Worker('./app.worker.ts', {type: 'module'})},\r\n     *  ])\r\n     * ]\r\n     *\r\n     * // usage ---\r\n     * export class AppComponent implements OnInit {\r\n     *\r\n     *   constructor(private workerManager: WorkerManager) {}\r\n     *\r\n     *   ngOnInit() {\r\n     *      let client: WorkerClient<AppWorker> ;\r\n     *      if(workerManager.isBrowserCompatible) {\r\n     *          client = this.workerManager.createClient(AppWorker);\r\n     *      } else {\r\n     *          // only if worker execution does not have UI blocking code else implement other behaviour\r\n     *          client = this.workerManager.createClient(AppWorker, true);\r\n     *      }\r\n     *   }\r\n     *\r\n     * }\r\n     */\r\n    createClient<T>(workerType: WebWorkerType<T>, runInApp: boolean = false): WorkerClient<T> {\r\n        const definition = this.workerDefinitions.filter(p => p.worker === workerType)[0];\r\n        if (definition) {\r\n            return new WorkerClient<T>(definition, runInApp);\r\n        } else {\r\n            throw new Error('WorkerManager: all web workers must be registered in the forWorkers function of the WorkerModule');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Whether the browser supports web workers\r\n     */\r\n    get isBrowserCompatible(): boolean {\r\n        return typeof Worker !== 'undefined';\r\n    }\r\n\r\n\r\n\r\n}\r\n","\r\nimport { WorkerManager } from './worker-manager';\r\nimport { ModuleWithProviders, NgModule } from '@angular/core';\r\nimport { WorkerUtils, WebWorkerType, WorkerAnnotations } from 'angular-web-worker/common';\r\n\r\n/**\r\n * Provides the `WorkerManager` service with the worker definitions passed into the static `forWorkers` method.\r\n * @example\r\n * imports: [\r\n *  WorkerModule.forWorkers([\r\n *    {worker: AppWorker, initFn: () => new Worker('./app.worker.ts', {type: 'module'})},\r\n *  ])\r\n * ]\r\n */\r\n@NgModule()\r\nexport class WorkerModule {\r\n\r\n    /**\r\n     * Returns a module with a `WorkerManager` provider\r\n     * @param workerDefinitions list of worker defintions which contain the worker class and an `initFn` function which is necessary for the\r\n     * webpack `worker-plugin` to bundle the worker seperately.\r\n     * @example\r\n     * imports: [\r\n     *  WorkerModule.forWorkers([\r\n     *    {worker: AppWorker, initFn: () => new Worker('./app.worker.ts', {type: 'module'})},\r\n     *  ])\r\n     * ]\r\n    */\r\n    static forWorkers(workerDefinitions: WorkerDefinition[]): ModuleWithProviders<any> {\r\n\r\n        workerDefinitions.forEach((definition) => {\r\n            if (!WorkerUtils.getAnnotation(definition.worker, WorkerAnnotations.IsWorker)) {\r\n                throw new Error('WorkerModule: one or more of the provided workers has not been decorated with the @AngularWebWorker decorator');\r\n            }\r\n        });\r\n\r\n        return {\r\n            ngModule: WorkerModule,\r\n            providers: [\r\n                { provide: WorkerManager, useValue: new WorkerManager(workerDefinitions) }\r\n            ]\r\n        };\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * A definition of a worker that is required to create new worker instances\r\n */\r\nexport interface WorkerDefinition {\r\n    /**\r\n     * the worker class which has been decorated with `@AngularWebWorker()`\r\n     */\r\n    worker: WebWorkerType<any>;\r\n    /**\r\n     * A function that creates a worker. This is required for the webpack `worker-plugin` to bundle the worker seperately and is used by a `WorkerClient`\r\n     * to create a new worker\r\n     *\r\n     * **IMPORTANT**\r\n     *\r\n     * The syntax is crucial for the webpack plugin. The path must be a string and the {type: 'module'} argument must be given\r\n     * @example\r\n     * () => new Worker('./app.worker.ts', {type: 'module'})\r\n     */\r\n    initFn: () => Worker;\r\n}\r\n"],"names":[],"mappings":";;;;;;AAGA;;;;AAIA,MAAa,eAAe;;;;;;IAkBxB,YAAY,UAA4B,EAAU,YAAqB;QAArB,iBAAY,GAAZ,YAAY,CAAS;QACnE,IAAI,CAAC,UAAU,GAAG;YACd,SAAS,EAAE,SAAS;YACpB,WAAW,EAAE,CAAC,IAAS;gBACnB,IAAI,CAAC,SAAS,CAAC,IAAI,YAAY,CAAC,iBAAiB,EAAE,EAAE,IAAI,EAAE,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,IAAI,EAAE,CAAC,CAAC,CAAC;aAClH;SACJ,CAAC;QACF,IAAI,CAAC,UAAU,GAAG,IAAI,gBAAgB,CAAC,UAAU,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;KACvE;;;;IAKD,IAAI,cAAc;QACd,OAAO,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC;KACzC;;;;IAKD,SAAS,CAAC,EAAgB;KACzB;;;;IAKD,WAAW,CAAC,IAAS;QACjB,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,IAAI,YAAY,CAAC,iBAAiB,EAAE,EAAE,IAAI,EAAE,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,IAAI,EAAE,CAAC,CAAC,CAAC;KAC7H;;;;IAKD,SAAS;QACL,IAAI,CAAC,UAAU,CAAC,sBAAsB,EAAE,CAAC;QACzC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;KAC1B;;;;;IAMO,SAAS,CAAC,GAAQ;QACtB,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC;KAC1C;;;;;IAOD,OAAO,CAAC,GAAQ;KACf;;;;;IAMD,gBAAgB;KACf;;;;;IAMD,mBAAmB;KAClB;;;;;IAOD,aAAa,CAAC,GAAU;QACpB,OAAO,IAAI,CAAC;KACf;CAGJ;;ACxFD;;;;;AAKA,MAAa,YAAY;;;;;;;IAqCrB,YAAoB,UAA4B,EAAU,WAAoB,KAAK,EAAU,eAAwB,KAAK;QAAtG,eAAU,GAAV,UAAU,CAAkB;QAAU,aAAQ,GAAR,QAAQ,CAAiB;QAAU,iBAAY,GAAZ,YAAY,CAAiB;KACzH;;;;;;;IAQD,OAAO;QACH,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;YACpB,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;YAClB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAC7C,IAAI,CAAC,MAAM,GAAG,WAAW,CAAC,aAAa,CAAW,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,iBAAiB,CAAC,OAAO,CAAC,CAAC;gBACjG,QAAQ,EAAE,IAAI;gBACd,YAAY,EAAE,IAAI,CAAC,YAAY;aAClC,CAAC,CAAC;YAEH,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;gBAChB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC;aAC7C;iBAAM;gBACH,IAAI,CAAC,SAAS,GAAG,IAAI,eAAe,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;aACnF;YACD,IAAI,CAAC,cAAc,EAAE,CAAC;YAEtB,OAAO,IAAI,CAAC,WAAW,CAAO,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,IAAI,EAAE;gBAC9D,IAAI,EAAE,MAAM,IAAI;gBAChB,SAAS,EAAE,IAAI;gBACf,OAAO,EAAE;oBACL,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;oBACzB,OAAO,SAAS,CAAC;iBACpB;gBACD,WAAW,EAAE,6BAA6B;aAC7C,CAAC,CAAC,CAAC;SACP;KACJ;;;;IAKD,OAAO;QACH,IAAI,IAAI,CAAC,WAAW,EAAE;YAClB,KAAK,MAAM,GAAG,IAAI,IAAI,CAAC,WAAW,EAAE;gBAChC,IAAI,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,EAAE;oBACvB,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC;iBAChC;aACJ;YACD,IAAI,CAAC,SAAS,CAAC,SAAS,EAAE,CAAC;YAC3B,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;YAClB,IAAI,CAAC,WAAW,GAAG,EAAE,CAAC;YACtB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;YACnB,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;SAC7B;KACJ;;;;IAKD,IAAI,WAAW;QACX,OAAO,IAAI,CAAC,YAAY,CAAC;KAC5B;;;;;;;;;;;;;;;;;IAkBD,GAAG,CACC,QAAmE;QAGnE,OAAO,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,UAAU,EAAE;YAC7C,cAAc,EAAE,QAAQ;YACxB,oBAAoB,EAAE,CAAC;oBACnB,EAAE,EAAE,CAAC,MAAM,KAAK,MAAM,CAAC,IAAI,CAAC,GAAG;oBAC/B,MAAM,EAAE,CAAC,MAAM,KAAK,IAAI,KAAK,CAAC,uDAAuD,MAAM,CAAC,YAAY,qEAAqE,CAAC;iBACjL,CAAC;YACF,WAAW,EAAE,0FAA0F;YACvG,IAAI,EAAE,QAAQ,OAAO,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,EAAE;YACvC,OAAO,EAAE,CAAC,IAAI;gBACV,MAAM,QAAQ,GAAG,WAAW,CAAC,aAAa,CAAuB,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,iBAAiB,CAAC,WAAW,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;gBACrK,IAAI,QAAQ,CAAC,eAAe,EAAE;oBAC1B,IAAI,QAAQ,CAAC,IAAI,EAAE;wBACf,IAAI,QAAQ,CAAC,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,MAAM,EAAE;4BACxC,IAAI,CAAC,MAAM,CAAC,SAAS,GAAG,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC;yBACnD;qBACJ;iBAEJ;gBACD,OAAO,IAAI,CAAC,MAAM,CAAC;aACtB;SACJ,CAAC,CAAC;KAEN;;;;;;;;;;;;;;;;;;;IAoBD,GAAG,CACC,QAAmE,EACnE,KAAmB;QAEnB,OAAO,IAAI,CAAC,WAAW,CAAO,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,UAAU,EAAE;YACpE,cAAc,EAAE,QAAQ;YACxB,oBAAoB,EAAE,CAAC;oBACnB,EAAE,EAAE,CAAC,MAAM,KAAK,MAAM,CAAC,IAAI,CAAC,GAAG;oBAC/B,MAAM,EAAE,CAAC,MAAM,KAAK,IAAI,KAAK,CAAC,uDAAuD,MAAM,CAAC,YAAY,qEAAqE,CAAC;iBACjL,CAAC;YACF,WAAW,EAAE,0FAA0F;YACvG,IAAI,EAAE,QAAQ,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,CAAC,EAAE;SACzD,CAAC,CAAC,CAAC;KACP;;;;;;;;;;;;;;;;;IAkBD,IAAI,CACA,MAAyD;QAGzD,OAAO,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,QAAQ,EAAE;YAC3C,cAAc,EAAE,MAAM;YACtB,WAAW,EAAE,sFAAsF;YACnG,IAAI,EAAE,CAAC,MAAM,OAAO,OAAO,EAAE,SAAS,EAAE,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,EAAE;YAC7D,OAAO,EAAE,CAAC,IAAI;gBACV,MAAM,QAAQ,GAAG,WAAW,CAAC,aAAa,CAAqB,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,iBAAiB,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;gBACrK,IAAI,QAAQ,CAAC,eAAe,EAAE;oBAC1B,IAAI,QAAQ,CAAC,UAAU,KAAK,OAAO,EAAE;wBACjC,MAAM,IAAI,KAAK,CAAC,yHAAyH,CAAC,CAAC;qBAC9I;oBACD,IAAI,QAAQ,CAAC,UAAU,IAAI,IAAI,CAAC,MAAM,EAAE;wBACpC,IAAI,CAAC,MAAM,CAAC,SAAS,GAAG,QAAQ,CAAC,UAAU,CAAC,SAAS,CAAC;qBACzD;iBACJ;gBACD,OAAO,IAAI,CAAC,MAAM,CAAC;aACtB;SACJ,CAAC,CAAC;KAEN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAgCD,SAAS,CACL,UAA2F,EAC3F,IAAqC,EACrC,KAA4B,EAC5B,QAAqB;QAErB,OAAO,IAAI,CAAC,WAAW,CAAe,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,UAAU,EAAE;YAC5E,cAAc,EAAE,UAAU;YAC1B,WAAW,EAAE,sFAAsF;YACnG,aAAa,EAAE,CAAC,MAAM,KAAK,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,YAAY,EAAE,IAAI,EAAE,KAAK,EAAE,QAAQ,CAAC;YAC9F,IAAI,EAAE,CAAC,MAAM,EAAE,GAAG,OAAO,OAAO,EAAE,aAAa,EAAE,KAAK,EAAE,eAAe,EAAE,GAAG,EAAE,CAAC,EAAE;YACjF,OAAO,EAAE,CAAC,IAAI,EAAE,MAAM,EAAE,GAAG,KAAK,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,YAAY;YAClE,YAAY,EAAE,CAAC,IAAI,EAAE,MAAM,EAAE,GAAG,KAAK,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC;SACpE,CAAC,CAAC,CAAC;KACP;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA6BD,OAAO,CACH,UAA2F;QAG3F,OAAO,IAAI,CAAC,WAAW,CAA6B,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,UAAU,EAAE;YAC1F,cAAc,EAAE,UAAU;YAC1B,WAAW,EAAE,sFAAsF;YACnG,aAAa,EAAE,CAAC,MAAM,KAAK,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,YAAY,CAAC;YACrE,IAAI,EAAE,CAAC,MAAM,EAAE,GAAG,OAAO,OAAO,EAAE,aAAa,EAAE,KAAK,EAAE,eAAe,EAAE,GAAG,EAAE,CAAC,EAAE;YACjF,OAAO,EAAE,CAAC,IAAI,EAAE,MAAM,EAAE,GAAG,KAAK,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,UAAU;YAChE,YAAY,EAAE,CAAC,IAAI,EAAE,MAAM,EAAE,GAAG,KAAK,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC;SACpE,CAAC,CAAC,CAAC;KACP;;;;;;IAOD,WAAW,CACP,wBAAwD;QAGxD,MAAM,GAAG,GAAG,IAAI,CAAC,iBAAiB,CAAC,wBAAwB,CAAC,CAAC;QAC7D,IAAI,GAAG,EAAE;YACL,MAAM,YAAY,GAAW,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,YAAY,CAAC;YAChE,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC;YAC7B,OAAO,IAAI,CAAC,WAAW,CAAO,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,UAAU,EAAE;gBACpE,cAAc,EAAE,YAAY;gBAC5B,WAAW,EAAE,EAAE;gBACf,IAAI,EAAE,CAAC,MAAM,OAAO,OAAO,EAAE,aAAa,EAAE,IAAI,EAAE,eAAe,EAAE,GAAG,EAAE,CAAC,EAAE;aAC9E,CAAC,CAAC,CAAC;SAEP;aAAM;YACH,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,KAAK,OAAO,EAAE,CAAC,CAAC;SAC9C;KACJ;;;;;;IAOO,WAAW,CACf,IAAe,EACf,IAAuD;QAEvD,MAAM,OAAO,GAAG,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM;YACxC,IAAI,IAAI,CAAC,YAAY,IAAI,IAAI,CAAC,SAAS,EAAE;gBACrC,IAAI;oBACA,MAAM,UAAU,GAAG,IAAI,CAAC,cAAc,KAAK,SAAS,CAAC;oBACrD,MAAM,YAAY,GAAG,UAAU,GAAG,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,OAAO,IAAI,CAAC,cAAc,KAAK,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,IAAI,CAAC,CAAC;oBAC5K,IAAI,YAAY,IAAI,UAAU,EAAE;;wBAE5B,IAAI,IAAI,CAAC,oBAAoB,EAAE;4BAC3B,KAAK,MAAM,GAAG,IAAI,IAAI,CAAC,oBAAoB,EAAE;gCACzC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,YAAY,CAAC,EAAE;oCACvB,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC;oCACjC,OAAO;iCACV;6BACJ;yBACJ;;wBAGD,IAAI,iBAAsB,CAAC;wBAC3B,IAAI,IAAI,CAAC,aAAa,EAAE;4BACpB,iBAAiB,GAAG,IAAI,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC;yBACxD;;wBAGD,MAAM,aAAa,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;wBAC/C,MAAM,oBAAoB,GAAG,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC,IAAI;4BAC3D,IAAI;gCACA,IAAI,cAAc,GAAG,IAAI,CAAC,IAAI,KAAK,IAAI,IAAI,IAAI,CAAC,aAAa,KAAK,aAAa,CAAC;gCAChF,cAAc,GAAG,UAAU,GAAG,cAAc,IAAI,cAAc,IAAI,YAAY,CAAC,YAAY,KAAK,IAAI,CAAC,YAAY,CAAC,CAAC;gCAEnH,IAAI,cAAc,EAAE;oCAChB,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;;wCAGf,IAAI,CAAC,eAAe,CAAC,aAAa,CAAC,CAAC;wCACpC,IAAI,IAAI,CAAC,OAAO,EAAE;4CACd,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,YAAY,EAAE,iBAAiB,CAAC,CAAC,CAAC;yCAChE;6CAAM;4CACH,OAAO,EAAE,CAAC;yCACb;wCACD,oBAAoB,CAAC,WAAW,EAAE,CAAC;qCAEtC;yCAAM;;wCAGH,IAAI,CAAC,eAAe,CAAC,aAAa,CAAC,CAAC;wCACpC,IAAI,IAAI,CAAC,YAAY,EAAE;4CACnB,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,YAAY,EAAE,iBAAiB,CAAC,CAAC;yCAC5D;wCACD,oBAAoB,CAAC,WAAW,EAAE,CAAC;wCACnC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;qCAClC;iCAEJ;6BACJ;4BAAC,OAAO,CAAC,EAAE;gCACR,MAAM,CAAC,CAAC,CAAC,CAAC;6BACb;yBACJ,CAAC,CAAC;;wBAGH,MAAM,GAAG,GAAkC;4BACvC,aAAa,EAAE,aAAa;4BAC5B,YAAY,EAAE,UAAU,GAAG,IAAI,GAAG,YAAY,CAAC,YAAY;4BAC3D,IAAI,EAAE,IAAI;4BACV,IAAI,EAAE,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,iBAAiB,CAAC,GAAG,IAAI;yBACtE,CAAC;wBACF,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;qBACzB;yBAAM;wBACH,MAAM,CAAC,IAAI,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;qBACvC;iBACJ;gBAAC,OAAO,CAAC,EAAE;oBACR,MAAM,CAAC,CAAC,CAAC,CAAC;iBACb;aACJ;iBAAM;gBACH,MAAM,CAAC,IAAI,KAAK,CAAC,gGAAgG,CAAC,CAAC,CAAC;aACvH;SACJ,CAAC,CAAC;QACH,OAAY,OAAO,CAAC;KACvB;;;;;IAMO,WAAW,CACf,OAAsC;QAEtC,IAAI;YACA,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;SACvC;QAAC,OAAO,CAAC,EAAE;YACR,MAAM,IAAI,KAAK,CAAC,+DAA+D,CAAC,CAAC;SACpF;KACJ;;;;;IAOO,WAAW,CACf,OAAqB;QAErB,OAA6B,OAAO,CAAC;KACxC;;;;;;;;IASO,kBAAkB,CACtB,YAAoB,EACpB,IAA2B,EAC3B,KAA4B,EAC5B,QAAqB;QAErB,MAAM,GAAG,GAAG,IAAI,CAAC,uBAAuB,CAAC,YAAY,CAAC,CAAC;QACvD,MAAM,OAAO,GAAG,IAAI,OAAO,EAAO,CAAC;QACnC,MAAM,YAAY,GAAG,OAAO,CAAC,SAAS,CAAC,IAAI,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;QAC9D,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,GAAG,EAAE,OAAO,EAAE,OAAO,EAAE,YAAY,EAAE,YAAY,EAAE,YAAY,EAAE,YAAY,EAAE,UAAU,EAAE,IAAI,EAAE,CAAC;QACvH,OAAO,GAAG,CAAC;KACd;;;;;IAMO,gBAAgB,CACpB,YAAoB;QAEpB,MAAM,GAAG,GAAG,IAAI,CAAC,uBAAuB,CAAC,YAAY,CAAC,CAAC;QACvD,MAAM,OAAO,GAAG,IAAI,OAAO,EAAO,CAAC;QACnC,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,GAAG,EAAE,OAAO,EAAE,OAAO,EAAE,YAAY,EAAE,IAAI,EAAE,YAAY,EAAE,YAAY,EAAE,UAAU,EAAE,OAAO,CAAC,YAAY,EAAE,EAAE,CAAC;QACjI,OAAO,GAAG,CAAC;KACd;;;;;IAMO,iBAAiB,CACrB,KAAqC;QAErC,KAAK,MAAM,GAAG,IAAI,IAAI,CAAC,WAAW,EAAE;YAChC,IAAI,KAAK,YAAY,YAAY,EAAE;gBAC/B,IAAI,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,YAAY,KAAK,KAAK,EAAE;oBAC9C,OAAO,GAAG,CAAC;iBACd;aACJ;iBAAM;gBACH,IAAI,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,UAAU,KAAK,KAAK,EAAE;oBAC5C,OAAO,GAAG,CAAC;iBACd;aACJ;SACJ;QACD,OAAO,IAAI,CAAC;KACf;;;;;IAMO,kBAAkB,CACtB,eAAuB;QAEvB,IAAI,IAAI,CAAC,WAAW,CAAC,eAAe,CAAC,EAAE;YACnC,IAAI,IAAI,CAAC,WAAW,CAAC,eAAe,CAAC,CAAC,YAAY,EAAE;gBAChD,IAAI,CAAC,WAAW,CAAC,eAAe,CAAC,CAAC,YAAY,CAAC,WAAW,EAAE,CAAC;aAChE;SACJ;QACD,OAAO,IAAI,CAAC,WAAW,CAAC,eAAe,CAAC,CAAC;KAC5C;;;;;;IAOO,WAAW,CACf,YAAoB,EACpB,MAAc;QAEd,OAAO,GAAG,YAAY,CAAC,WAAW,EAAE,IAAI,KAAK,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,EAAE,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,CAAC;KACxI;;;;;IAMO,uBAAuB,CAC3B,YAAoB;QAEpB,IAAI,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,YAAY,EAAE,CAAC,CAAC,CAAC;QAC5C,OAAO,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,EAAE;YAC1B,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,YAAY,EAAE,CAAC,CAAC,CAAC;SAC3C;QACD,OAAO,GAAG,CAAC;KACd;;;;;;IAOO,iBAAiB,CACrB,YAAqB;QAErB,YAAY,GAAG,YAAY,GAAG,YAAY,GAAG,QAAQ,CAAC;QACtD,IAAI,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;QAC7C,OAAO,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;YACrC,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;SAC5C;QACD,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACvB,OAAO,GAAG,CAAC;KACd;;;;;IAMO,eAAe,CACnB,MAAc;QAEd,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE;YACrC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC;SACxD;KACJ;;;;;;;IAQO,QAAQ,CACZ,YAAiB,EACjB,IAAgB;QAEhB,IAAI,YAAY,EAAE;YACd,IAAI,YAAY,CAAC,cAAc,CAAC,IAAI,YAAY,CAAC,cAAc,CAAC,IAAI,YAAY,CAAC,MAAM,CAAC,EAAE;gBACtF,IAAI,YAAY,CAAC,cAAc,CAAC,KAAK,IAAI,CAAC,YAAY,IAAI,YAAY,CAAC,MAAM,CAAC,KAAK,IAAI,EAAE;oBACrF,OAAiC,YAAY,CAAC;iBACjD;aACJ;SACJ;QACD,OAAO,IAAI,CAAC;KACf;;;;IAKO,cAAc;QAElB,IAAI,CAAC,aAAa,GAAG,IAAI,OAAO,EAA8C,CAAC;QAC/E,IAAI,CAAC,WAAW,GAAG,EAAE,CAAC;QAEtB,IAAI,CAAC,SAAS,CAAC,SAAS,GAAG,CAAC,EAAyC;YACjE,QAAQ,EAAE,CAAC,IAAI,CAAC,IAAI;gBAChB,KAAK,YAAY,CAAC,iBAAiB;oBAC/B,MAAM,IAAI,GAA4B,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC;oBACrD,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;wBAC5B,QAAQ,IAAI,CAAC,IAAI;4BACb,KAAK,4BAA4B,CAAC,IAAI;gCAClC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gCACpD,MAAM;4BACV,KAAK,4BAA4B,CAAC,KAAK;gCACnC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gCACrD,MAAM;4BACV,KAAK,4BAA4B,CAAC,QAAQ;gCACtC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC;yBACrD;qBACJ;oBACD,MAAM;gBACV;oBACI,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;aACxC;SACJ,CAAC;KAGL;CAGJ;;ACznBD;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA,MAAa,aAAa;;;;;IAWtB,YAAY,gBAAoC;QAC5C,IAAI,CAAC,iBAAiB,GAAG,gBAAgB,GAAG,gBAAgB,GAAG,EAAE,CAAC;KACrE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAgCD,YAAY,CAAI,UAA4B,EAAE,WAAoB,KAAK;QACnE,MAAM,UAAU,GAAG,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,KAAK,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;QAClF,IAAI,UAAU,EAAE;YACZ,OAAO,IAAI,YAAY,CAAI,UAAU,EAAE,QAAQ,CAAC,CAAC;SACpD;aAAM;YACH,MAAM,IAAI,KAAK,CAAC,kGAAkG,CAAC,CAAC;SACvH;KACJ;;;;IAKD,IAAI,mBAAmB;QACnB,OAAO,OAAO,MAAM,KAAK,WAAW,CAAC;KACxC;CAIJ;;;AC9FD,AAIA;;;;;;;;;AAUA,IAAa,YAAY,oBAAzB,MAAa,YAAY;;;;;;;;;;;;IAarB,OAAO,UAAU,CAAC,iBAAqC;QAEnD,iBAAiB,CAAC,OAAO,CAAC,CAAC,UAAU;YACjC,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC,UAAU,CAAC,MAAM,EAAE,iBAAiB,CAAC,QAAQ,CAAC,EAAE;gBAC3E,MAAM,IAAI,KAAK,CAAC,+GAA+G,CAAC,CAAC;aACpI;SACJ,CAAC,CAAC;QAEH,OAAO;YACH,QAAQ,EAAE,cAAY;YACtB,SAAS,EAAE;gBACP,EAAE,OAAO,EAAE,aAAa,EAAE,QAAQ,EAAE,IAAI,aAAa,CAAC,iBAAiB,CAAC,EAAE;aAC7E;SACJ,CAAC;KACL;CAEJ,CAAA;AA7BY,YAAY;IADxB,QAAQ,EAAE;GACE,YAAY,CA6BxB;;;;"}