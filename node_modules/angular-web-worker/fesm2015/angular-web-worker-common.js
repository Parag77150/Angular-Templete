/**
 * Worker annotation constants for decorators
 */
var WorkerAnnotations;
(function (WorkerAnnotations) {
    WorkerAnnotations["Annotation"] = "__worker_annotations__";
    WorkerAnnotations["Config"] = "__worker_config__";
    WorkerAnnotations["Callables"] = "callables";
    WorkerAnnotations["Observables"] = "observables";
    WorkerAnnotations["Accessables"] = "accessables";
    WorkerAnnotations["ShallowTransferArgs"] = "shallowTransferArgs";
    WorkerAnnotations["IsWorker"] = "isWorker";
    WorkerAnnotations["Factory"] = "workerFactory";
})(WorkerAnnotations || (WorkerAnnotations = {}));

/**
 * A set of static utility functions for creating and retrieving worker annotations
 */
class WorkerUtils {
    /**
     * Creates or replaces a worker annotation
     * @param cls Class or object that the annotations will be attached to
     * @param propertyKey name of the annotated property
     * @param value the value of the annotation
     */
    static setAnnotation(cls, propertyKey, value) {
        if (cls.hasOwnProperty(WorkerAnnotations.Annotation)) {
            cls[WorkerAnnotations.Annotation][propertyKey] = value;
        }
        else {
            Object.defineProperty(cls, WorkerAnnotations.Annotation, {
                value: {}
            });
            WorkerUtils.setAnnotation(cls, propertyKey, value);
        }
    }
    /**
     * Adds an item to an array for a particular annotation property. If no array exists a new array will be created before the item is added
     * @param cls Class or object that the annotations will be attached to
     * @param propertyKey name of the annotated array
     * @param value the item to add in the array
     */
    static pushAnnotation(cls, propertyKey, value) {
        if (cls.hasOwnProperty(WorkerAnnotations.Annotation)) {
            if (cls[WorkerAnnotations.Annotation].hasOwnProperty(propertyKey)) {
                cls[WorkerAnnotations.Annotation][propertyKey].push(value);
            }
            else {
                cls[WorkerAnnotations.Annotation][propertyKey] = [];
                cls[WorkerAnnotations.Annotation][propertyKey].push(value);
            }
        }
        else {
            Object.defineProperty(cls, WorkerAnnotations.Annotation, {
                value: {}
            });
            WorkerUtils.pushAnnotation(cls, propertyKey, value);
        }
    }
    /**
     * Returns an annotated worker property. Allows for a generic type argument to specify the return type of the annotation
     * @param cls Class or object that the annotations is attached to
     * @param propertyKey name of the annotated array
     * @param ifUndefined the returned value if the annotated property does not exist
     */
    static getAnnotation(cls, propertyKey, ifUndefined = null) {
        if (cls.hasOwnProperty(WorkerAnnotations.Annotation)) {
            return cls[WorkerAnnotations.Annotation][propertyKey];
        }
        else {
            return ifUndefined;
        }
    }
}

/**
 * Numeric enum of worker event types that are sent between a `WorkerClient` and a `WorkerController`
 */
var WorkerEvents;
(function (WorkerEvents) {
    /**
     * Event type for calling worker methods decorated with `@Callable()`. Triggered in the `WorkerClient.call()` method
     */
    WorkerEvents[WorkerEvents["Callable"] = 1] = "Callable";
    /**
     * Event type for accessing worker properties decorated with `@Accessable()`. Triggered in the `WorkerClient.get()` and `WorkerClient.set()` methods
     */
    WorkerEvents[WorkerEvents["Accessable"] = 2] = "Accessable";
    /**
     * Event type for creating and/or removing subscriptions or observables from RxJS subjects within a worker that are decorated with `@Subscribable()`.
     * Triggered in the `WorkerClient.subscribe()`, `WorkerClient.observe()` and `WorkerClient.unsubscribe()`
     */
    WorkerEvents[WorkerEvents["Observable"] = 3] = "Observable";
    /**
     * Event type for observables that are triggered within the worker and delivered to a `WorkerClient` which occurs after a client has subscribed to, or observed a worker subject.
     * This differs from the other events types as it is one-way communication and therefore is not triggered by a request but rather observables in the worker
     */
    WorkerEvents[WorkerEvents["ObservableMessage"] = 4] = "ObservableMessage";
    /**
     * Event type when the worker script is created in the browser which triggers the `onWorkerInit` life-cycle hook if implemented
     */
    WorkerEvents[WorkerEvents["Init"] = 5] = "Init";
})(WorkerEvents || (WorkerEvents = {}));
/**
  * The event type when a `WorkerResponseEvent` response is sent to a client after being triggered by an obvservable in the worker
  */
var WorkerObservableMessageTypes;
(function (WorkerObservableMessageTypes) {
    WorkerObservableMessageTypes[WorkerObservableMessageTypes["Next"] = 1] = "Next";
    WorkerObservableMessageTypes[WorkerObservableMessageTypes["Error"] = 2] = "Error";
    WorkerObservableMessageTypes[WorkerObservableMessageTypes["Complete"] = 3] = "Complete";
})(WorkerObservableMessageTypes || (WorkerObservableMessageTypes = {}));

export { WorkerAnnotations, WorkerEvents, WorkerObservableMessageTypes, WorkerUtils };
//# sourceMappingURL=angular-web-worker-common.js.map
