(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs'), require('angular-web-worker/common'), require('angular-web-worker'), require('@angular/core')) :
    typeof define === 'function' && define.amd ? define('angular-web-worker/angular', ['exports', 'rxjs', 'angular-web-worker/common', 'angular-web-worker', '@angular/core'], factory) :
    (global = global || self, factory((global['angular-web-worker'] = global['angular-web-worker'] || {}, global['angular-web-worker'].angular = {}), global.rxjs, global['angular-web-worker'].common, global['angular-web-worker'], global.ng.core));
}(this, function (exports, rxjs, common, angularWebWorker, core) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    /**
     * Used to mock the behaviour of the native `Worker` class when a `WorkerClient` is set to run in the app and not in the worker script.
     * Controls the flow of messages to and from a `WorkerClient` and a `WorkerController`
     */
    var ClientWebWorker = /** @class */ (function () {
        /**
         * Creates a new instance of a `ClientWebWorker`
         * @param workerType the worker class
         * @param isTestClient whether the instance is used for testing which will then mock serialization
         */
        function ClientWebWorker(workerType, isTestClient) {
            var _this = this;
            this.isTestClient = isTestClient;
            this.messageBus = {
                onmessage: function () { },
                postMessage: function (resp) {
                    _this.onmessage(new MessageEvent('ClientWebWorker', { data: _this.isTestClient ? _this.serialize(resp) : resp }));
                }
            };
            this.controller = new angularWebWorker.WorkerController(workerType, this.messageBus);
        }
        Object.defineProperty(ClientWebWorker.prototype, "workerInstance", {
            /**
             * Returns instance of worker class
             */
            get: function () {
                return this.controller.workerInstance;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Message listener for a `WorkerClient`
         */
        ClientWebWorker.prototype.onmessage = function (ev) {
        };
        /**
         * Sends messages triggered from a `WorkerClient` to a `WorkerController`
         */
        ClientWebWorker.prototype.postMessage = function (resp) {
            this.messageBus.onmessage(new MessageEvent('ClientWebWorker', { data: this.isTestClient ? this.serialize(resp) : resp }));
        };
        /**
         * Unsubscribes from all subscriptions in the `WorkerController` and then destroys the controller
         */
        ClientWebWorker.prototype.terminate = function () {
            this.controller.removeAllSubscriptions();
            this.controller = null;
        };
        /**
         * Used for testing to mock the serialization that occurs when native the postMessage or onmessage are used to communicate with a worker script
         * @param obj object to be serialised
         */
        ClientWebWorker.prototype.serialize = function (obj) {
            return JSON.parse(JSON.stringify(obj));
        };
        /**
         * Ensures class conforms to the native `Worker` class
         * @NotImplemented
         */
        ClientWebWorker.prototype.onerror = function (err) {
        };
        /**
         * Ensures class conforms to the native `Worker` class
         * @NotImplemented
         */
        ClientWebWorker.prototype.addEventListener = function () {
        };
        /**
         * Ensures class conforms to the native `Worker` class
         * @NotImplemented
         */
        ClientWebWorker.prototype.removeEventListener = function () {
        };
        /**
         * Ensures class conforms to the native `Worker` class
         * @NotImplemented
         */
        ClientWebWorker.prototype.dispatchEvent = function (evt) {
            return true;
        };
        return ClientWebWorker;
    }());

    /**
     * Provides functionality for an Angular app to access the properties, call the methods and subscribe to the events in a web worker by managing
     * the communication between the app and the worker. Also provides the option to execute the worker code within the app should the browser not support web workers,
     * although intensive work may then block the UI.
     */
    var WorkerClient = /** @class */ (function () {
        /**
         * Creates a new `WorkerClient`
         * @param definition the worker defintion originating from the arguments of the `WorkerModule.forWorkers()` method
         * @param runInApp whether the execution of the worker will occur in the app or within the worker script
         * @param runInApp whether the client is used for unit testing which determines if serialization should be mocked
         */
        function WorkerClient(definition, runInApp, isTestClient) {
            if (runInApp === void 0) { runInApp = false; }
            if (isTestClient === void 0) { isTestClient = false; }
            this.definition = definition;
            this.runInApp = runInApp;
            this.isTestClient = isTestClient;
        }
        /**
         * Creates a new worker script in the browser, or within the app, and triggers the `OnWorkerInit` hook, if implemented. If the hook is implemented the promise will only be resolved once `onWorkerInit` method
         * has completed regardless of whether it is async or not
         *
         * This method must called before any worker methods and/or properties can be called/accessed
         */
        WorkerClient.prototype.connect = function () {
            var _this = this;
            if (!this._isConnected) {
                this.secrets = [];
                this.workerSecret = this.generateSecretKey();
                this.worker = common.WorkerUtils.getAnnotation(this.definition.worker, common.WorkerAnnotations.Factory)({
                    isClient: true,
                    clientSecret: this.workerSecret
                });
                if (!this.runInApp) {
                    this.workerRef = this.definition.initFn();
                }
                else {
                    this.workerRef = new ClientWebWorker(this.definition.worker, this.isTestClient);
                }
                this.registerEvents();
                return this.castPromise(this.sendRequest(common.WorkerEvents.Init, {
                    body: function () { return null; },
                    isConnect: true,
                    resolve: function () {
                        _this._isConnected = true;
                        return undefined;
                    },
                    secretError: 'Could not initialise worker'
                }));
            }
        };
        /**
         * Terminates the worker and unsubscribes from any subscriptions created from the `subscribe()` method
         */
        WorkerClient.prototype.destroy = function () {
            if (this.isConnected) {
                for (var key in this.observables) {
                    if (this.observables[key]) {
                        this.removeSubscription(key);
                    }
                }
                this.workerRef.terminate();
                this.secrets = [];
                this.observables = {};
                this.worker = null;
                this._isConnected = false;
            }
        };
        Object.defineProperty(WorkerClient.prototype, "isConnected", {
            /**
             * Whether the worker is active after it is created with the `connect()` method and before it has been terminated by the `destroy()` method
             */
            get: function () {
                return this._isConnected;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns the value of a worker property that has been decorated with `@Accessable()`. Undecorated properties will cause the promise to be rejected
         * @Serialized
         * @example
         * // async await syntax ---
         * const name: string = await client.get(w => w.name);
         *
         * // promise syntax ---
         * client.get(w => w.name).then((name) => {
         *   console.log(name);
         * }).catch((err) => {
         *   console.log(err);
         * });
         * @param property A lamda expression that returns the targeted property of the worker. The worker argument in the expression only has the properties owned by the worker class (no methods)
         * and only those properties that are not RxJS subjects
         */
        WorkerClient.prototype.get = function (property) {
            var _this = this;
            return this.sendRequest(common.WorkerEvents.Accessable, {
                workerProperty: property,
                additionalConditions: [{
                        if: function (secret) { return secret.body.get; },
                        reject: function (secret) { return new Error("WorkerClient: will not apply the get method to the \"" + secret.propertyName + "\" property because the get accessor has been explicity set to false"); }
                    }],
                secretError: 'WorkerClient: only properties decorated with @Accessable() can be used in the get method',
                body: function () { return { isGet: true }; },
                resolve: function (resp) {
                    var metaData = common.WorkerUtils.getAnnotation(_this.definition.worker, common.WorkerAnnotations.Accessables).filter(function (x) { return x.name === resp.propertyName; })[0];
                    if (metaData.shallowTransfer) {
                        if (metaData.type) {
                            if (metaData.type.prototype && resp.result) {
                                resp.result.__proto__ = metaData.type.prototype;
                            }
                        }
                    }
                    return resp.result;
                }
            });
        };
        /**
         * Sets value of a worker property that has been decorated with `@Accessable()`. Undecorated properties will cause the promise to be rejected
         * @Serialized

         * @example
         * // async await syntax ---
         * await client.set(w => w.name, 'peter');
         *
         * // promise syntax ---
         * client.set(w => w.name, 'peter').then(() => {
         *   console.log('property has been set');
         * }).catch((err) => {
         *   console.log(err);
         * });
         * @param property A lamda expression that returns the targeted property of the worker. The worker argument in the expression only has the properties owned by the worker class (no methods)
         * and only those properties that are not RxJS subjects
         * @param value the value which the property should be set to
         */
        WorkerClient.prototype.set = function (property, value) {
            return this.castPromise(this.sendRequest(common.WorkerEvents.Accessable, {
                workerProperty: property,
                additionalConditions: [{
                        if: function (secret) { return secret.body.set; },
                        reject: function (secret) { return new Error("WorkerClient: will not apply the set method to the \"" + secret.propertyName + "\" property because the set accessor has been explicity set to false"); }
                    }],
                secretError: 'WorkerClient: only properties decorated with @Accessable() can be used in the set method',
                body: function () { return { isGet: false, value: value }; }
            }));
        };
        /**
         * Calls a method in the worker and returns its value. The called method can be either synchronous or asynchronous
         * but must be decorated with `@Callable()` else the promise will be rejected
         * @Serialized Applies to both the function arguments and the returned value
         * @example
         * // async await syntax ---
         * const functionResult: SomeResultType = await client.call(w => w.doSomeWork('someArgument', 2123));
         *
         * // promise syntax ---
         * client.call(w => w.doSomeWork('someArgument', 2123)).then((result) => {
         *    console.log(result);
         * }).catch((err) => {
         *    console.log(err);
         * });
         * @param property A lamda expression that calls the worker method. The worker argument in the expression only has the methods owned by the worker class (not the properties)
         */
        WorkerClient.prototype.call = function (callFn) {
            var _this = this;
            return this.sendRequest(common.WorkerEvents.Callable, {
                workerProperty: callFn,
                secretError: 'WorkerClient: only methods decorated with @Callable() can be used in the call method',
                body: function (secret) { return { arguments: secret.body.args }; },
                resolve: function (resp) {
                    var metaData = common.WorkerUtils.getAnnotation(_this.definition.worker, common.WorkerAnnotations.Callables, []).filter(function (x) { return x.name === resp.propertyName; })[0];
                    if (metaData.shallowTransfer) {
                        if (metaData.returnType === Promise) {
                            throw new Error('WorkerClient: shallowTransfer will not be true in the @Callable() decorator when the decorated method returns a promise');
                        }
                        if (metaData.returnType && resp.result) {
                            resp.result.__proto__ = metaData.returnType.prototype;
                        }
                    }
                    return resp.result;
                }
            });
        };
        /**
         * Subscribes to a worker's RxJS subject, which has been decorated with `@Subscribable()`, and then returns this subscription.
         *  Supports all four RxJS subjects being `Subject`,  `BehaviorSubject`, `ReplaySubject` and `AsyncSubject`.
         *
         * **UNSUBSCRIBING**
         *
         * While the returned subscription can be destroyed with `Subscription.unsubscribe()` this is only destroys the client subscription. A subscription is also created in the worker.
         * To release the resources in both the client and the worker the `WorkerClient.unsubscribe(subscription)` method should be used. The `WorkerClient.destroy()` method will
         * dispose of all subscriptions correctly.
         *
         * @Serialized This applies to messages posted through `Subject.next()`
         * @example
         * // async await syntax ---
         * this.workerSubscription = await client.subscribe(w => w.someEventSubject);
         *
         * // promise syntax ---
         * client.subscribe(w => w.someEventSubject).then((subscription) => {
         *    this.workerSubscription = subscription;
         * }).catch((err) => {
         *    console.log(err);
         * });
         *
         * // unsubscribing --------
         * await client.unsubscribe(this.workerSubscription)
         * @param observable A lamda expression that returns the targeted RxJS subject of the worker. The worker argument in the expression only has the properties owned by the worker class (no methods)
         * and only those properties that are RxJS subjects
         * @param next Callback function that is triggered when the subject's `next()` method is called within the worker
         * @param error Callback function that is triggered when the subject throws and error
         * @param complete Callback function that is triggered when the subject's `complete()` method is called within the worker
         */
        WorkerClient.prototype.subscribe = function (observable, next, error, complete) {
            var _this = this;
            return this.castPromise(this.sendRequest(common.WorkerEvents.Observable, {
                workerProperty: observable,
                secretError: 'WorkerClient: only methods decorated with @Callable() can be used in the call method',
                beforeRequest: function (secret) { return _this.createSubscription(secret.propertyName, next, error, complete); },
                body: function (secret, key) { return { isUnsubscribe: false, subscriptionKey: key }; },
                resolve: function (resp, secret, key) { return _this.observables[key].subscription; },
                beforeReject: function (resp, secret, key) { return _this.removeSubscription(key); }
            }));
        };
        /**
         * Creates and returns a RxJS observable that is in sync with a RxJS subject within a worker. The worker subject must be decorated with `@Subscribable()` otherwise the
         * promise will be rejected. Supports all four RxJS subjects being, `Subject`,  `BehaviorSubject`, `ReplaySubject` and `AsyncSubject`.
         *
         * **UNSUBSCRIBING**
         *
         * While under normal circumstances you don't need to unsubscribe from an RxJS observable, when an observable is created from a worker subject a subscription is also created in the worker.
         * To release the resources in the worker the `WorkerClient.unsubscribe(observable)` method should be used. The `WorkerClient.destroy()` method will
         * dispose of all observables correctly.
         *
         * @Serialized
         * @example
         * // async await syntax ---
         * this.observable$ = await client.observe(w => w.someEventSubject);
         *
         * // promise syntax ---
         * client.observe(w => w.someEventSubject).then((observable) => {
         *   this.observable$ = observable;
         * }).catch((err) => {
         *    console.log(err);
         * });
         *
         * // unsubscribing --------
         * await client.unsubscribe(this.observable$)
         * @param observable A lamda expression that returns the targeted RxJS subject of the worker. The worker argument in the expression only has the properties owned by the worker class (no methods)
         * and only those properties that are RxJS subjects
         */
        WorkerClient.prototype.observe = function (observable) {
            var _this = this;
            return this.castPromise(this.sendRequest(common.WorkerEvents.Observable, {
                workerProperty: observable,
                secretError: 'WorkerClient: only methods decorated with @Callable() can be used in the call method',
                beforeRequest: function (secret) { return _this.createObservable(secret.propertyName); },
                body: function (secret, key) { return { isUnsubscribe: false, subscriptionKey: key }; },
                resolve: function (resp, secret, key) { return _this.observables[key].observable; },
                beforeReject: function (resp, secret, key) { return _this.removeSubscription(key); }
            }));
        };
        /**
         * Unsubscribes from an RxJS subscription or observable that has been created from the `WorkerClient.subscribe()` or `WorkerClient.observe()` methods respectively.
         *  This method is neccessary to release resources within the worker. Calling `WorkerClient.destory()` will also dispose of all observables/subscriptions
         * @param subscriptionOrObservable The observable or subscription that must be disposed of
         */
        WorkerClient.prototype.unsubscribe = function (subscriptionOrObservable) {
            var key = this.findObservableKey(subscriptionOrObservable);
            if (key) {
                var propertyName = this.observables[key].propertyName;
                this.removeSubscription(key);
                return this.castPromise(this.sendRequest(common.WorkerEvents.Observable, {
                    workerProperty: propertyName,
                    secretError: '',
                    body: function (secret) { return { isUnsubscribe: true, subscriptionKey: key }; },
                }));
            }
            else {
                return new Promise(function (resolve) { return resolve(); });
            }
        };
        /**
         * A generic utility function for sending requests to, and handling the responses from a `WorkerController` used when the `runInApp` property is set to `false`
         * @param type the type of worker event
         * @param opts Configurable options that defines how the request is sent and how the response is handled
         */
        WorkerClient.prototype.sendRequest = function (type, opts) {
            var _this = this;
            var promise = new Promise(function (resolve, reject) {
                var e_1, _a;
                if (_this._isConnected || opts.isConnect) {
                    try {
                        var noProperty_1 = opts.workerProperty === undefined;
                        var secretResult_1 = noProperty_1 ? null : _this.isSecret(typeof opts.workerProperty === 'string' ? _this.worker[opts.workerProperty] : opts.workerProperty(_this.worker), type);
                        if (secretResult_1 || noProperty_1) {
                            // additional checks ---
                            if (opts.additionalConditions) {
                                try {
                                    for (var _b = __values(opts.additionalConditions), _c = _b.next(); !_c.done; _c = _b.next()) {
                                        var opt = _c.value;
                                        if (!opt.if(secretResult_1)) {
                                            reject(opt.reject(secretResult_1));
                                            return;
                                        }
                                    }
                                }
                                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                                finally {
                                    try {
                                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                                    }
                                    finally { if (e_1) throw e_1.error; }
                                }
                            }
                            // additional functionality ---
                            var additionalContext_1;
                            if (opts.beforeRequest) {
                                additionalContext_1 = opts.beforeRequest(secretResult_1);
                            }
                            // response ----
                            var requestSecret_1 = _this.generateSecretKey();
                            var repsonseSubscription_1 = _this.responseEvent.subscribe(function (resp) {
                                try {
                                    var isValidReponse = resp.type === type && resp.requestSecret === requestSecret_1;
                                    isValidReponse = noProperty_1 ? isValidReponse : (isValidReponse && secretResult_1.propertyName === resp.propertyName);
                                    if (isValidReponse) {
                                        if (!resp.isError) {
                                            // resolve ----
                                            _this.removeSecretKey(requestSecret_1);
                                            if (opts.resolve) {
                                                resolve(opts.resolve(resp, secretResult_1, additionalContext_1));
                                            }
                                            else {
                                                resolve();
                                            }
                                            repsonseSubscription_1.unsubscribe();
                                        }
                                        else {
                                            // reject -----
                                            _this.removeSecretKey(requestSecret_1);
                                            if (opts.beforeReject) {
                                                opts.beforeReject(resp, secretResult_1, additionalContext_1);
                                            }
                                            repsonseSubscription_1.unsubscribe();
                                            reject(JSON.parse(resp.error));
                                        }
                                    }
                                }
                                catch (e) {
                                    reject(e);
                                }
                            });
                            // send request -----
                            var req = {
                                requestSecret: requestSecret_1,
                                propertyName: noProperty_1 ? null : secretResult_1.propertyName,
                                type: type,
                                body: opts.body ? opts.body(secretResult_1, additionalContext_1) : null
                            };
                            _this.postMessage(req);
                        }
                        else {
                            reject(new Error(opts.secretError));
                        }
                    }
                    catch (e) {
                        reject(e);
                    }
                }
                else {
                    reject(new Error('WorkerClient: the WorkerClient.connect() method must be called before a worker can be accessed'));
                }
            });
            return promise;
        };
        /**
         * A wrapper function around the `Worker.postMessage()` method to catch any serialization errors should they occur
         * @param request the request to be sent to the worker
         */
        WorkerClient.prototype.postMessage = function (request) {
            try {
                this.workerRef.postMessage(request);
            }
            catch (e) {
                throw new Error('Unable to serialize the request from the client to the worker');
            }
        };
        /**
         * A utility function to cast promises
         * @param promise promise to cast
         */
        WorkerClient.prototype.castPromise = function (promise) {
            return promise;
        };
        /**
         * Creates client subscription reference with a subscription and an RxJS subject, adds it to the `observables` dictionary with unique key and then returns the key. Called from the `subscribe()` method.
         * @param propertyName the property name of the worker's RxJS subject that was subscribed to
         * @param next Callback function that is triggered when the subject's `next()` method is called
         * @param error Callback function that is triggered when the subject throws and error
         * @param complete Callback function that is triggered when the subject's `complete()` method is called
         */
        WorkerClient.prototype.createSubscription = function (propertyName, next, error, complete) {
            var key = this.generateSubscriptionKey(propertyName);
            var subject = new rxjs.Subject();
            var subscription = subject.subscribe(next, error, complete);
            this.observables[key] = { subject: subject, subscription: subscription, propertyName: propertyName, observable: null };
            return key;
        };
        /**
         * Creates client observable reference with a RxJS observable and subject, adds it to the `observables` dictionary with unique key and then returns the key. Called from the `observe()` method.
         * @param propertyName the property name of the worker's RxJS subject that was subscribed to
         */
        WorkerClient.prototype.createObservable = function (propertyName) {
            var key = this.generateSubscriptionKey(propertyName);
            var subject = new rxjs.Subject();
            this.observables[key] = { subject: subject, subscription: null, propertyName: propertyName, observable: subject.asObservable() };
            return key;
        };
        /**
         * Iterates through the `observables` dictionary to find the associated key for a particular subscription or observable. Returns null if no match is found
         * @param value Subscription or observable for which the dictionary key must be found
         */
        WorkerClient.prototype.findObservableKey = function (value) {
            for (var key in this.observables) {
                if (value instanceof rxjs.Subscription) {
                    if (this.observables[key].subscription === value) {
                        return key;
                    }
                }
                else {
                    if (this.observables[key].observable === value) {
                        return key;
                    }
                }
            }
            return null;
        };
        /**
         * Remove a subscription or observable reference from `observables` dictionary. Removed subscriptions are unsubsribed before destroyed
         * @param subscriptionKey unique key in the `observables` dictionary
         */
        WorkerClient.prototype.removeSubscription = function (subscriptionKey) {
            if (this.observables[subscriptionKey]) {
                if (this.observables[subscriptionKey].subscription) {
                    this.observables[subscriptionKey].subscription.unsubscribe();
                }
            }
            delete this.observables[subscriptionKey];
        };
        /**
         * Generates a random key
         * @param propertyName appended as the prefix to the key
         * @param length length of the randomly generated characters
         */
        WorkerClient.prototype.generateKey = function (propertyName, length) {
            return propertyName.toUpperCase() + "_" + Array(length).fill(null).map(function () { return (Math.round(Math.random() * 16)).toString(16); }).join('');
        };
        /**
         * Creates a unique key for a subscription/observable reference for use in the `observables` dictionary. This key allows messages from the worker to be correctly mapped and handled in the client
         * @param propertyName property name of the worker's RxJS subject which is subscribed to. This is attached as a prefix to the unique key
         */
        WorkerClient.prototype.generateSubscriptionKey = function (propertyName) {
            var key = this.generateKey(propertyName, 6);
            while (this.observables[key]) {
                key = this.generateKey(propertyName, 6);
            }
            return key;
        };
        /**
         * Creates a unique key for worker requests ensuring no two keys are avaliable at any time through the `secrets` array. Allows requests to be mapped to responses from
         * the worker
         * @param propertyName property name of the worker's property/method that is being called. This is attached as a prefix to the unique key
         */
        WorkerClient.prototype.generateSecretKey = function (propertyName) {
            propertyName = propertyName ? propertyName : 'client';
            var key = this.generateKey(propertyName, 16);
            while (this.secrets.indexOf(key) !== -1) {
                key = this.generateKey(propertyName, 16);
            }
            this.secrets.push(key);
            return key;
        };
        /**
         * Removes a key from the `secrets` array if it exists
         * @param secret unqiue key to be removed
         */
        WorkerClient.prototype.removeSecretKey = function (secret) {
            if (this.secrets.indexOf(secret) !== -1) {
                this.secrets.splice(this.secrets.indexOf(secret), 1);
            }
        };
        /**
         * Checks if a valid `SecretResult` is returned when a decorated property and/or method of the client instance of the worker class is called.
         *  Returns the secret when valid otherwise returns null
         * @param secretResult the returned value from calling the property or method of a client instance of a worker
         * @param type the worker event type that originated the request
         */
        WorkerClient.prototype.isSecret = function (secretResult, type) {
            if (secretResult) {
                if (secretResult['clientSecret'] && secretResult['propertyName'] && secretResult['type']) {
                    if (secretResult['clientSecret'] === this.workerSecret && secretResult['type'] === type) {
                        return secretResult;
                    }
                }
            }
            return null;
        };
        /**
         * Creates the event listeners to listen for, and handle, messages recieved through `Worker.onmessage`
         */
        WorkerClient.prototype.registerEvents = function () {
            var _this = this;
            this.responseEvent = new rxjs.Subject();
            this.observables = {};
            this.workerRef.onmessage = function (ev) {
                switch (ev.data.type) {
                    case common.WorkerEvents.ObservableMessage:
                        var body = ev.data.result;
                        if (_this.observables[body.key]) {
                            switch (body.type) {
                                case common.WorkerObservableMessageTypes.Next:
                                    _this.observables[body.key].subject.next(body.value);
                                    break;
                                case common.WorkerObservableMessageTypes.Error:
                                    _this.observables[body.key].subject.error(body.error);
                                    break;
                                case common.WorkerObservableMessageTypes.Complete:
                                    _this.observables[body.key].subject.complete();
                            }
                        }
                        break;
                    default:
                        _this.responseEvent.next(ev.data);
                }
            };
        };
        return WorkerClient;
    }());

    /**
     * Injectable angular service with a primary responsability of acting as `WorkerClient` factory through its `createClient()` method.
     *
     * **Module**
     *
     * The `WorkerModule` must be imported to provide the service, passing in worker defintions in the `WorkerModule.forWorkers()` function so that the factory method
     * has neccessary details to create new clients
     *
     * @example
     * // module ---
     * imports: [
     *  WorkerModule.forWorkers([
     *    {worker: AppWorker, initFn: () => new Worker('./app.worker.ts', {type: 'module'})},
     *  ])
     * ]
     *
     * // usage ---
     * export class AppComponent implements OnInit {
     *
     *   constructor(private workerManager: WorkerManager) {}
     *
     *   ngOnInit() {
     *      const client: WorkerClient<AppWorker> = this.workerManager.createClient(AppWorker);
     *   }
     *
     * }
     */
    var WorkerManager = /** @class */ (function () {
        /**
         * Creates a new `WorkerManager` and called from `WorkerModule.forWorkers()` where the angular provider is created
         * @param workerDefintions List of workers with details to create new worker instances. Passed into `WorkerModule.forWorkers()`
         */
        function WorkerManager(workerDefintions) {
            this.workerDefinitions = workerDefintions ? workerDefintions : [];
        }
        /**
         * Factory function that creates a new `WorkerClient`. The worker definitions must first be registered when importing the `WorkerModule.forWorkers()` module, otherwise
         * it will throw an error
         * @param workerType the worker class
         * @param runInApp whether the execution of the worker code is run in the application's "thread". Defaults to run in the worker script
         * @example
         * // module ---
         * imports: [
         *  WorkerModule.forWorkers([
         *    {worker: AppWorker, initFn: () => new Worker('./app.worker.ts', {type: 'module'})},
         *  ])
         * ]
         *
         * // usage ---
         * export class AppComponent implements OnInit {
         *
         *   constructor(private workerManager: WorkerManager) {}
         *
         *   ngOnInit() {
         *      let client: WorkerClient<AppWorker> ;
         *      if(workerManager.isBrowserCompatible) {
         *          client = this.workerManager.createClient(AppWorker);
         *      } else {
         *          // only if worker execution does not have UI blocking code else implement other behaviour
         *          client = this.workerManager.createClient(AppWorker, true);
         *      }
         *   }
         *
         * }
         */
        WorkerManager.prototype.createClient = function (workerType, runInApp) {
            if (runInApp === void 0) { runInApp = false; }
            var definition = this.workerDefinitions.filter(function (p) { return p.worker === workerType; })[0];
            if (definition) {
                return new WorkerClient(definition, runInApp);
            }
            else {
                throw new Error('WorkerManager: all web workers must be registered in the forWorkers function of the WorkerModule');
            }
        };
        Object.defineProperty(WorkerManager.prototype, "isBrowserCompatible", {
            /**
             * Whether the browser supports web workers
             */
            get: function () {
                return typeof Worker !== 'undefined';
            },
            enumerable: true,
            configurable: true
        });
        return WorkerManager;
    }());

    /**
     * Provides the `WorkerManager` service with the worker definitions passed into the static `forWorkers` method.
     * @example
     * imports: [
     *  WorkerModule.forWorkers([
     *    {worker: AppWorker, initFn: () => new Worker('./app.worker.ts', {type: 'module'})},
     *  ])
     * ]
     */
    var WorkerModule = /** @class */ (function () {
        function WorkerModule() {
        }
        WorkerModule_1 = WorkerModule;
        /**
         * Returns a module with a `WorkerManager` provider
         * @param workerDefinitions list of worker defintions which contain the worker class and an `initFn` function which is necessary for the
         * webpack `worker-plugin` to bundle the worker seperately.
         * @example
         * imports: [
         *  WorkerModule.forWorkers([
         *    {worker: AppWorker, initFn: () => new Worker('./app.worker.ts', {type: 'module'})},
         *  ])
         * ]
        */
        WorkerModule.forWorkers = function (workerDefinitions) {
            workerDefinitions.forEach(function (definition) {
                if (!common.WorkerUtils.getAnnotation(definition.worker, common.WorkerAnnotations.IsWorker)) {
                    throw new Error('WorkerModule: one or more of the provided workers has not been decorated with the @AngularWebWorker decorator');
                }
            });
            return {
                ngModule: WorkerModule_1,
                providers: [
                    { provide: WorkerManager, useValue: new WorkerManager(workerDefinitions) }
                ]
            };
        };
        var WorkerModule_1;
        WorkerModule = WorkerModule_1 = __decorate([
            core.NgModule()
        ], WorkerModule);
        return WorkerModule;
    }());

    exports.ClientWebWorker = ClientWebWorker;
    exports.WorkerClient = WorkerClient;
    exports.WorkerManager = WorkerManager;
    exports.WorkerModule = WorkerModule;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=angular-web-worker-angular.umd.js.map
