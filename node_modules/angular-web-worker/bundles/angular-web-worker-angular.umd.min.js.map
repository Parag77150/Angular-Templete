{"version":3,"sources":["ng://angular-web-worker/angular/lib/client-web-worker.ts","ng://angular-web-worker/angular/lib/worker-client.ts","../../node_modules/tslib/tslib.es6.js","ng://angular-web-worker/angular/lib/worker-manager.ts","ng://angular-web-worker/angular/lib/worker.module.ts"],"names":["ClientWebWorker","workerType","isTestClient","_this","this","messageBus","onmessage","postMessage","resp","MessageEvent","data","serialize","controller","WorkerController","Object","defineProperty","prototype","workerInstance","ev","terminate","removeAllSubscriptions","obj","JSON","parse","stringify","onerror","err","addEventListener","removeEventListener","dispatchEvent","evt","WorkerClient","definition","runInApp","connect","_isConnected","secrets","workerSecret","generateSecretKey","worker","WorkerUtils","getAnnotation","WorkerAnnotations","Factory","isClient","clientSecret","workerRef","initFn","registerEvents","castPromise","sendRequest","WorkerEvents","Init","body","isConnect","resolve","secretError","destroy","isConnected","key","observables","removeSubscription","get","property","Accessable","workerProperty","additionalConditions","if","secret","reject","Error","propertyName","isGet","metaData","Accessables","filter","x","name","shallowTransfer","type","result","__proto__","set","value","call","callFn","Callable","arguments","args","Callables","returnType","Promise","subscribe","observable","next","error","complete","Observable","beforeRequest","createSubscription","isUnsubscribe","subscriptionKey","subscription","beforeReject","observe","createObservable","unsubscribe","subscriptionOrObservable","findObservableKey","opts","noProperty_1","undefined","secretResult_1","isSecret","_b","o","m","Symbol","iterator","i","length","done","tslib_1.__values","_c","opt","additionalContext_1","requestSecret_1","repsonseSubscription_1","responseEvent","isValidReponse","requestSecret","isError","removeSecretKey","e","req","request","promise","generateSubscriptionKey","subject","Subject","asObservable","Subscription","generateKey","toUpperCase","Array","fill","map","Math","round","random","toString","join","indexOf","push","splice","secretResult","ObservableMessage","WorkerObservableMessageTypes","Next","Complete","WorkerManager","workerDefintions","workerDefinitions","createClient","p","Worker","WorkerModule","forWorkers","forEach","IsWorker","ngModule","WorkerModule_1","providers","provide","useValue","decorators","target","desc","d","c","r","getOwnPropertyDescriptor","Reflect","decorate","__decorate","NgModule"],"mappings":"ijBAOA,IAAAA,EAAA,WAkBI,SAAAA,EAAYC,EAAsCC,GAAlD,IAAAC,EAAAC,KAAkDA,KAAAF,aAAAA,EAC9CE,KAAKC,WAAa,CACdC,UAAW,aACXC,YAAa,SAACC,GACVL,EAAKG,UAAU,IAAIG,aAAa,kBAAmB,CAAEC,KAAMP,EAAKD,aAAeC,EAAKQ,UAAUH,GAAQA,OAG9GJ,KAAKQ,WAAa,IAAIC,EAAAA,iBAAiBZ,EAAYG,KAAKC,YAuEhE,OAjEIS,OAAAC,eAAIf,EAAAgB,UAAA,iBAAc,KAAlB,WACI,OAAOZ,KAAKQ,WAAWK,gDAM3BjB,EAAAgB,UAAAV,UAAA,SAAUY,KAMVlB,EAAAgB,UAAAT,YAAA,SAAYC,GACRJ,KAAKC,WAAWC,UAAU,IAAIG,aAAa,kBAAmB,CAAEC,KAAMN,KAAKF,aAAeE,KAAKO,UAAUH,GAAQA,MAMrHR,EAAAgB,UAAAG,UAAA,WACIf,KAAKQ,WAAWQ,yBAChBhB,KAAKQ,WAAa,MAOdZ,EAAAgB,UAAAL,UAAR,SAAkBU,GACd,OAAOC,KAAKC,MAAMD,KAAKE,UAAUH,KAQrCrB,EAAAgB,UAAAS,QAAA,SAAQC,KAOR1B,EAAAgB,UAAAW,iBAAA,aAOA3B,EAAAgB,UAAAY,oBAAA,aAQA5B,EAAAgB,UAAAa,cAAA,SAAcC,GACV,OAAO,GAIf9B,EAhGA,GCaA+B,EAAA,WAqCI,SAAAA,EAAoBC,EAAsCC,EAAmC/B,QAAnC,IAAA+B,IAAAA,GAAA,QAAmC,IAAA/B,IAAAA,GAAA,GAAzEE,KAAA4B,WAAAA,EAAsC5B,KAAA6B,SAAAA,EAAmC7B,KAAAF,aAAAA,EAqkBjG,OA5jBI6B,EAAAf,UAAAkB,QAAA,WAAA,IAAA/B,EAAAC,KACI,IAAKA,KAAK+B,aAeN,OAdA/B,KAAKgC,QAAU,GACfhC,KAAKiC,aAAejC,KAAKkC,oBACzBlC,KAAKmC,OAASC,EAAAA,YAAYC,cAAwBrC,KAAK4B,WAAWO,OAAQG,EAAAA,kBAAkBC,QAA9EH,CAAuF,CACjGI,UAAU,EACVC,aAAczC,KAAKiC,eAGlBjC,KAAK6B,SAGN7B,KAAK0C,UAAY,IAAI9C,EAAgBI,KAAK4B,WAAWO,OAAQnC,KAAKF,cAFlEE,KAAK0C,UAAY1C,KAAK4B,WAAWe,SAIrC3C,KAAK4C,iBAEE5C,KAAK6C,YAAkB7C,KAAK8C,YAAYC,EAAAA,aAAaC,KAAM,CAC9DC,KAAM,WAAM,OAAA,MACZC,WAAW,EACXC,QAAS,WACLpD,EAAKgC,cAAe,GAGxBqB,YAAa,kCAQzBzB,EAAAf,UAAAyC,QAAA,WACI,GAAIrD,KAAKsD,YAAa,CAClB,IAAK,IAAMC,KAAOvD,KAAKwD,YACfxD,KAAKwD,YAAYD,IACjBvD,KAAKyD,mBAAmBF,GAGhCvD,KAAK0C,UAAU3B,YACff,KAAKgC,QAAU,GACfhC,KAAKwD,YAAc,GACnBxD,KAAKmC,OAAS,KACdnC,KAAK+B,cAAe,IAO5BrB,OAAAC,eAAIgB,EAAAf,UAAA,cAAW,KAAf,WACI,OAAOZ,KAAK+B,8CAmBhBJ,EAAAf,UAAA8C,IAAA,SACIC,GADJ,IAAA5D,EAAAC,KAII,OAAOA,KAAK8C,YAAYC,EAAAA,aAAaa,WAAY,CAC7CC,eAAgBF,EAChBG,qBAAsB,CAAC,CACnBC,GAAI,SAACC,GAAW,OAAAA,EAAOf,KAAKS,KAC5BO,OAAQ,SAACD,GAAW,OAAA,IAAIE,MAAM,uDAAuDF,EAAOG,aAAY,0EAE5Gf,YAAa,2FACbH,KAAM,WAAQ,MAAO,CAAEmB,OAAO,IAC9BjB,QAAS,SAAC/C,GACN,IAAMiE,EAAWjC,EAAAA,YAAYC,cAAoCtC,EAAK6B,WAAWO,OAAQG,EAAAA,kBAAkBgC,aAAaC,OAAO,SAAAC,GAAK,OAAAA,EAAEC,OAASrE,EAAK+D,eAAc,GASlK,OARIE,EAASK,iBACLL,EAASM,MACLN,EAASM,KAAK/D,WAAaR,EAAKwE,SAChCxE,EAAKwE,OAAOC,UAAYR,EAASM,KAAK/D,WAK3CR,EAAKwE,WAwBxBjD,EAAAf,UAAAkE,IAAA,SACInB,EACAoB,GAEA,OAAO/E,KAAK6C,YAAkB7C,KAAK8C,YAAYC,EAAAA,aAAaa,WAAY,CACpEC,eAAgBF,EAChBG,qBAAsB,CAAC,CACnBC,GAAI,SAACC,GAAW,OAAAA,EAAOf,KAAK6B,KAC5Bb,OAAQ,SAACD,GAAW,OAAA,IAAIE,MAAM,uDAAuDF,EAAOG,aAAY,0EAE5Gf,YAAa,2FACbH,KAAM,WAAQ,MAAO,CAAEmB,OAAO,EAAOW,MAAOA,QAoBpDpD,EAAAf,UAAAoE,KAAA,SACIC,GADJ,IAAAlF,EAAAC,KAII,OAAOA,KAAK8C,YAAYC,EAAAA,aAAamC,SAAU,CAC3CrB,eAAgBoB,EAChB7B,YAAa,uFACbH,KAAM,SAACe,GAAa,MAAO,CAAEmB,UAAWnB,EAAOf,KAAKmC,OACpDjC,QAAS,SAAC/C,GACN,IAAMiE,EAAWjC,EAAAA,YAAYC,cAAkCtC,EAAK6B,WAAWO,OAAQG,EAAAA,kBAAkB+C,UAAW,IAAId,OAAO,SAAAC,GAAK,OAAAA,EAAEC,OAASrE,EAAK+D,eAAc,GAClK,GAAIE,EAASK,gBAAiB,CAC1B,GAAIL,EAASiB,aAAeC,QACxB,MAAM,IAAIrB,MAAM,2HAEhBG,EAASiB,YAAclF,EAAKwE,SAC5BxE,EAAKwE,OAAOC,UAAYR,EAASiB,WAAW1E,WAGpD,OAAOR,EAAKwE,WAoCxBjD,EAAAf,UAAA4E,UAAA,SACIC,EACAC,EACAC,EACAC,GAJJ,IAAA7F,EAAAC,KAMI,OAAOA,KAAK6C,YAA0B7C,KAAK8C,YAAYC,EAAAA,aAAa8C,WAAY,CAC5EhC,eAAgB4B,EAChBrC,YAAa,uFACb0C,cAAe,SAAC9B,GAAW,OAAAjE,EAAKgG,mBAAmB/B,EAAOG,aAAcuB,EAAMC,EAAOC,IACrF3C,KAAM,SAACe,EAAQT,GAAU,MAAO,CAAEyC,eAAe,EAAOC,gBAAiB1C,IACzEJ,QAAS,SAAC/C,EAAM4D,EAAQT,GAAQ,OAAAxD,EAAKyD,YAAYD,GAAK2C,cACtDC,aAAc,SAAC/F,EAAM4D,EAAQT,GAAQ,OAAAxD,EAAK0D,mBAAmBF,QA+BrE5B,EAAAf,UAAAwF,QAAA,SACIX,GADJ,IAAA1F,EAAAC,KAII,OAAOA,KAAK6C,YAAwC7C,KAAK8C,YAAYC,EAAAA,aAAa8C,WAAY,CAC1FhC,eAAgB4B,EAChBrC,YAAa,uFACb0C,cAAe,SAAC9B,GAAW,OAAAjE,EAAKsG,iBAAiBrC,EAAOG,eACxDlB,KAAM,SAACe,EAAQT,GAAU,MAAO,CAAEyC,eAAe,EAAOC,gBAAiB1C,IACzEJ,QAAS,SAAC/C,EAAM4D,EAAQT,GAAQ,OAAAxD,EAAKyD,YAAYD,GAAKkC,YACtDU,aAAc,SAAC/F,EAAM4D,EAAQT,GAAQ,OAAAxD,EAAK0D,mBAAmBF,QASrE5B,EAAAf,UAAA0F,YAAA,SACIC,GAGA,IAAMhD,EAAMvD,KAAKwG,kBAAkBD,GACnC,GAAIhD,EAAK,CACL,IAAMY,EAAuBnE,KAAKwD,YAAYD,GAAKY,aAEnD,OADAnE,KAAKyD,mBAAmBF,GACjBvD,KAAK6C,YAAkB7C,KAAK8C,YAAYC,EAAAA,aAAa8C,WAAY,CACpEhC,eAAgBM,EAChBf,YAAa,GACbH,KAAM,SAACe,GAAa,MAAO,CAAEgC,eAAe,EAAMC,gBAAiB1C,OAIvE,OAAO,IAAIgC,QAAQ,SAACpC,GAAY,OAAAA,OAShCxB,EAAAf,UAAAkC,YAAR,SACI6B,EACA8B,GAFJ,IAAA1G,EAAAC,KAgFI,OA5EgB,IAAIuF,QAAQ,SAACpC,EAASc,WAClC,GAAIlE,EAAKgC,cAAgB0E,EAAKvD,UAC1B,IACI,IAAMwD,OAAqCC,IAAxBF,EAAK5C,eAClB+C,EAAeF,EAAa,KAAO3G,EAAK8G,SAAwC,iBAAxBJ,EAAK5C,eAA8B9D,EAAKoC,OAAOsE,EAAK5C,gBAAkB4C,EAAK5C,eAAe9D,EAAKoC,QAASwC,GACtK,GAAIiC,GAAgBF,EAAY,CAE5B,GAAID,EAAK3C,yBACL,IAAkB,IAAAgD,EChQvC,SAAkBC,GACrB,IAAIC,EAAsB,mBAAXC,QAAyBF,EAAEE,OAAOC,UAAWC,EAAI,EAChE,OAAIH,EAAUA,EAAEhC,KAAK+B,GACd,CACHrB,KAAM,WAEF,OADIqB,GAAKI,GAAKJ,EAAEK,SAAQL,OAAI,GACrB,CAAEhC,MAAOgC,GAAKA,EAAEI,KAAME,MAAON,KD0PFO,CAAAb,EAAK3C,sBAAoByD,EAAAT,EAAApB,QAAA6B,EAAAF,KAAAE,EAAAT,EAAApB,OAAE,CAAxC,IAAM8B,EAAGD,EAAAxC,MACV,IAAKyC,EAAIzD,GAAG6C,GAER,YADA3C,EAAOuD,EAAIvD,OAAO2C,sGAO9B,IAAIa,EACAhB,EAAKX,gBACL2B,EAAoBhB,EAAKX,cAAcc,IAI3C,IAAMc,EAAgB3H,EAAKmC,oBACrByF,EAAuB5H,EAAK6H,cAAcpC,UAAU,SAACpF,GACvD,IACI,IAAIyH,EAAiBzH,EAAKuE,OAASA,GAAQvE,EAAK0H,gBAAkBJ,GAClEG,EAAiBnB,EAAamB,EAAkBA,GAAkBjB,EAAazC,eAAiB/D,EAAK+D,gBAG5F/D,EAAK2H,SAcNhI,EAAKiI,gBAAgBN,GACjBjB,EAAKN,cACLM,EAAKN,aAAa/F,EAAMwG,EAAca,GAE1CE,EAAqBrB,cACrBrC,EAAO/C,KAAKC,MAAMf,EAAKuF,UAhBvB5F,EAAKiI,gBAAgBN,GACjBjB,EAAKtD,QACLA,EAAQsD,EAAKtD,QAAQ/C,EAAMwG,EAAca,IAEzCtE,IAEJwE,EAAqBrB,gBAc/B,MAAO2B,GACLhE,EAAOgE,MAKTC,EAAqC,CACvCJ,cAAeJ,EACfvD,aAAcuC,EAAa,KAAOE,EAAazC,aAC/CQ,KAAMA,EACN1B,KAAMwD,EAAKxD,KAAOwD,EAAKxD,KAAK2D,EAAca,GAAqB,MAEnE1H,EAAKI,YAAY+H,QAEjBjE,EAAO,IAAIC,MAAMuC,EAAKrD,cAE5B,MAAO6E,GACLhE,EAAOgE,QAGXhE,EAAO,IAAIC,MAAM,sGAUrBvC,EAAAf,UAAAT,YAAR,SACIgI,GAEA,IACInI,KAAK0C,UAAUvC,YAAYgI,GAC7B,MAAOF,GACL,MAAM,IAAI/D,MAAM,mEAShBvC,EAAAf,UAAAiC,YAAR,SACIuF,GAEA,OAA6BA,GAUzBzG,EAAAf,UAAAmF,mBAAR,SACI5B,EACAuB,EACAC,EACAC,GAEA,IAAMrC,EAAMvD,KAAKqI,wBAAwBlE,GACnCmE,EAAU,IAAIC,EAAAA,QACdrC,EAAeoC,EAAQ9C,UAAUE,EAAMC,EAAOC,GAEpD,OADA5F,KAAKwD,YAAYD,GAAO,CAAE+E,QAASA,EAASpC,aAAcA,EAAc/B,aAAcA,EAAcsB,WAAY,MACzGlC,GAOH5B,EAAAf,UAAAyF,iBAAR,SACIlC,GAEA,IAAMZ,EAAMvD,KAAKqI,wBAAwBlE,GACnCmE,EAAU,IAAIC,EAAAA,QAEpB,OADAvI,KAAKwD,YAAYD,GAAO,CAAE+E,QAASA,EAASpC,aAAc,KAAM/B,aAAcA,EAAcsB,WAAY6C,EAAQE,gBACzGjF,GAOH5B,EAAAf,UAAA4F,kBAAR,SACIzB,GAEA,IAAK,IAAMxB,KAAOvD,KAAKwD,YACnB,GAAIuB,aAAiB0D,EAAAA,cACjB,GAAIzI,KAAKwD,YAAYD,GAAK2C,eAAiBnB,EACvC,OAAOxB,OAGX,GAAIvD,KAAKwD,YAAYD,GAAKkC,aAAeV,EACrC,OAAOxB,EAInB,OAAO,MAOH5B,EAAAf,UAAA6C,mBAAR,SACIwC,GAEIjG,KAAKwD,YAAYyC,IACbjG,KAAKwD,YAAYyC,GAAiBC,cAClClG,KAAKwD,YAAYyC,GAAiBC,aAAaI,qBAGhDtG,KAAKwD,YAAYyC,IAQpBtE,EAAAf,UAAA8H,YAAR,SACIvE,EACAiD,GAEA,OAAUjD,EAAawE,cAAa,IAAIC,MAAMxB,GAAQyB,KAAK,MAAMC,IAAI,WAAM,OAACC,KAAKC,MAAsB,GAAhBD,KAAKE,UAAgBC,SAAS,MAAKC,KAAK,KAO3HxH,EAAAf,UAAAyH,wBAAR,SACIlE,GAGA,IADA,IAAIZ,EAAMvD,KAAK0I,YAAYvE,EAAc,GAClCnE,KAAKwD,YAAYD,IACpBA,EAAMvD,KAAK0I,YAAYvE,EAAc,GAEzC,OAAOZ,GAQH5B,EAAAf,UAAAsB,kBAAR,SACIiC,GAEAA,EAAeA,GAA8B,SAE7C,IADA,IAAIZ,EAAMvD,KAAK0I,YAAYvE,EAAc,KACH,IAA/BnE,KAAKgC,QAAQoH,QAAQ7F,IACxBA,EAAMvD,KAAK0I,YAAYvE,EAAc,IAGzC,OADAnE,KAAKgC,QAAQqH,KAAK9F,GACXA,GAOH5B,EAAAf,UAAAoH,gBAAR,SACIhE,IAEsC,IAAlChE,KAAKgC,QAAQoH,QAAQpF,IACrBhE,KAAKgC,QAAQsH,OAAOtJ,KAAKgC,QAAQoH,QAAQpF,GAAS,IAUlDrC,EAAAf,UAAAiG,SAAR,SACI0C,EACA5E,GAEA,OAAI4E,GACIA,EAA2B,cAAKA,EAA2B,cAAKA,EAAmB,MAC/EA,EAA2B,eAAMvJ,KAAKiC,cAAgBsH,EAAmB,OAAM5E,EAC9C4E,EAItC,MAMH5H,EAAAf,UAAAgC,eAAR,WAAA,IAAA7C,EAAAC,KAEIA,KAAK4H,cAAgB,IAAIW,EAAAA,QACzBvI,KAAKwD,YAAc,GAEnBxD,KAAK0C,UAAUxC,UAAY,SAACY,GACxB,OAAQA,EAAGR,KAAKqE,MACZ,KAAK5B,EAAAA,aAAayG,kBACd,IAAMvG,EAAgCnC,EAAGR,KAAKsE,OAC9C,GAAI7E,EAAKyD,YAAYP,EAAKM,KACtB,OAAQN,EAAK0B,MACT,KAAK8E,EAAAA,6BAA6BC,KAC9B3J,EAAKyD,YAAYP,EAAKM,KAAK+E,QAAQ5C,KAAKzC,EAAK8B,OAC7C,MACJ,KAAK0E,EAAAA,6BAA6BvF,MAC9BnE,EAAKyD,YAAYP,EAAKM,KAAK+E,QAAQ3C,MAAM1C,EAAK0C,OAC9C,MACJ,KAAK8D,EAAAA,6BAA6BE,SAC9B5J,EAAKyD,YAAYP,EAAKM,KAAK+E,QAAQ1C,WAG/C,MACJ,QACI7F,EAAK6H,cAAclC,KAAK5E,EAAGR,SAQ/CqB,EA1mBA,GEYAiI,EAAA,WAWI,SAAAA,EAAYC,GACR7J,KAAK8J,kBAAoBD,GAAsC,GAmDvE,OAlBID,EAAAhJ,UAAAmJ,aAAA,SAAgBlK,EAA8BgC,QAAA,IAAAA,IAAAA,GAAA,GAC1C,IAAMD,EAAa5B,KAAK8J,kBAAkBvF,OAAO,SAAAyF,GAAK,OAAAA,EAAE7H,SAAWtC,IAAY,GAC/E,GAAI+B,EACA,OAAO,IAAID,EAAgBC,EAAYC,GAEvC,MAAM,IAAIqC,MAAM,qGAOxBxD,OAAAC,eAAIiJ,EAAAhJ,UAAA,sBAAmB,KAAvB,WACI,MAAyB,oBAAXqJ,wCAKtBL,EA/DA,GCjBAM,EAAA,WAAA,SAAAA,WA6BA,SA7BaA,EAaFA,EAAAC,WAAP,SAAkBL,GAQd,OANAA,EAAkBM,QAAQ,SAACxI,GACvB,IAAKQ,EAAAA,YAAYC,cAAcT,EAAWO,OAAQG,EAAAA,kBAAkB+H,UAChE,MAAM,IAAInG,MAAM,mHAIjB,CACHoG,SAAUC,EACVC,UAAW,CACP,CAAEC,QAASb,EAAec,SAAU,IAAId,EAAcE,OAxBzDI,EAAYK,EFqClB,SAAoBI,EAAYC,EAAQrH,EAAKsH,GAChD,IAA2HC,EAAvHC,EAAI5F,UAAUiC,OAAQ4D,EAAID,EAAI,EAAIH,EAAkB,OAATC,EAAgBA,EAAOnK,OAAOuK,yBAAyBL,EAAQrH,GAAOsH,EACrH,GAAuB,iBAAZK,SAAoD,mBAArBA,QAAQC,SAAyBH,EAAIE,QAAQC,SAASR,EAAYC,EAAQrH,EAAKsH,QACpH,IAAK,IAAI1D,EAAIwD,EAAWvD,OAAS,EAAGD,GAAK,EAAGA,KAAS2D,EAAIH,EAAWxD,MAAI6D,GAAKD,EAAI,EAAID,EAAEE,GAAKD,EAAI,EAAID,EAAEF,EAAQrH,EAAKyH,GAAKF,EAAEF,EAAQrH,KAASyH,GAChJ,OAAOD,EAAI,GAAKC,GAAKtK,OAAOC,eAAeiK,EAAQrH,EAAKyH,GAAIA,EEzCvCI,CAAA,CADxBC,EAAAA,YACYnB,GAAb","sourcesContent":["import { WorkerController } from 'angular-web-worker';\r\nimport { WebWorkerType, WorkerMessageBus } from 'angular-web-worker/common';\r\n\r\n/**\r\n * Used to mock the behaviour of the native `Worker` class when a `WorkerClient` is set to run in the app and not in the worker script.\r\n * Controls the flow of messages to and from a `WorkerClient` and a `WorkerController`\r\n */\r\nexport class ClientWebWorker<T> implements Partial<Worker> {\r\n\r\n    /**\r\n     * Handles execution of code in a worker\r\n     */\r\n    private controller: WorkerController<T>;\r\n\r\n    /**\r\n     * Interface for message bus provided into a `WorkerController` allowing the communication mechanism to be interchanged between in-app, and native worker\r\n     * communication mechansims\r\n     */\r\n    private messageBus: WorkerMessageBus;\r\n\r\n    /**\r\n     * Creates a new instance of a `ClientWebWorker`\r\n     * @param workerType the worker class\r\n     * @param isTestClient whether the instance is used for testing which will then mock serialization\r\n     */\r\n    constructor(workerType: WebWorkerType<T>, private isTestClient: boolean) {\r\n        this.messageBus = {\r\n            onmessage: () => { },\r\n            postMessage: (resp: any) => {\r\n                this.onmessage(new MessageEvent('ClientWebWorker', { data: this.isTestClient ? this.serialize(resp) : resp }));\r\n            }\r\n        };\r\n        this.controller = new WorkerController(workerType, this.messageBus);\r\n    }\r\n\r\n    /**\r\n     * Returns instance of worker class\r\n     */\r\n    get workerInstance(): T {\r\n        return this.controller.workerInstance;\r\n    }\r\n\r\n    /**\r\n     * Message listener for a `WorkerClient`\r\n     */\r\n    onmessage(ev: MessageEvent) {\r\n    }\r\n\r\n    /**\r\n     * Sends messages triggered from a `WorkerClient` to a `WorkerController`\r\n     */\r\n    postMessage(resp: any) {\r\n        this.messageBus.onmessage(new MessageEvent('ClientWebWorker', { data: this.isTestClient ? this.serialize(resp) : resp }));\r\n    }\r\n\r\n    /**\r\n     * Unsubscribes from all subscriptions in the `WorkerController` and then destroys the controller\r\n     */\r\n    terminate() {\r\n        this.controller.removeAllSubscriptions();\r\n        this.controller = null;\r\n    }\r\n\r\n    /**\r\n     * Used for testing to mock the serialization that occurs when native the postMessage or onmessage are used to communicate with a worker script\r\n     * @param obj object to be serialised\r\n     */\r\n    private serialize(obj: any): any {\r\n        return JSON.parse(JSON.stringify(obj));\r\n    }\r\n\r\n\r\n    /**\r\n     * Ensures class conforms to the native `Worker` class\r\n     * @NotImplemented\r\n     */\r\n    onerror(err: any) {\r\n    }\r\n\r\n    /**\r\n     * Ensures class conforms to the native `Worker` class\r\n     * @NotImplemented\r\n     */\r\n    addEventListener() {\r\n    }\r\n\r\n    /**\r\n     * Ensures class conforms to the native `Worker` class\r\n     * @NotImplemented\r\n     */\r\n    removeEventListener() {\r\n    }\r\n\r\n\r\n    /**\r\n     * Ensures class conforms to the native `Worker` class\r\n     * @NotImplemented\r\n     */\r\n    dispatchEvent(evt: Event): boolean {\r\n        return true;\r\n    }\r\n\r\n\r\n}\r\n","import { Subject, Subscription, Observable } from 'rxjs';\r\nimport { WorkerClientObservablesDict, WorkerClientRequestOpts } from './worker-client-types';\r\nimport {\r\n    WorkerResponseEvent, WorkerEvents, WorkerUtils,\r\n    WorkerAnnotations, NonObservablesOnly, AccessableMetaData, FunctionsOnly,\r\n    CallableMetaData, ObservablesOnly, WorkerObservableType, WorkerRequestEvent,\r\n    SecretResult,\r\n    WorkerEvent,\r\n    WorkerObservableMessage,\r\n    WorkerObservableMessageTypes\r\n} from 'angular-web-worker/common';\r\nimport { WorkerDefinition } from './worker.module';\r\nimport { ClientWebWorker } from './client-web-worker';\r\n\r\n\r\n/**\r\n * Provides functionality for an Angular app to access the properties, call the methods and subscribe to the events in a web worker by managing\r\n * the communication between the app and the worker. Also provides the option to execute the worker code within the app should the browser not support web workers,\r\n * although intensive work may then block the UI.\r\n */\r\nexport class WorkerClient<T> {\r\n    /**\r\n     * Reference to the browser's worker class for posting messages and terminating the worker\r\n     */\r\n    private workerRef: Worker | ClientWebWorker<T>;\r\n    /**\r\n     * The client instance of the worker class\r\n     */\r\n    private worker: T;\r\n    /**\r\n     * A secret key that must be returned when decorated properties and/or methods are called from the client instance of the worker class\r\n     */\r\n    private workerSecret?: string;\r\n    /**\r\n     * Array of secret keys containing the `workerSecret` and `WorkerRequestEvent.requestSecret`s ensuring that there are never two of the same keys at any point in time\r\n     */\r\n    private secrets: string[];\r\n    /**\r\n     * An event subject that is triggered each time a response is recieved from a `WorkerController`. This is subscribed to immediately before any request is made in the `sendRequest()` method.\r\n     * This allows the `Worker.onmessage` listener to be mapped back to an async function call from where the request originated\r\n     */\r\n    private responseEvent: Subject<WorkerResponseEvent<WorkerEvents.Callable | WorkerEvents.Accessable | WorkerEvents.Observable | WorkerEvents.ObservableMessage>>;\r\n    /**\r\n     * A dictionary of observable references that listen for events triggered by the worker after they have been subscribed or observed through the use of either the `subscribe()` or `observe` methods\r\n     */\r\n    private observables: WorkerClientObservablesDict;\r\n    /**\r\n     * Whether the worker is active after it is created with the `connect()` method and before it has been terminated by the `destroy()` method\r\n     */\r\n    private _isConnected: boolean;\r\n\r\n    /**\r\n     * Creates a new `WorkerClient`\r\n     * @param definition the worker defintion originating from the arguments of the `WorkerModule.forWorkers()` method\r\n     * @param runInApp whether the execution of the worker will occur in the app or within the worker script\r\n     * @param runInApp whether the client is used for unit testing which determines if serialization should be mocked\r\n     */\r\n    constructor(private definition: WorkerDefinition, private runInApp: boolean = false, private isTestClient: boolean = false) {\r\n    }\r\n\r\n    /**\r\n     * Creates a new worker script in the browser, or within the app, and triggers the `OnWorkerInit` hook, if implemented. If the hook is implemented the promise will only be resolved once `onWorkerInit` method\r\n     * has completed regardless of whether it is async or not\r\n     *\r\n     * This method must called before any worker methods and/or properties can be called/accessed\r\n     */\r\n    connect(): Promise<void> {\r\n        if (!this._isConnected) {\r\n            this.secrets = [];\r\n            this.workerSecret = this.generateSecretKey();\r\n            this.worker = WorkerUtils.getAnnotation<Function>(this.definition.worker, WorkerAnnotations.Factory)({\r\n                isClient: true,\r\n                clientSecret: this.workerSecret\r\n            });\r\n\r\n            if (!this.runInApp) {\r\n                this.workerRef = this.definition.initFn();\r\n            } else {\r\n                this.workerRef = new ClientWebWorker(this.definition.worker, this.isTestClient);\r\n            }\r\n            this.registerEvents();\r\n\r\n            return this.castPromise<void>(this.sendRequest(WorkerEvents.Init, {\r\n                body: () => null,\r\n                isConnect: true,\r\n                resolve: () => {\r\n                    this._isConnected = true;\r\n                    return undefined;\r\n                },\r\n                secretError: 'Could not initialise worker'\r\n            }));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Terminates the worker and unsubscribes from any subscriptions created from the `subscribe()` method\r\n     */\r\n    destroy(): void {\r\n        if (this.isConnected) {\r\n            for (const key in this.observables) {\r\n                if (this.observables[key]) {\r\n                    this.removeSubscription(key);\r\n                }\r\n            }\r\n            this.workerRef.terminate();\r\n            this.secrets = [];\r\n            this.observables = {};\r\n            this.worker = null;\r\n            this._isConnected = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Whether the worker is active after it is created with the `connect()` method and before it has been terminated by the `destroy()` method\r\n     */\r\n    get isConnected(): boolean {\r\n        return this._isConnected;\r\n    }\r\n\r\n    /**\r\n     * Returns the value of a worker property that has been decorated with `@Accessable()`. Undecorated properties will cause the promise to be rejected\r\n     * @Serialized\r\n     * @example\r\n     * // async await syntax ---\r\n     * const name: string = await client.get(w => w.name);\r\n     *\r\n     * // promise syntax ---\r\n     * client.get(w => w.name).then((name) => {\r\n     *   console.log(name);\r\n     * }).catch((err) => {\r\n     *   console.log(err);\r\n     * });\r\n     * @param property A lamda expression that returns the targeted property of the worker. The worker argument in the expression only has the properties owned by the worker class (no methods)\r\n     * and only those properties that are not RxJS subjects\r\n     */\r\n    get<PropertyType>(\r\n        property: (workerProperties: NonObservablesOnly<T>) => PropertyType\r\n    ): Promise<PropertyType> {\r\n\r\n        return this.sendRequest(WorkerEvents.Accessable, {\r\n            workerProperty: property,\r\n            additionalConditions: [{\r\n                if: (secret) => secret.body.get,\r\n                reject: (secret) => new Error(`WorkerClient: will not apply the get method to the \"${secret.propertyName}\" property because the get accessor has been explicity set to false`)\r\n            }],\r\n            secretError: 'WorkerClient: only properties decorated with @Accessable() can be used in the get method',\r\n            body: () => { return { isGet: true }; },\r\n            resolve: (resp) => {\r\n                const metaData = WorkerUtils.getAnnotation<AccessableMetaData[]>(this.definition.worker, WorkerAnnotations.Accessables).filter(x => x.name === resp.propertyName)[0];\r\n                if (metaData.shallowTransfer) {\r\n                    if (metaData.type) {\r\n                        if (metaData.type.prototype && resp.result) {\r\n                            resp.result.__proto__ = metaData.type.prototype;\r\n                        }\r\n                    }\r\n\r\n                }\r\n                return resp.result;\r\n            }\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Sets value of a worker property that has been decorated with `@Accessable()`. Undecorated properties will cause the promise to be rejected\r\n     * @Serialized\r\n\r\n     * @example\r\n     * // async await syntax ---\r\n     * await client.set(w => w.name, 'peter');\r\n     *\r\n     * // promise syntax ---\r\n     * client.set(w => w.name, 'peter').then(() => {\r\n     *   console.log('property has been set');\r\n     * }).catch((err) => {\r\n     *   console.log(err);\r\n     * });\r\n     * @param property A lamda expression that returns the targeted property of the worker. The worker argument in the expression only has the properties owned by the worker class (no methods)\r\n     * and only those properties that are not RxJS subjects\r\n     * @param value the value which the property should be set to\r\n     */\r\n    set<PropertyType>(\r\n        property: (workerProperties: NonObservablesOnly<T>) => PropertyType,\r\n        value: PropertyType\r\n    ): Promise<void> {\r\n        return this.castPromise<void>(this.sendRequest(WorkerEvents.Accessable, {\r\n            workerProperty: property,\r\n            additionalConditions: [{\r\n                if: (secret) => secret.body.set,\r\n                reject: (secret) => new Error(`WorkerClient: will not apply the set method to the \"${secret.propertyName}\" property because the set accessor has been explicity set to false`)\r\n            }],\r\n            secretError: 'WorkerClient: only properties decorated with @Accessable() can be used in the set method',\r\n            body: () => { return { isGet: false, value: value }; }\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Calls a method in the worker and returns its value. The called method can be either synchronous or asynchronous\r\n     * but must be decorated with `@Callable()` else the promise will be rejected\r\n     * @Serialized Applies to both the function arguments and the returned value\r\n     * @example\r\n     * // async await syntax ---\r\n     * const functionResult: SomeResultType = await client.call(w => w.doSomeWork('someArgument', 2123));\r\n     *\r\n     * // promise syntax ---\r\n     * client.call(w => w.doSomeWork('someArgument', 2123)).then((result) => {\r\n     *    console.log(result);\r\n     * }).catch((err) => {\r\n     *    console.log(err);\r\n     * });\r\n     * @param property A lamda expression that calls the worker method. The worker argument in the expression only has the methods owned by the worker class (not the properties)\r\n     */\r\n    call<ReturnType>(\r\n        callFn: (workerFunctions: FunctionsOnly<T>) => ReturnType\r\n    ): ReturnType extends Promise<any> ? ReturnType : Promise<ReturnType> {\r\n\r\n        return this.sendRequest(WorkerEvents.Callable, {\r\n            workerProperty: callFn,\r\n            secretError: 'WorkerClient: only methods decorated with @Callable() can be used in the call method',\r\n            body: (secret) => { return { arguments: secret.body.args }; },\r\n            resolve: (resp) => {\r\n                const metaData = WorkerUtils.getAnnotation<CallableMetaData[]>(this.definition.worker, WorkerAnnotations.Callables, []).filter(x => x.name === resp.propertyName)[0];\r\n                if (metaData.shallowTransfer) {\r\n                    if (metaData.returnType === Promise) {\r\n                        throw new Error('WorkerClient: shallowTransfer will not be true in the @Callable() decorator when the decorated method returns a promise');\r\n                    }\r\n                    if (metaData.returnType && resp.result) {\r\n                        resp.result.__proto__ = metaData.returnType.prototype;\r\n                    }\r\n                }\r\n                return resp.result;\r\n            }\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Subscribes to a worker's RxJS subject, which has been decorated with `@Subscribable()`, and then returns this subscription.\r\n     *  Supports all four RxJS subjects being `Subject`,  `BehaviorSubject`, `ReplaySubject` and `AsyncSubject`.\r\n     *\r\n     * **UNSUBSCRIBING**\r\n     *\r\n     * While the returned subscription can be destroyed with `Subscription.unsubscribe()` this is only destroys the client subscription. A subscription is also created in the worker.\r\n     * To release the resources in both the client and the worker the `WorkerClient.unsubscribe(subscription)` method should be used. The `WorkerClient.destroy()` method will\r\n     * dispose of all subscriptions correctly.\r\n     *\r\n     * @Serialized This applies to messages posted through `Subject.next()`\r\n     * @example\r\n     * // async await syntax ---\r\n     * this.workerSubscription = await client.subscribe(w => w.someEventSubject);\r\n     *\r\n     * // promise syntax ---\r\n     * client.subscribe(w => w.someEventSubject).then((subscription) => {\r\n     *    this.workerSubscription = subscription;\r\n     * }).catch((err) => {\r\n     *    console.log(err);\r\n     * });\r\n     *\r\n     * // unsubscribing --------\r\n     * await client.unsubscribe(this.workerSubscription)\r\n     * @param observable A lamda expression that returns the targeted RxJS subject of the worker. The worker argument in the expression only has the properties owned by the worker class (no methods)\r\n     * and only those properties that are RxJS subjects\r\n     * @param next Callback function that is triggered when the subject's `next()` method is called within the worker\r\n     * @param error Callback function that is triggered when the subject throws and error\r\n     * @param complete Callback function that is triggered when the subject's `complete()` method is called within the worker\r\n     */\r\n    subscribe<ObservableType>(\r\n        observable: (workerObservables: ObservablesOnly<T>) => WorkerObservableType<ObservableType>,\r\n        next: (value: ObservableType) => void,\r\n        error?: (error: any) => void,\r\n        complete?: () => void\r\n    ): Promise<Subscription> {\r\n        return this.castPromise<Subscription>(this.sendRequest(WorkerEvents.Observable, {\r\n            workerProperty: observable,\r\n            secretError: 'WorkerClient: only methods decorated with @Callable() can be used in the call method',\r\n            beforeRequest: (secret) => this.createSubscription(secret.propertyName, next, error, complete),\r\n            body: (secret, key) => { return { isUnsubscribe: false, subscriptionKey: key }; },\r\n            resolve: (resp, secret, key) => this.observables[key].subscription,\r\n            beforeReject: (resp, secret, key) => this.removeSubscription(key)\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Creates and returns a RxJS observable that is in sync with a RxJS subject within a worker. The worker subject must be decorated with `@Subscribable()` otherwise the\r\n     * promise will be rejected. Supports all four RxJS subjects being, `Subject`,  `BehaviorSubject`, `ReplaySubject` and `AsyncSubject`.\r\n     *\r\n     * **UNSUBSCRIBING**\r\n     *\r\n     * While under normal circumstances you don't need to unsubscribe from an RxJS observable, when an observable is created from a worker subject a subscription is also created in the worker.\r\n     * To release the resources in the worker the `WorkerClient.unsubscribe(observable)` method should be used. The `WorkerClient.destroy()` method will\r\n     * dispose of all observables correctly.\r\n     *\r\n     * @Serialized\r\n     * @example\r\n     * // async await syntax ---\r\n     * this.observable$ = await client.observe(w => w.someEventSubject);\r\n     *\r\n     * // promise syntax ---\r\n     * client.observe(w => w.someEventSubject).then((observable) => {\r\n     *   this.observable$ = observable;\r\n     * }).catch((err) => {\r\n     *    console.log(err);\r\n     * });\r\n     *\r\n     * // unsubscribing --------\r\n     * await client.unsubscribe(this.observable$)\r\n     * @param observable A lamda expression that returns the targeted RxJS subject of the worker. The worker argument in the expression only has the properties owned by the worker class (no methods)\r\n     * and only those properties that are RxJS subjects\r\n     */\r\n    observe<ObservableType>(\r\n        observable: (workerObservables: ObservablesOnly<T>) => WorkerObservableType<ObservableType>,\r\n    ): Promise<Observable<ObservableType>> {\r\n\r\n        return this.castPromise<Observable<ObservableType>>(this.sendRequest(WorkerEvents.Observable, {\r\n            workerProperty: observable,\r\n            secretError: 'WorkerClient: only methods decorated with @Callable() can be used in the call method',\r\n            beforeRequest: (secret) => this.createObservable(secret.propertyName),\r\n            body: (secret, key) => { return { isUnsubscribe: false, subscriptionKey: key }; },\r\n            resolve: (resp, secret, key) => this.observables[key].observable,\r\n            beforeReject: (resp, secret, key) => this.removeSubscription(key)\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Unsubscribes from an RxJS subscription or observable that has been created from the `WorkerClient.subscribe()` or `WorkerClient.observe()` methods respectively.\r\n     *  This method is neccessary to release resources within the worker. Calling `WorkerClient.destory()` will also dispose of all observables/subscriptions\r\n     * @param subscriptionOrObservable The observable or subscription that must be disposed of\r\n     */\r\n    unsubscribe(\r\n        subscriptionOrObservable: Subscription | Observable<any>\r\n    ): Promise<void> {\r\n\r\n        const key = this.findObservableKey(subscriptionOrObservable);\r\n        if (key) {\r\n            const propertyName: string = this.observables[key].propertyName;\r\n            this.removeSubscription(key);\r\n            return this.castPromise<void>(this.sendRequest(WorkerEvents.Observable, {\r\n                workerProperty: propertyName,\r\n                secretError: '',\r\n                body: (secret) => { return { isUnsubscribe: true, subscriptionKey: key }; },\r\n            }));\r\n\r\n        } else {\r\n            return new Promise((resolve) => resolve());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * A generic utility function for sending requests to, and handling the responses from a `WorkerController` used when the `runInApp` property is set to `false`\r\n     * @param type the type of worker event\r\n     * @param opts Configurable options that defines how the request is sent and how the response is handled\r\n     */\r\n    private sendRequest<EventType extends number, ReturnType>(\r\n        type: EventType,\r\n        opts: WorkerClientRequestOpts<T, EventType, ReturnType>\r\n    ): ReturnType extends Promise<any> ? ReturnType : Promise<ReturnType> {\r\n        const promise = new Promise((resolve, reject) => {\r\n            if (this._isConnected || opts.isConnect) {\r\n                try {\r\n                    const noProperty = opts.workerProperty === undefined;\r\n                    const secretResult = noProperty ? null : this.isSecret(typeof opts.workerProperty === 'string' ? this.worker[opts.workerProperty] : opts.workerProperty(this.worker), type);\r\n                    if (secretResult || noProperty) {\r\n                        // additional checks ---\r\n                        if (opts.additionalConditions) {\r\n                            for (const opt of opts.additionalConditions) {\r\n                                if (!opt.if(secretResult)) {\r\n                                    reject(opt.reject(secretResult));\r\n                                    return;\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // additional functionality ---\r\n                        let additionalContext: any;\r\n                        if (opts.beforeRequest) {\r\n                            additionalContext = opts.beforeRequest(secretResult);\r\n                        }\r\n\r\n                        // response ----\r\n                        const requestSecret = this.generateSecretKey();\r\n                        const repsonseSubscription = this.responseEvent.subscribe((resp) => {\r\n                            try {\r\n                                let isValidReponse = resp.type === type && resp.requestSecret === requestSecret;\r\n                                isValidReponse = noProperty ? isValidReponse : (isValidReponse && secretResult.propertyName === resp.propertyName);\r\n\r\n                                if (isValidReponse) {\r\n                                    if (!resp.isError) {\r\n\r\n                                        // resolve ----\r\n                                        this.removeSecretKey(requestSecret);\r\n                                        if (opts.resolve) {\r\n                                            resolve(opts.resolve(resp, secretResult, additionalContext));\r\n                                        } else {\r\n                                            resolve();\r\n                                        }\r\n                                        repsonseSubscription.unsubscribe();\r\n\r\n                                    } else {\r\n\r\n                                        // reject -----\r\n                                        this.removeSecretKey(requestSecret);\r\n                                        if (opts.beforeReject) {\r\n                                            opts.beforeReject(resp, secretResult, additionalContext);\r\n                                        }\r\n                                        repsonseSubscription.unsubscribe();\r\n                                        reject(JSON.parse(resp.error));\r\n                                    }\r\n\r\n                                }\r\n                            } catch (e) {\r\n                                reject(e);\r\n                            }\r\n                        });\r\n\r\n                        // send request -----\r\n                        const req: WorkerRequestEvent<EventType> = {\r\n                            requestSecret: requestSecret,\r\n                            propertyName: noProperty ? null : secretResult.propertyName,\r\n                            type: type,\r\n                            body: opts.body ? opts.body(secretResult, additionalContext) : null\r\n                        };\r\n                        this.postMessage(req);\r\n                    } else {\r\n                        reject(new Error(opts.secretError));\r\n                    }\r\n                } catch (e) {\r\n                    reject(e);\r\n                }\r\n            } else {\r\n                reject(new Error('WorkerClient: the WorkerClient.connect() method must be called before a worker can be accessed'));\r\n            }\r\n        });\r\n        return <any>promise;\r\n    }\r\n\r\n    /**\r\n     * A wrapper function around the `Worker.postMessage()` method to catch any serialization errors should they occur\r\n     * @param request the request to be sent to the worker\r\n     */\r\n    private postMessage<EventType extends number>(\r\n        request: WorkerRequestEvent<EventType>\r\n    ) {\r\n        try {\r\n            this.workerRef.postMessage(request);\r\n        } catch (e) {\r\n            throw new Error('Unable to serialize the request from the client to the worker');\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * A utility function to cast promises\r\n     * @param promise promise to cast\r\n     */\r\n    private castPromise<PromiseType>(\r\n        promise: Promise<any>\r\n    ): Promise<PromiseType> {\r\n        return <Promise<PromiseType>>promise;\r\n    }\r\n\r\n    /**\r\n     * Creates client subscription reference with a subscription and an RxJS subject, adds it to the `observables` dictionary with unique key and then returns the key. Called from the `subscribe()` method.\r\n     * @param propertyName the property name of the worker's RxJS subject that was subscribed to\r\n     * @param next Callback function that is triggered when the subject's `next()` method is called\r\n     * @param error Callback function that is triggered when the subject throws and error\r\n     * @param complete Callback function that is triggered when the subject's `complete()` method is called\r\n     */\r\n    private createSubscription(\r\n        propertyName: string,\r\n        next?: (value: any) => void,\r\n        error?: (error: any) => void,\r\n        complete?: () => void\r\n    ): string {\r\n        const key = this.generateSubscriptionKey(propertyName);\r\n        const subject = new Subject<any>();\r\n        const subscription = subject.subscribe(next, error, complete);\r\n        this.observables[key] = { subject: subject, subscription: subscription, propertyName: propertyName, observable: null };\r\n        return key;\r\n    }\r\n\r\n    /**\r\n     * Creates client observable reference with a RxJS observable and subject, adds it to the `observables` dictionary with unique key and then returns the key. Called from the `observe()` method.\r\n     * @param propertyName the property name of the worker's RxJS subject that was subscribed to\r\n     */\r\n    private createObservable(\r\n        propertyName: string,\r\n    ): string {\r\n        const key = this.generateSubscriptionKey(propertyName);\r\n        const subject = new Subject<any>();\r\n        this.observables[key] = { subject: subject, subscription: null, propertyName: propertyName, observable: subject.asObservable() };\r\n        return key;\r\n    }\r\n\r\n    /**\r\n     * Iterates through the `observables` dictionary to find the associated key for a particular subscription or observable. Returns null if no match is found\r\n     * @param value Subscription or observable for which the dictionary key must be found\r\n     */\r\n    private findObservableKey(\r\n        value: Subscription | Observable<any>\r\n    ): string {\r\n        for (const key in this.observables) {\r\n            if (value instanceof Subscription) {\r\n                if (this.observables[key].subscription === value) {\r\n                    return key;\r\n                }\r\n            } else {\r\n                if (this.observables[key].observable === value) {\r\n                    return key;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Remove a subscription or observable reference from `observables` dictionary. Removed subscriptions are unsubsribed before destroyed\r\n     * @param subscriptionKey unique key in the `observables` dictionary\r\n     */\r\n    private removeSubscription(\r\n        subscriptionKey: string\r\n    ) {\r\n        if (this.observables[subscriptionKey]) {\r\n            if (this.observables[subscriptionKey].subscription) {\r\n                this.observables[subscriptionKey].subscription.unsubscribe();\r\n            }\r\n        }\r\n        delete this.observables[subscriptionKey];\r\n    }\r\n\r\n    /**\r\n     * Generates a random key\r\n     * @param propertyName appended as the prefix to the key\r\n     * @param length length of the randomly generated characters\r\n     */\r\n    private generateKey(\r\n        propertyName: string,\r\n        length: number\r\n    ) {\r\n        return `${propertyName.toUpperCase()}_${Array(length).fill(null).map(() => (Math.round(Math.random() * 16)).toString(16)).join('')}`;\r\n    }\r\n\r\n    /**\r\n     * Creates a unique key for a subscription/observable reference for use in the `observables` dictionary. This key allows messages from the worker to be correctly mapped and handled in the client\r\n     * @param propertyName property name of the worker's RxJS subject which is subscribed to. This is attached as a prefix to the unique key\r\n     */\r\n    private generateSubscriptionKey(\r\n        propertyName: string\r\n    ): string {\r\n        let key = this.generateKey(propertyName, 6);\r\n        while (this.observables[key]) {\r\n            key = this.generateKey(propertyName, 6);\r\n        }\r\n        return key;\r\n    }\r\n\r\n    /**\r\n     * Creates a unique key for worker requests ensuring no two keys are avaliable at any time through the `secrets` array. Allows requests to be mapped to responses from\r\n     * the worker\r\n     * @param propertyName property name of the worker's property/method that is being called. This is attached as a prefix to the unique key\r\n     */\r\n    private generateSecretKey(\r\n        propertyName?: string\r\n    ): string {\r\n        propertyName = propertyName ? propertyName : 'client';\r\n        let key = this.generateKey(propertyName, 16);\r\n        while (this.secrets.indexOf(key) !== -1) {\r\n            key = this.generateKey(propertyName, 16);\r\n        }\r\n        this.secrets.push(key);\r\n        return key;\r\n    }\r\n\r\n    /**\r\n     * Removes a key from the `secrets` array if it exists\r\n     * @param secret unqiue key to be removed\r\n     */\r\n    private removeSecretKey(\r\n        secret: string\r\n    ) {\r\n        if (this.secrets.indexOf(secret) !== -1) {\r\n            this.secrets.splice(this.secrets.indexOf(secret), 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if a valid `SecretResult` is returned when a decorated property and/or method of the client instance of the worker class is called.\r\n     *  Returns the secret when valid otherwise returns null\r\n     * @param secretResult the returned value from calling the property or method of a client instance of a worker\r\n     * @param type the worker event type that originated the request\r\n     */\r\n    private isSecret<SecretType extends number>(\r\n        secretResult: any,\r\n        type: SecretType\r\n    ): SecretResult<SecretType> {\r\n        if (secretResult) {\r\n            if (secretResult['clientSecret'] && secretResult['propertyName'] && secretResult['type']) {\r\n                if (secretResult['clientSecret'] === this.workerSecret && secretResult['type'] === type) {\r\n                    return <SecretResult<SecretType>>secretResult;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Creates the event listeners to listen for, and handle, messages recieved through `Worker.onmessage`\r\n     */\r\n    private registerEvents() {\r\n\r\n        this.responseEvent = new Subject<WorkerResponseEvent<WorkerEvents.Callable>>();\r\n        this.observables = {};\r\n\r\n        this.workerRef.onmessage = (ev: WorkerEvent<WorkerResponseEvent<any>>) => {\r\n            switch (ev.data.type) {\r\n                case WorkerEvents.ObservableMessage:\r\n                    const body: WorkerObservableMessage = ev.data.result;\r\n                    if (this.observables[body.key]) {\r\n                        switch (body.type) {\r\n                            case WorkerObservableMessageTypes.Next:\r\n                                this.observables[body.key].subject.next(body.value);\r\n                                break;\r\n                            case WorkerObservableMessageTypes.Error:\r\n                                this.observables[body.key].subject.error(body.error);\r\n                                break;\r\n                            case WorkerObservableMessageTypes.Complete:\r\n                                this.observables[body.key].subject.complete();\r\n                        }\r\n                    }\r\n                    break;\r\n                default:\r\n                    this.responseEvent.next(ev.data);\r\n            }\r\n        };\r\n\r\n\r\n    }\r\n\r\n\r\n}\r\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","\r\nimport { WorkerClient } from './worker-client';\r\nimport { WorkerDefinition } from './worker.module';\r\nimport { WebWorkerType } from 'angular-web-worker/common';\r\n\r\n/**\r\n * Injectable angular service with a primary responsability of acting as `WorkerClient` factory through its `createClient()` method.\r\n *\r\n * **Module**\r\n *\r\n * The `WorkerModule` must be imported to provide the service, passing in worker defintions in the `WorkerModule.forWorkers()` function so that the factory method\r\n * has neccessary details to create new clients\r\n *\r\n * @example\r\n * // module ---\r\n * imports: [\r\n *  WorkerModule.forWorkers([\r\n *    {worker: AppWorker, initFn: () => new Worker('./app.worker.ts', {type: 'module'})},\r\n *  ])\r\n * ]\r\n *\r\n * // usage ---\r\n * export class AppComponent implements OnInit {\r\n *\r\n *   constructor(private workerManager: WorkerManager) {}\r\n *\r\n *   ngOnInit() {\r\n *      const client: WorkerClient<AppWorker> = this.workerManager.createClient(AppWorker);\r\n *   }\r\n *\r\n * }\r\n */\r\nexport class WorkerManager {\r\n\r\n    /**\r\n     * List of workers with details to created new worker instances. Passed into `WorkerModule.forWorkers()`\r\n     */\r\n    private workerDefinitions: WorkerDefinition[];\r\n\r\n    /**\r\n     * Creates a new `WorkerManager` and called from `WorkerModule.forWorkers()` where the angular provider is created\r\n     * @param workerDefintions List of workers with details to create new worker instances. Passed into `WorkerModule.forWorkers()`\r\n     */\r\n    constructor(workerDefintions: WorkerDefinition[]) {\r\n        this.workerDefinitions = workerDefintions ? workerDefintions : [];\r\n    }\r\n\r\n    /**\r\n     * Factory function that creates a new `WorkerClient`. The worker definitions must first be registered when importing the `WorkerModule.forWorkers()` module, otherwise\r\n     * it will throw an error\r\n     * @param workerType the worker class\r\n     * @param runInApp whether the execution of the worker code is run in the application's \"thread\". Defaults to run in the worker script\r\n     * @example\r\n     * // module ---\r\n     * imports: [\r\n     *  WorkerModule.forWorkers([\r\n     *    {worker: AppWorker, initFn: () => new Worker('./app.worker.ts', {type: 'module'})},\r\n     *  ])\r\n     * ]\r\n     *\r\n     * // usage ---\r\n     * export class AppComponent implements OnInit {\r\n     *\r\n     *   constructor(private workerManager: WorkerManager) {}\r\n     *\r\n     *   ngOnInit() {\r\n     *      let client: WorkerClient<AppWorker> ;\r\n     *      if(workerManager.isBrowserCompatible) {\r\n     *          client = this.workerManager.createClient(AppWorker);\r\n     *      } else {\r\n     *          // only if worker execution does not have UI blocking code else implement other behaviour\r\n     *          client = this.workerManager.createClient(AppWorker, true);\r\n     *      }\r\n     *   }\r\n     *\r\n     * }\r\n     */\r\n    createClient<T>(workerType: WebWorkerType<T>, runInApp: boolean = false): WorkerClient<T> {\r\n        const definition = this.workerDefinitions.filter(p => p.worker === workerType)[0];\r\n        if (definition) {\r\n            return new WorkerClient<T>(definition, runInApp);\r\n        } else {\r\n            throw new Error('WorkerManager: all web workers must be registered in the forWorkers function of the WorkerModule');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Whether the browser supports web workers\r\n     */\r\n    get isBrowserCompatible(): boolean {\r\n        return typeof Worker !== 'undefined';\r\n    }\r\n\r\n\r\n\r\n}\r\n","\r\nimport { WorkerManager } from './worker-manager';\r\nimport { ModuleWithProviders, NgModule } from '@angular/core';\r\nimport { WorkerUtils, WebWorkerType, WorkerAnnotations } from 'angular-web-worker/common';\r\n\r\n/**\r\n * Provides the `WorkerManager` service with the worker definitions passed into the static `forWorkers` method.\r\n * @example\r\n * imports: [\r\n *  WorkerModule.forWorkers([\r\n *    {worker: AppWorker, initFn: () => new Worker('./app.worker.ts', {type: 'module'})},\r\n *  ])\r\n * ]\r\n */\r\n@NgModule()\r\nexport class WorkerModule {\r\n\r\n    /**\r\n     * Returns a module with a `WorkerManager` provider\r\n     * @param workerDefinitions list of worker defintions which contain the worker class and an `initFn` function which is necessary for the\r\n     * webpack `worker-plugin` to bundle the worker seperately.\r\n     * @example\r\n     * imports: [\r\n     *  WorkerModule.forWorkers([\r\n     *    {worker: AppWorker, initFn: () => new Worker('./app.worker.ts', {type: 'module'})},\r\n     *  ])\r\n     * ]\r\n    */\r\n    static forWorkers(workerDefinitions: WorkerDefinition[]): ModuleWithProviders<any> {\r\n\r\n        workerDefinitions.forEach((definition) => {\r\n            if (!WorkerUtils.getAnnotation(definition.worker, WorkerAnnotations.IsWorker)) {\r\n                throw new Error('WorkerModule: one or more of the provided workers has not been decorated with the @AngularWebWorker decorator');\r\n            }\r\n        });\r\n\r\n        return {\r\n            ngModule: WorkerModule,\r\n            providers: [\r\n                { provide: WorkerManager, useValue: new WorkerManager(workerDefinitions) }\r\n            ]\r\n        };\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * A definition of a worker that is required to create new worker instances\r\n */\r\nexport interface WorkerDefinition {\r\n    /**\r\n     * the worker class which has been decorated with `@AngularWebWorker()`\r\n     */\r\n    worker: WebWorkerType<any>;\r\n    /**\r\n     * A function that creates a worker. This is required for the webpack `worker-plugin` to bundle the worker seperately and is used by a `WorkerClient`\r\n     * to create a new worker\r\n     *\r\n     * **IMPORTANT**\r\n     *\r\n     * The syntax is crucial for the webpack plugin. The path must be a string and the {type: 'module'} argument must be given\r\n     * @example\r\n     * () => new Worker('./app.worker.ts', {type: 'module'})\r\n     */\r\n    initFn: () => Worker;\r\n}\r\n"]}