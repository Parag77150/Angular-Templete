(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('angular-web-worker/common'), require('reflect-metadata')) :
    typeof define === 'function' && define.amd ? define('angular-web-worker', ['exports', 'angular-web-worker/common', 'reflect-metadata'], factory) :
    (global = global || self, factory(global['angular-web-worker'] = {}, global['angular-web-worker'].common));
}(this, function (exports, common) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    var ɵ0 = function (instance, config) {
        Object.defineProperty(instance, common.WorkerAnnotations.Config, {
            get: function () {
                return config;
            },
            enumerable: true,
            configurable: true
        });
    }, ɵ1 = function (instance) {
        var accessables = common.WorkerUtils.getAnnotation(instance.__proto__.constructor, common.WorkerAnnotations.Accessables, []);
        if (accessables) {
            accessables.forEach(function (item) {
                var _val = instance[item.name];
                var getter = function () {
                    var config = this.__worker_config__;
                    if (config) {
                        if (config.isClient) {
                            var secret = {
                                clientSecret: config.clientSecret,
                                type: common.WorkerEvents.Accessable,
                                propertyName: item.name,
                                body: {
                                    get: item.get,
                                    set: item.set
                                }
                            };
                            return secret;
                        }
                        else {
                            return _val;
                        }
                    }
                    else {
                        return _val;
                    }
                };
                var setter = function (newVal) {
                    _val = newVal;
                };
                delete instance[item.name];
                Object.defineProperty(instance, item.name, {
                    get: getter,
                    set: setter,
                    enumerable: true,
                    configurable: true
                });
            });
        }
    }, ɵ2 = function (instance) {
        var observables = common.WorkerUtils.getAnnotation(instance.__proto__.constructor, common.WorkerAnnotations.Observables, []);
        if (observables) {
            observables.forEach(function (item) {
                var _val = instance[item.name];
                var getter = function () {
                    var config = this.__worker_config__;
                    if (config) {
                        if (config.isClient) {
                            var secret = {
                                clientSecret: config.clientSecret,
                                type: common.WorkerEvents.Observable,
                                propertyName: item.name,
                                body: null
                            };
                            return secret;
                        }
                        else {
                            return _val;
                        }
                    }
                    else {
                        return _val;
                    }
                };
                var setter = function (newVal) {
                    _val = newVal;
                };
                delete instance[item.name];
                Object.defineProperty(instance, item.name, {
                    get: getter,
                    set: setter,
                    enumerable: true,
                    configurable: true
                });
            });
        }
    };
    var WorkerFactoryFunctions = {
        /*
         * Attaches a worker configuration to an instance of a worker class
         * @param instance instance of the worker class
         * @param config configuration
         */
        setWorkerConfig: ɵ0,
        configureAccessables: ɵ1,
        configureSubscribables: ɵ2
    };
    /**
     * Class decorator allowing the class to be bootstrapped into a web worker script, and allowing communication with a `WorkerClient`
     */
    function AngularWebWorker() {
        return function (target) {
            common.WorkerUtils.setAnnotation(target, common.WorkerAnnotations.IsWorker, true);
            common.WorkerUtils.setAnnotation(target, common.WorkerAnnotations.Factory, function create(config) {
                var instance = new target();
                WorkerFactoryFunctions.setWorkerConfig(instance, config);
                WorkerFactoryFunctions.configureAccessables(instance);
                WorkerFactoryFunctions.configureSubscribables(instance);
                return instance;
            });
        };
    }

    /**
     * Handles communication to and from a `WorkerClient` and triggers work with the worker class.
     */
    var WorkerController = /** @class */ (function () {
        /**
         * Creates a new `WorkerController`
         * @param workerClass the worker class,
         * @param postMessageFn the worker postMessage function passed into constuctor allowing this to be mocked when running within the app (not the worker script)
         * @param onMessageFn the worker onmessage event function passed into constructor allowing this to be mocked when running within the app (not the worker script)
         */
        function WorkerController(workerClass, messageBus) {
            this.workerClass = workerClass;
            this.messageBus = messageBus;
            try {
                this.worker = common.WorkerUtils.getAnnotation(workerClass, common.WorkerAnnotations.Factory)({
                    isClient: false
                });
                this.subscriptions = {};
                this.registerEvents();
            }
            catch (e) { }
        }
        Object.defineProperty(WorkerController.prototype, "workerInstance", {
            /**
             * Returns instance of worker class
             */
            get: function () {
                return this.worker;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates the event listeners to correctly handle and respond to messages recieved from a `WorkerClient`
         */
        WorkerController.prototype.registerEvents = function () {
            var _this = this;
            this.messageBus.onmessage = function (ev) {
                switch (ev.data.type) {
                    case common.WorkerEvents.Callable:
                        _this.handleCallable(ev.data);
                        break;
                    case common.WorkerEvents.Accessable:
                        _this.handleAccessable(ev.data);
                        break;
                    case common.WorkerEvents.Observable:
                        _this.handleSubscription(ev.data);
                        break;
                    case common.WorkerEvents.Init:
                        _this.handleInit(ev.data);
                        break;
                }
            };
        };
        /**
         * A utility function to create a new `WorkerResponseEvent` from the details provided by the `WorkerRequestEvent`, as well as the result to be returned
         * @param type The type of worker event
         * @param request The request that the response relates to
         * @param result data to return with the response
         */
        WorkerController.prototype.response = function (type, request, result) {
            return {
                type: type,
                isError: false,
                requestSecret: request.requestSecret,
                propertyName: request.propertyName,
                result: result
            };
        };
        /**
         * A utility function to create a new error in the form of a `WorkerResponseEvent` from the details provided by the `WorkerRequestEvent`, as well as the error to be returned
         * @param type The type of worker event
         * @param request The request that the error relates to
         * @param result the error to be returned
         */
        WorkerController.prototype.error = function (type, request, error) {
            return {
                type: type,
                isError: true,
                requestSecret: request.requestSecret,
                propertyName: request.propertyName,
                error: JSON.stringify(error, this.replaceErrors),
                result: null
            };
        };
        /**
         * A utility function as the replacer for the `JSON.stringify()` function to make the native browser `Error` class serializable to JSON
         */
        WorkerController.prototype.replaceErrors = function (key, value) {
            if (value instanceof Error) {
                var error_1 = {};
                // tslint:disable-next-line: no-shadowed-variable
                Object.getOwnPropertyNames(value).forEach(function (key) {
                    error_1[key] = value[key];
                });
                return error_1;
            }
            return value;
        };
        /**
         * Handles `WorkerEvents.Init` requests from a client by calling the `onWorkerInit` hook if implemented and only responding once the hook has been completed, regardless of whether it is
         * async or not
         * @param request request recieved from the `WorkerClient`
         */
        WorkerController.prototype.handleInit = function (request) {
            return __awaiter(this, void 0, void 0, function () {
                var result, isPromise;
                var _this = this;
                return __generator(this, function (_a) {
                    if (this.worker['onWorkerInit']) {
                        try {
                            result = this.worker['onWorkerInit']();
                            isPromise = false;
                            if (result) {
                                isPromise = result.__proto__.constructor === Promise;
                            }
                            if (isPromise) {
                                result.then(function () {
                                    _this.postMessage(_this.response(common.WorkerEvents.Init, request, null));
                                }).catch(function (err) {
                                    _this.postMessage(_this.error(common.WorkerEvents.Init, request, err));
                                });
                            }
                            else {
                                this.postMessage(this.response(common.WorkerEvents.Init, request, null));
                            }
                        }
                        catch (e) {
                            this.postMessage(this.error(common.WorkerEvents.Init, request, null));
                        }
                    }
                    else {
                        this.postMessage(this.response(common.WorkerEvents.Init, request, null));
                    }
                    return [2 /*return*/];
                });
            });
        };
        /**
         * Handles `WorkerEvents.Callable` requests from a client by calling the targeted method and responding with the method's return value
         * @param request request recieved from the `WorkerClient`
         */
        WorkerController.prototype.handleCallable = function (request) {
            return __awaiter(this, void 0, void 0, function () {
                var _a, response, result, e_1;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _b.trys.push([0, 2, 3, 4]);
                            request.body.arguments = this.applyShallowTransferToCallableArgs(request, request.body.arguments);
                            return [4 /*yield*/, (_a = this.worker)[request.propertyName].apply(_a, __spread(request.body.arguments))];
                        case 1:
                            result = _b.sent();
                            response = this.response(common.WorkerEvents.Callable, request, result);
                            return [3 /*break*/, 4];
                        case 2:
                            e_1 = _b.sent();
                            response = this.error(common.WorkerEvents.Callable, request, e_1);
                            return [3 /*break*/, 4];
                        case 3:
                            this.postMessage(response);
                            return [7 /*endfinally*/];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Transfers the prototype of any function arguments decorated with `@ShallowTransfer()` which have been serialized and recieved from a `WorkerEvents.Callable` request.
         *  This occurs before the arguments are used to call the worker function.
         * @param request request recieved from the `WorkerClient`
         * @param args array of function arguments
         */
        WorkerController.prototype.applyShallowTransferToCallableArgs = function (request, args) {
            var metaData = common.WorkerUtils.getAnnotation(this.workerClass, common.WorkerAnnotations.ShallowTransferArgs, []);
            if (metaData) {
                var shallowTransferMeta = metaData.filter(function (x) { return x.name === request.propertyName; });
                var _loop_1 = function (i) {
                    var meta = shallowTransferMeta.filter(function (x) { return x.argIndex === i; })[0];
                    if (meta) {
                        if (meta.type && args[i]) {
                            args[i].__proto__ = meta.type.prototype;
                        }
                    }
                };
                for (var i = 0; i < args.length; i++) {
                    _loop_1(i);
                }
            }
            return args;
        };
        /**
         * Handles `WorkerEvents.Accessable` requests from a client by either setting the target property of the worker or responding with the target property's value
         * @param request request recieved from the `WorkerClient`
         */
        WorkerController.prototype.handleAccessable = function (request) {
            var response;
            try {
                var metaData = common.WorkerUtils.getAnnotation(this.workerClass, 'accessables', []).filter(function (x) { return x.name === request.propertyName; })[0];
                if (request.body.isGet) {
                    response = this.response(common.WorkerEvents.Accessable, request, this.worker[request.propertyName]);
                }
                else {
                    this.worker[request.propertyName] = request.body.value;
                    if (metaData.shallowTransfer) {
                        if (metaData.type && this.worker[request.propertyName]) {
                            this.worker[request.propertyName].__proto__ = metaData.type.prototype;
                        }
                    }
                    response = this.response(common.WorkerEvents.Accessable, request, null);
                }
            }
            catch (e) {
                response = this.error(common.WorkerEvents.Accessable, request, e);
            }
            finally {
                this.postMessage(response);
            }
        };
        /**
         * Handles `WorkerEvents.Subscribable` requests from a client by creating a new subscription to the targeted observable which will send messages to the client each time
         * an event is triggered by the observable. The function may also unsubscribe from a subscription depending on the details of the request
         * @param request request recieved from the `WorkerClient`
         */
        WorkerController.prototype.handleSubscription = function (request) {
            var response;
            if (!request.body.isUnsubscribe) {
                try {
                    this.createSubscription(request);
                    response = this.response(common.WorkerEvents.Observable, request, request.body.subscriptionKey);
                }
                catch (e) {
                    this.removeSubscription(request.body.subscriptionKey);
                    response = this.error(common.WorkerEvents.Observable, request, e);
                }
                finally {
                    this.postMessage(response);
                }
            }
            else {
                try {
                    this.removeSubscription(request.body.subscriptionKey);
                    response = this.response(common.WorkerEvents.Observable, request, null);
                }
                catch (e) {
                    response = this.error(common.WorkerEvents.Observable, request, e);
                }
                finally {
                    this.postMessage(response);
                }
            }
        };
        /**
         * Creates a new subscription to a worker observable and adds it to the `subscriptions` dictionary. The subscriptions will send messages to the client each time
         *  and event is triggered by the observable
         * @param request request recieved from the `WorkerClient`
         */
        WorkerController.prototype.createSubscription = function (request) {
            var _this = this;
            this.removeSubscription(request.body.subscriptionKey);
            this.subscriptions[request.body.subscriptionKey] = this.worker[request.propertyName].subscribe(function (val) {
                var response = {
                    type: common.WorkerEvents.ObservableMessage,
                    propertyName: request.propertyName,
                    isError: false,
                    requestSecret: null,
                    result: {
                        key: request.body.subscriptionKey,
                        type: common.WorkerObservableMessageTypes.Next,
                        value: val
                    }
                };
                _this.postSubscriptionMessage(response);
            }, function (err) {
                var response = {
                    type: common.WorkerEvents.ObservableMessage,
                    propertyName: request.propertyName,
                    isError: true,
                    requestSecret: null,
                    result: {
                        key: request.body.subscriptionKey,
                        type: common.WorkerObservableMessageTypes.Error,
                        error: JSON.parse(JSON.stringify(err, _this.replaceErrors))
                    }
                };
                _this.postSubscriptionMessage(response);
            }, function () {
                var response = {
                    type: common.WorkerEvents.ObservableMessage,
                    propertyName: request.propertyName,
                    isError: false,
                    requestSecret: null,
                    result: {
                        key: request.body.subscriptionKey,
                        type: common.WorkerObservableMessageTypes.Complete,
                    }
                };
                _this.postSubscriptionMessage(response);
            });
        };
        /**
         * Removes a subscription from the `subscriptions` dictionary, unsubscribing before it is deleted
         * @param subscriptionKey key in dictionary
         */
        WorkerController.prototype.removeSubscription = function (subscriptionKey) {
            if (this.subscriptions[subscriptionKey]) {
                this.subscriptions[subscriptionKey].unsubscribe();
            }
            delete this.subscriptions[subscriptionKey];
        };
        /**
         * Unsubscribes from all subscriptions
         */
        WorkerController.prototype.removeAllSubscriptions = function () {
            for (var key in this.subscriptions) {
                if (this.subscriptions[key]) {
                    this.subscriptions[key].unsubscribe();
                    delete this.subscriptions[key];
                }
            }
        };
        /**
         * A wrapper function around the `postMessage()` method allowing serialization errors to be caught and sent to the client as a `WorkerResponseEvent`.
         * Only used when the response is triggered by a request, which is not the case when the event type is `WorkerEvents.ObservableMessage`.
         * @param response reponse to send to the client
         */
        WorkerController.prototype.postMessage = function (response) {
            try {
                this.messageBus.postMessage(response);
            }
            catch (e) {
                var errorResponse = {
                    type: response.type,
                    isError: true,
                    requestSecret: response.requestSecret,
                    propertyName: response.propertyName,
                    error: JSON.parse(JSON.stringify(new Error('Unable to serialize response from worker to client'), this.replaceErrors)),
                    result: null
                };
                this.messageBus.postMessage(errorResponse);
            }
        };
        /**
         * A wrapper function around the `postMessage()` method allowing serialization errors to be caught and sent to the client as a `WorkerResponseEvent`.
         * Only used when the response type is `WorkerEvents.ObservableMessage` which requires a different implementation to the `WorkerController.postMessage` wrapper as it
         * is one-way communication which is not triggered by a request
         */
        WorkerController.prototype.postSubscriptionMessage = function (response) {
            try {
                this.messageBus.postMessage(response);
            }
            catch (e) {
                var errorResponse = {
                    type: response.type,
                    isError: true,
                    requestSecret: response.requestSecret,
                    propertyName: response.propertyName,
                    result: {
                        key: response.result.key,
                        type: common.WorkerObservableMessageTypes.Error,
                        error: JSON.parse(JSON.stringify(new Error('Unable to serialize subscribable response from worker to client'), this.replaceErrors))
                    },
                };
                this.messageBus.postMessage(errorResponse);
            }
        };
        return WorkerController;
    }());

    /**
     * Bootstraps the worker class when a new worker script is created in the browser. The class must be decorated with `@AngularWebWorker()`
     * @param worker worker class to bootstrap
     */
    function bootstrapWorker(worker) {
        var messageBus = {
            onmessage: function (ev) {
            },
            postMessage: function (msg) {
                postMessage(msg);
            }
        };
        var workerController = new WorkerController(worker, messageBus);
        onmessage = function (ev) {
            messageBus.onmessage(ev);
        };
    }

    /**
     * Allows the decorated worker method to be called, and its value returned, from the `WorkerClient.call()` method.
     * Can be used on both asynchronous and synchronous methods.
     * @Serialized Functions will not be copied and circular referencing structures will cause errors. This applies to both the function arguments and the value returned by the function
     * @param options Configurable options defining how the decorated method is called from a `WorkerClient`
     */
    function Callable(options) {
        return function (target, propertyKey, descriptor) {
            var opts = { shallowTransfer: false };
            if (options) {
                opts.shallowTransfer = options.shallowTransfer ? true : false;
            }
            common.WorkerUtils.pushAnnotation(target.constructor, common.WorkerAnnotations.Callables, {
                name: propertyKey,
                shallowTransfer: opts.shallowTransfer,
                returnType: Reflect.getMetadata('design:returntype', target, propertyKey)
            });
            var originalMethod = descriptor.value;
            descriptor.value = function () {
                var context = this;
                var args = Array.prototype.slice.call(arguments);
                var config = context.__worker_config__;
                if (config) {
                    if (config.isClient) {
                        var secret = {
                            clientSecret: context.__worker_config__.clientSecret,
                            type: common.WorkerEvents.Callable,
                            propertyName: propertyKey,
                            body: {
                                args: args
                            }
                        };
                        return secret;
                    }
                    else {
                        return originalMethod.call.apply(originalMethod, __spread([context], args));
                    }
                }
                else {
                    return originalMethod.call.apply(originalMethod, __spread([context], args));
                }
            };
            return descriptor;
        };
    }

    /**
     * Allows the decorated worker property to be accessed from the `WorkerClient.get()` and `WorkerClient.set()` methods
     * @Serialized Functions will not be copied and circular referencing structures will cause errors
     * @param options configurable options defining how the decorated property can be interacted with from a `WorkerClient`
     */
    function Accessable(options) {
        var opts = { get: true, set: true, shallowTransfer: false };
        if (options) {
            opts.get = options.get === false ? false : true;
            opts.set = options.set === false ? false : true;
            opts.shallowTransfer = options.shallowTransfer ? true : false;
        }
        return function (target, propertyKey) {
            common.WorkerUtils.pushAnnotation(target.constructor, common.WorkerAnnotations.Accessables, {
                name: propertyKey,
                type: Reflect.getMetadata('design:type', target, propertyKey),
                get: opts.get,
                set: opts.set,
                shallowTransfer: opts.shallowTransfer
            });
        };
    }

    /**
     * Allows the decorated worker property to be subscribed to, or observed through the `WorkerClient.subscribe()` and `WorkerClient.observe()` methods.
     *
     * Can only be used on multicasted RxJS observables being a `Subject`,  `BehaviorSubject`, `ReplaySubject` or `AsyncSubject`.
     * @Serialized When data is transferred through `Subject.next()`, functions will not be copied and circular referencing structures will cause errors
     */
    function Subscribable() {
        return function (target, propertyKey) {
            common.WorkerUtils.pushAnnotation(target.constructor, common.WorkerAnnotations.Observables, {
                name: propertyKey,
                type: Reflect.getMetadata('design:type', target, propertyKey)
            });
        };
    }

    /**
     * Transfers the decorated argument's prototype when it is serialized and unserialized when the method is called from `WorkerClient.call()`. This will only have an effect if
     * the method is decorated with `@Callable()`
     * @Experimental has limitations
     */
    function ShallowTransfer() {
        return function (target, propertyKey, parameterIndex) {
            var argTypes = Reflect.getMetadata('design:paramtypes', target, propertyKey);
            common.WorkerUtils.pushAnnotation(target.constructor, common.WorkerAnnotations.ShallowTransferArgs, {
                name: propertyKey,
                type: argTypes[parameterIndex],
                argIndex: parameterIndex
            });
        };
    }

    exports.Accessable = Accessable;
    exports.AngularWebWorker = AngularWebWorker;
    exports.Callable = Callable;
    exports.ShallowTransfer = ShallowTransfer;
    exports.Subscribable = Subscribable;
    exports.WorkerController = WorkerController;
    exports.WorkerFactoryFunctions = WorkerFactoryFunctions;
    exports.bootstrapWorker = bootstrapWorker;
    exports.ɵ0 = ɵ0;
    exports.ɵ1 = ɵ1;
    exports.ɵ2 = ɵ2;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=angular-web-worker.umd.js.map
