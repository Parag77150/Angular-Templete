import { WorkerClient } from './worker-client';
/**
 * Injectable angular service with a primary responsability of acting as `WorkerClient` factory through its `createClient()` method.
 *
 * **Module**
 *
 * The `WorkerModule` must be imported to provide the service, passing in worker defintions in the `WorkerModule.forWorkers()` function so that the factory method
 * has neccessary details to create new clients
 *
 * @example
 * // module ---
 * imports: [
 *  WorkerModule.forWorkers([
 *    {worker: AppWorker, initFn: () => new Worker('./app.worker.ts', {type: 'module'})},
 *  ])
 * ]
 *
 * // usage ---
 * export class AppComponent implements OnInit {
 *
 *   constructor(private workerManager: WorkerManager) {}
 *
 *   ngOnInit() {
 *      const client: WorkerClient<AppWorker> = this.workerManager.createClient(AppWorker);
 *   }
 *
 * }
 */
var WorkerManager = /** @class */ (function () {
    /**
     * Creates a new `WorkerManager` and called from `WorkerModule.forWorkers()` where the angular provider is created
     * @param workerDefintions List of workers with details to create new worker instances. Passed into `WorkerModule.forWorkers()`
     */
    function WorkerManager(workerDefintions) {
        this.workerDefinitions = workerDefintions ? workerDefintions : [];
    }
    /**
     * Factory function that creates a new `WorkerClient`. The worker definitions must first be registered when importing the `WorkerModule.forWorkers()` module, otherwise
     * it will throw an error
     * @param workerType the worker class
     * @param runInApp whether the execution of the worker code is run in the application's "thread". Defaults to run in the worker script
     * @example
     * // module ---
     * imports: [
     *  WorkerModule.forWorkers([
     *    {worker: AppWorker, initFn: () => new Worker('./app.worker.ts', {type: 'module'})},
     *  ])
     * ]
     *
     * // usage ---
     * export class AppComponent implements OnInit {
     *
     *   constructor(private workerManager: WorkerManager) {}
     *
     *   ngOnInit() {
     *      let client: WorkerClient<AppWorker> ;
     *      if(workerManager.isBrowserCompatible) {
     *          client = this.workerManager.createClient(AppWorker);
     *      } else {
     *          // only if worker execution does not have UI blocking code else implement other behaviour
     *          client = this.workerManager.createClient(AppWorker, true);
     *      }
     *   }
     *
     * }
     */
    WorkerManager.prototype.createClient = function (workerType, runInApp) {
        if (runInApp === void 0) { runInApp = false; }
        var definition = this.workerDefinitions.filter(function (p) { return p.worker === workerType; })[0];
        if (definition) {
            return new WorkerClient(definition, runInApp);
        }
        else {
            throw new Error('WorkerManager: all web workers must be registered in the forWorkers function of the WorkerModule');
        }
    };
    Object.defineProperty(WorkerManager.prototype, "isBrowserCompatible", {
        /**
         * Whether the browser supports web workers
         */
        get: function () {
            return typeof Worker !== 'undefined';
        },
        enumerable: true,
        configurable: true
    });
    return WorkerManager;
}());
export { WorkerManager };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid29ya2VyLW1hbmFnZXIuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyLXdlYi13b3JrZXIvYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi93b3JrZXItbWFuYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFJL0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBMEJHO0FBQ0g7SUFPSTs7O09BR0c7SUFDSCx1QkFBWSxnQkFBb0M7UUFDNUMsSUFBSSxDQUFDLGlCQUFpQixHQUFHLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQ3RFLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0E2Qkc7SUFDSCxvQ0FBWSxHQUFaLFVBQWdCLFVBQTRCLEVBQUUsUUFBeUI7UUFBekIseUJBQUEsRUFBQSxnQkFBeUI7UUFDbkUsSUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxVQUFBLENBQUMsSUFBSSxPQUFBLENBQUMsQ0FBQyxNQUFNLEtBQUssVUFBVSxFQUF2QixDQUF1QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbEYsSUFBSSxVQUFVLEVBQUU7WUFDWixPQUFPLElBQUksWUFBWSxDQUFJLFVBQVUsRUFBRSxRQUFRLENBQUMsQ0FBQztTQUNwRDthQUFNO1lBQ0gsTUFBTSxJQUFJLEtBQUssQ0FBQyxrR0FBa0csQ0FBQyxDQUFDO1NBQ3ZIO0lBQ0wsQ0FBQztJQUtELHNCQUFJLDhDQUFtQjtRQUh2Qjs7V0FFRzthQUNIO1lBQ0ksT0FBTyxPQUFPLE1BQU0sS0FBSyxXQUFXLENBQUM7UUFDekMsQ0FBQzs7O09BQUE7SUFJTCxvQkFBQztBQUFELENBQUMsQUEvREQsSUErREMiLCJzb3VyY2VzQ29udGVudCI6WyJcclxuaW1wb3J0IHsgV29ya2VyQ2xpZW50IH0gZnJvbSAnLi93b3JrZXItY2xpZW50JztcclxuaW1wb3J0IHsgV29ya2VyRGVmaW5pdGlvbiB9IGZyb20gJy4vd29ya2VyLm1vZHVsZSc7XHJcbmltcG9ydCB7IFdlYldvcmtlclR5cGUgfSBmcm9tICdhbmd1bGFyLXdlYi13b3JrZXIvY29tbW9uJztcclxuXHJcbi8qKlxyXG4gKiBJbmplY3RhYmxlIGFuZ3VsYXIgc2VydmljZSB3aXRoIGEgcHJpbWFyeSByZXNwb25zYWJpbGl0eSBvZiBhY3RpbmcgYXMgYFdvcmtlckNsaWVudGAgZmFjdG9yeSB0aHJvdWdoIGl0cyBgY3JlYXRlQ2xpZW50KClgIG1ldGhvZC5cclxuICpcclxuICogKipNb2R1bGUqKlxyXG4gKlxyXG4gKiBUaGUgYFdvcmtlck1vZHVsZWAgbXVzdCBiZSBpbXBvcnRlZCB0byBwcm92aWRlIHRoZSBzZXJ2aWNlLCBwYXNzaW5nIGluIHdvcmtlciBkZWZpbnRpb25zIGluIHRoZSBgV29ya2VyTW9kdWxlLmZvcldvcmtlcnMoKWAgZnVuY3Rpb24gc28gdGhhdCB0aGUgZmFjdG9yeSBtZXRob2RcclxuICogaGFzIG5lY2Nlc3NhcnkgZGV0YWlscyB0byBjcmVhdGUgbmV3IGNsaWVudHNcclxuICpcclxuICogQGV4YW1wbGVcclxuICogLy8gbW9kdWxlIC0tLVxyXG4gKiBpbXBvcnRzOiBbXHJcbiAqICBXb3JrZXJNb2R1bGUuZm9yV29ya2VycyhbXHJcbiAqICAgIHt3b3JrZXI6IEFwcFdvcmtlciwgaW5pdEZuOiAoKSA9PiBuZXcgV29ya2VyKCcuL2FwcC53b3JrZXIudHMnLCB7dHlwZTogJ21vZHVsZSd9KX0sXHJcbiAqICBdKVxyXG4gKiBdXHJcbiAqXHJcbiAqIC8vIHVzYWdlIC0tLVxyXG4gKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcclxuICpcclxuICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIHdvcmtlck1hbmFnZXI6IFdvcmtlck1hbmFnZXIpIHt9XHJcbiAqXHJcbiAqICAgbmdPbkluaXQoKSB7XHJcbiAqICAgICAgY29uc3QgY2xpZW50OiBXb3JrZXJDbGllbnQ8QXBwV29ya2VyPiA9IHRoaXMud29ya2VyTWFuYWdlci5jcmVhdGVDbGllbnQoQXBwV29ya2VyKTtcclxuICogICB9XHJcbiAqXHJcbiAqIH1cclxuICovXHJcbmV4cG9ydCBjbGFzcyBXb3JrZXJNYW5hZ2VyIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExpc3Qgb2Ygd29ya2VycyB3aXRoIGRldGFpbHMgdG8gY3JlYXRlZCBuZXcgd29ya2VyIGluc3RhbmNlcy4gUGFzc2VkIGludG8gYFdvcmtlck1vZHVsZS5mb3JXb3JrZXJzKClgXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgd29ya2VyRGVmaW5pdGlvbnM6IFdvcmtlckRlZmluaXRpb25bXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgYFdvcmtlck1hbmFnZXJgIGFuZCBjYWxsZWQgZnJvbSBgV29ya2VyTW9kdWxlLmZvcldvcmtlcnMoKWAgd2hlcmUgdGhlIGFuZ3VsYXIgcHJvdmlkZXIgaXMgY3JlYXRlZFxyXG4gICAgICogQHBhcmFtIHdvcmtlckRlZmludGlvbnMgTGlzdCBvZiB3b3JrZXJzIHdpdGggZGV0YWlscyB0byBjcmVhdGUgbmV3IHdvcmtlciBpbnN0YW5jZXMuIFBhc3NlZCBpbnRvIGBXb3JrZXJNb2R1bGUuZm9yV29ya2VycygpYFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih3b3JrZXJEZWZpbnRpb25zOiBXb3JrZXJEZWZpbml0aW9uW10pIHtcclxuICAgICAgICB0aGlzLndvcmtlckRlZmluaXRpb25zID0gd29ya2VyRGVmaW50aW9ucyA/IHdvcmtlckRlZmludGlvbnMgOiBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZhY3RvcnkgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IGBXb3JrZXJDbGllbnRgLiBUaGUgd29ya2VyIGRlZmluaXRpb25zIG11c3QgZmlyc3QgYmUgcmVnaXN0ZXJlZCB3aGVuIGltcG9ydGluZyB0aGUgYFdvcmtlck1vZHVsZS5mb3JXb3JrZXJzKClgIG1vZHVsZSwgb3RoZXJ3aXNlXHJcbiAgICAgKiBpdCB3aWxsIHRocm93IGFuIGVycm9yXHJcbiAgICAgKiBAcGFyYW0gd29ya2VyVHlwZSB0aGUgd29ya2VyIGNsYXNzXHJcbiAgICAgKiBAcGFyYW0gcnVuSW5BcHAgd2hldGhlciB0aGUgZXhlY3V0aW9uIG9mIHRoZSB3b3JrZXIgY29kZSBpcyBydW4gaW4gdGhlIGFwcGxpY2F0aW9uJ3MgXCJ0aHJlYWRcIi4gRGVmYXVsdHMgdG8gcnVuIGluIHRoZSB3b3JrZXIgc2NyaXB0XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gbW9kdWxlIC0tLVxyXG4gICAgICogaW1wb3J0czogW1xyXG4gICAgICogIFdvcmtlck1vZHVsZS5mb3JXb3JrZXJzKFtcclxuICAgICAqICAgIHt3b3JrZXI6IEFwcFdvcmtlciwgaW5pdEZuOiAoKSA9PiBuZXcgV29ya2VyKCcuL2FwcC53b3JrZXIudHMnLCB7dHlwZTogJ21vZHVsZSd9KX0sXHJcbiAgICAgKiAgXSlcclxuICAgICAqIF1cclxuICAgICAqXHJcbiAgICAgKiAvLyB1c2FnZSAtLS1cclxuICAgICAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xyXG4gICAgICpcclxuICAgICAqICAgY29uc3RydWN0b3IocHJpdmF0ZSB3b3JrZXJNYW5hZ2VyOiBXb3JrZXJNYW5hZ2VyKSB7fVxyXG4gICAgICpcclxuICAgICAqICAgbmdPbkluaXQoKSB7XHJcbiAgICAgKiAgICAgIGxldCBjbGllbnQ6IFdvcmtlckNsaWVudDxBcHBXb3JrZXI+IDtcclxuICAgICAqICAgICAgaWYod29ya2VyTWFuYWdlci5pc0Jyb3dzZXJDb21wYXRpYmxlKSB7XHJcbiAgICAgKiAgICAgICAgICBjbGllbnQgPSB0aGlzLndvcmtlck1hbmFnZXIuY3JlYXRlQ2xpZW50KEFwcFdvcmtlcik7XHJcbiAgICAgKiAgICAgIH0gZWxzZSB7XHJcbiAgICAgKiAgICAgICAgICAvLyBvbmx5IGlmIHdvcmtlciBleGVjdXRpb24gZG9lcyBub3QgaGF2ZSBVSSBibG9ja2luZyBjb2RlIGVsc2UgaW1wbGVtZW50IG90aGVyIGJlaGF2aW91clxyXG4gICAgICogICAgICAgICAgY2xpZW50ID0gdGhpcy53b3JrZXJNYW5hZ2VyLmNyZWF0ZUNsaWVudChBcHBXb3JrZXIsIHRydWUpO1xyXG4gICAgICogICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqXHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZUNsaWVudDxUPih3b3JrZXJUeXBlOiBXZWJXb3JrZXJUeXBlPFQ+LCBydW5JbkFwcDogYm9vbGVhbiA9IGZhbHNlKTogV29ya2VyQ2xpZW50PFQ+IHtcclxuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gdGhpcy53b3JrZXJEZWZpbml0aW9ucy5maWx0ZXIocCA9PiBwLndvcmtlciA9PT0gd29ya2VyVHlwZSlbMF07XHJcbiAgICAgICAgaWYgKGRlZmluaXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JrZXJDbGllbnQ8VD4oZGVmaW5pdGlvbiwgcnVuSW5BcHApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya2VyTWFuYWdlcjogYWxsIHdlYiB3b3JrZXJzIG11c3QgYmUgcmVnaXN0ZXJlZCBpbiB0aGUgZm9yV29ya2VycyBmdW5jdGlvbiBvZiB0aGUgV29ya2VyTW9kdWxlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyB3ZWIgd29ya2Vyc1xyXG4gICAgICovXHJcbiAgICBnZXQgaXNCcm93c2VyQ29tcGF0aWJsZSgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIFdvcmtlciAhPT0gJ3VuZGVmaW5lZCc7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbn1cclxuIl19