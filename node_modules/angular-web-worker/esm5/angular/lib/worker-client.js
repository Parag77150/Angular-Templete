import * as tslib_1 from "tslib";
import { Subject, Subscription } from 'rxjs';
import { WorkerEvents, WorkerUtils, WorkerAnnotations, WorkerObservableMessageTypes } from 'angular-web-worker/common';
import { ClientWebWorker } from './client-web-worker';
/**
 * Provides functionality for an Angular app to access the properties, call the methods and subscribe to the events in a web worker by managing
 * the communication between the app and the worker. Also provides the option to execute the worker code within the app should the browser not support web workers,
 * although intensive work may then block the UI.
 */
var WorkerClient = /** @class */ (function () {
    /**
     * Creates a new `WorkerClient`
     * @param definition the worker defintion originating from the arguments of the `WorkerModule.forWorkers()` method
     * @param runInApp whether the execution of the worker will occur in the app or within the worker script
     * @param runInApp whether the client is used for unit testing which determines if serialization should be mocked
     */
    function WorkerClient(definition, runInApp, isTestClient) {
        if (runInApp === void 0) { runInApp = false; }
        if (isTestClient === void 0) { isTestClient = false; }
        this.definition = definition;
        this.runInApp = runInApp;
        this.isTestClient = isTestClient;
    }
    /**
     * Creates a new worker script in the browser, or within the app, and triggers the `OnWorkerInit` hook, if implemented. If the hook is implemented the promise will only be resolved once `onWorkerInit` method
     * has completed regardless of whether it is async or not
     *
     * This method must called before any worker methods and/or properties can be called/accessed
     */
    WorkerClient.prototype.connect = function () {
        var _this = this;
        if (!this._isConnected) {
            this.secrets = [];
            this.workerSecret = this.generateSecretKey();
            this.worker = WorkerUtils.getAnnotation(this.definition.worker, WorkerAnnotations.Factory)({
                isClient: true,
                clientSecret: this.workerSecret
            });
            if (!this.runInApp) {
                this.workerRef = this.definition.initFn();
            }
            else {
                this.workerRef = new ClientWebWorker(this.definition.worker, this.isTestClient);
            }
            this.registerEvents();
            return this.castPromise(this.sendRequest(WorkerEvents.Init, {
                body: function () { return null; },
                isConnect: true,
                resolve: function () {
                    _this._isConnected = true;
                    return undefined;
                },
                secretError: 'Could not initialise worker'
            }));
        }
    };
    /**
     * Terminates the worker and unsubscribes from any subscriptions created from the `subscribe()` method
     */
    WorkerClient.prototype.destroy = function () {
        if (this.isConnected) {
            for (var key in this.observables) {
                if (this.observables[key]) {
                    this.removeSubscription(key);
                }
            }
            this.workerRef.terminate();
            this.secrets = [];
            this.observables = {};
            this.worker = null;
            this._isConnected = false;
        }
    };
    Object.defineProperty(WorkerClient.prototype, "isConnected", {
        /**
         * Whether the worker is active after it is created with the `connect()` method and before it has been terminated by the `destroy()` method
         */
        get: function () {
            return this._isConnected;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the value of a worker property that has been decorated with `@Accessable()`. Undecorated properties will cause the promise to be rejected
     * @Serialized
     * @example
     * // async await syntax ---
     * const name: string = await client.get(w => w.name);
     *
     * // promise syntax ---
     * client.get(w => w.name).then((name) => {
     *   console.log(name);
     * }).catch((err) => {
     *   console.log(err);
     * });
     * @param property A lamda expression that returns the targeted property of the worker. The worker argument in the expression only has the properties owned by the worker class (no methods)
     * and only those properties that are not RxJS subjects
     */
    WorkerClient.prototype.get = function (property) {
        var _this = this;
        return this.sendRequest(WorkerEvents.Accessable, {
            workerProperty: property,
            additionalConditions: [{
                    if: function (secret) { return secret.body.get; },
                    reject: function (secret) { return new Error("WorkerClient: will not apply the get method to the \"" + secret.propertyName + "\" property because the get accessor has been explicity set to false"); }
                }],
            secretError: 'WorkerClient: only properties decorated with @Accessable() can be used in the get method',
            body: function () { return { isGet: true }; },
            resolve: function (resp) {
                var metaData = WorkerUtils.getAnnotation(_this.definition.worker, WorkerAnnotations.Accessables).filter(function (x) { return x.name === resp.propertyName; })[0];
                if (metaData.shallowTransfer) {
                    if (metaData.type) {
                        if (metaData.type.prototype && resp.result) {
                            resp.result.__proto__ = metaData.type.prototype;
                        }
                    }
                }
                return resp.result;
            }
        });
    };
    /**
     * Sets value of a worker property that has been decorated with `@Accessable()`. Undecorated properties will cause the promise to be rejected
     * @Serialized

     * @example
     * // async await syntax ---
     * await client.set(w => w.name, 'peter');
     *
     * // promise syntax ---
     * client.set(w => w.name, 'peter').then(() => {
     *   console.log('property has been set');
     * }).catch((err) => {
     *   console.log(err);
     * });
     * @param property A lamda expression that returns the targeted property of the worker. The worker argument in the expression only has the properties owned by the worker class (no methods)
     * and only those properties that are not RxJS subjects
     * @param value the value which the property should be set to
     */
    WorkerClient.prototype.set = function (property, value) {
        return this.castPromise(this.sendRequest(WorkerEvents.Accessable, {
            workerProperty: property,
            additionalConditions: [{
                    if: function (secret) { return secret.body.set; },
                    reject: function (secret) { return new Error("WorkerClient: will not apply the set method to the \"" + secret.propertyName + "\" property because the set accessor has been explicity set to false"); }
                }],
            secretError: 'WorkerClient: only properties decorated with @Accessable() can be used in the set method',
            body: function () { return { isGet: false, value: value }; }
        }));
    };
    /**
     * Calls a method in the worker and returns its value. The called method can be either synchronous or asynchronous
     * but must be decorated with `@Callable()` else the promise will be rejected
     * @Serialized Applies to both the function arguments and the returned value
     * @example
     * // async await syntax ---
     * const functionResult: SomeResultType = await client.call(w => w.doSomeWork('someArgument', 2123));
     *
     * // promise syntax ---
     * client.call(w => w.doSomeWork('someArgument', 2123)).then((result) => {
     *    console.log(result);
     * }).catch((err) => {
     *    console.log(err);
     * });
     * @param property A lamda expression that calls the worker method. The worker argument in the expression only has the methods owned by the worker class (not the properties)
     */
    WorkerClient.prototype.call = function (callFn) {
        var _this = this;
        return this.sendRequest(WorkerEvents.Callable, {
            workerProperty: callFn,
            secretError: 'WorkerClient: only methods decorated with @Callable() can be used in the call method',
            body: function (secret) { return { arguments: secret.body.args }; },
            resolve: function (resp) {
                var metaData = WorkerUtils.getAnnotation(_this.definition.worker, WorkerAnnotations.Callables, []).filter(function (x) { return x.name === resp.propertyName; })[0];
                if (metaData.shallowTransfer) {
                    if (metaData.returnType === Promise) {
                        throw new Error('WorkerClient: shallowTransfer will not be true in the @Callable() decorator when the decorated method returns a promise');
                    }
                    if (metaData.returnType && resp.result) {
                        resp.result.__proto__ = metaData.returnType.prototype;
                    }
                }
                return resp.result;
            }
        });
    };
    /**
     * Subscribes to a worker's RxJS subject, which has been decorated with `@Subscribable()`, and then returns this subscription.
     *  Supports all four RxJS subjects being `Subject`,  `BehaviorSubject`, `ReplaySubject` and `AsyncSubject`.
     *
     * **UNSUBSCRIBING**
     *
     * While the returned subscription can be destroyed with `Subscription.unsubscribe()` this is only destroys the client subscription. A subscription is also created in the worker.
     * To release the resources in both the client and the worker the `WorkerClient.unsubscribe(subscription)` method should be used. The `WorkerClient.destroy()` method will
     * dispose of all subscriptions correctly.
     *
     * @Serialized This applies to messages posted through `Subject.next()`
     * @example
     * // async await syntax ---
     * this.workerSubscription = await client.subscribe(w => w.someEventSubject);
     *
     * // promise syntax ---
     * client.subscribe(w => w.someEventSubject).then((subscription) => {
     *    this.workerSubscription = subscription;
     * }).catch((err) => {
     *    console.log(err);
     * });
     *
     * // unsubscribing --------
     * await client.unsubscribe(this.workerSubscription)
     * @param observable A lamda expression that returns the targeted RxJS subject of the worker. The worker argument in the expression only has the properties owned by the worker class (no methods)
     * and only those properties that are RxJS subjects
     * @param next Callback function that is triggered when the subject's `next()` method is called within the worker
     * @param error Callback function that is triggered when the subject throws and error
     * @param complete Callback function that is triggered when the subject's `complete()` method is called within the worker
     */
    WorkerClient.prototype.subscribe = function (observable, next, error, complete) {
        var _this = this;
        return this.castPromise(this.sendRequest(WorkerEvents.Observable, {
            workerProperty: observable,
            secretError: 'WorkerClient: only methods decorated with @Callable() can be used in the call method',
            beforeRequest: function (secret) { return _this.createSubscription(secret.propertyName, next, error, complete); },
            body: function (secret, key) { return { isUnsubscribe: false, subscriptionKey: key }; },
            resolve: function (resp, secret, key) { return _this.observables[key].subscription; },
            beforeReject: function (resp, secret, key) { return _this.removeSubscription(key); }
        }));
    };
    /**
     * Creates and returns a RxJS observable that is in sync with a RxJS subject within a worker. The worker subject must be decorated with `@Subscribable()` otherwise the
     * promise will be rejected. Supports all four RxJS subjects being, `Subject`,  `BehaviorSubject`, `ReplaySubject` and `AsyncSubject`.
     *
     * **UNSUBSCRIBING**
     *
     * While under normal circumstances you don't need to unsubscribe from an RxJS observable, when an observable is created from a worker subject a subscription is also created in the worker.
     * To release the resources in the worker the `WorkerClient.unsubscribe(observable)` method should be used. The `WorkerClient.destroy()` method will
     * dispose of all observables correctly.
     *
     * @Serialized
     * @example
     * // async await syntax ---
     * this.observable$ = await client.observe(w => w.someEventSubject);
     *
     * // promise syntax ---
     * client.observe(w => w.someEventSubject).then((observable) => {
     *   this.observable$ = observable;
     * }).catch((err) => {
     *    console.log(err);
     * });
     *
     * // unsubscribing --------
     * await client.unsubscribe(this.observable$)
     * @param observable A lamda expression that returns the targeted RxJS subject of the worker. The worker argument in the expression only has the properties owned by the worker class (no methods)
     * and only those properties that are RxJS subjects
     */
    WorkerClient.prototype.observe = function (observable) {
        var _this = this;
        return this.castPromise(this.sendRequest(WorkerEvents.Observable, {
            workerProperty: observable,
            secretError: 'WorkerClient: only methods decorated with @Callable() can be used in the call method',
            beforeRequest: function (secret) { return _this.createObservable(secret.propertyName); },
            body: function (secret, key) { return { isUnsubscribe: false, subscriptionKey: key }; },
            resolve: function (resp, secret, key) { return _this.observables[key].observable; },
            beforeReject: function (resp, secret, key) { return _this.removeSubscription(key); }
        }));
    };
    /**
     * Unsubscribes from an RxJS subscription or observable that has been created from the `WorkerClient.subscribe()` or `WorkerClient.observe()` methods respectively.
     *  This method is neccessary to release resources within the worker. Calling `WorkerClient.destory()` will also dispose of all observables/subscriptions
     * @param subscriptionOrObservable The observable or subscription that must be disposed of
     */
    WorkerClient.prototype.unsubscribe = function (subscriptionOrObservable) {
        var key = this.findObservableKey(subscriptionOrObservable);
        if (key) {
            var propertyName = this.observables[key].propertyName;
            this.removeSubscription(key);
            return this.castPromise(this.sendRequest(WorkerEvents.Observable, {
                workerProperty: propertyName,
                secretError: '',
                body: function (secret) { return { isUnsubscribe: true, subscriptionKey: key }; },
            }));
        }
        else {
            return new Promise(function (resolve) { return resolve(); });
        }
    };
    /**
     * A generic utility function for sending requests to, and handling the responses from a `WorkerController` used when the `runInApp` property is set to `false`
     * @param type the type of worker event
     * @param opts Configurable options that defines how the request is sent and how the response is handled
     */
    WorkerClient.prototype.sendRequest = function (type, opts) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            var e_1, _a;
            if (_this._isConnected || opts.isConnect) {
                try {
                    var noProperty_1 = opts.workerProperty === undefined;
                    var secretResult_1 = noProperty_1 ? null : _this.isSecret(typeof opts.workerProperty === 'string' ? _this.worker[opts.workerProperty] : opts.workerProperty(_this.worker), type);
                    if (secretResult_1 || noProperty_1) {
                        // additional checks ---
                        if (opts.additionalConditions) {
                            try {
                                for (var _b = tslib_1.__values(opts.additionalConditions), _c = _b.next(); !_c.done; _c = _b.next()) {
                                    var opt = _c.value;
                                    if (!opt.if(secretResult_1)) {
                                        reject(opt.reject(secretResult_1));
                                        return;
                                    }
                                }
                            }
                            catch (e_1_1) { e_1 = { error: e_1_1 }; }
                            finally {
                                try {
                                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                                }
                                finally { if (e_1) throw e_1.error; }
                            }
                        }
                        // additional functionality ---
                        var additionalContext_1;
                        if (opts.beforeRequest) {
                            additionalContext_1 = opts.beforeRequest(secretResult_1);
                        }
                        // response ----
                        var requestSecret_1 = _this.generateSecretKey();
                        var repsonseSubscription_1 = _this.responseEvent.subscribe(function (resp) {
                            try {
                                var isValidReponse = resp.type === type && resp.requestSecret === requestSecret_1;
                                isValidReponse = noProperty_1 ? isValidReponse : (isValidReponse && secretResult_1.propertyName === resp.propertyName);
                                if (isValidReponse) {
                                    if (!resp.isError) {
                                        // resolve ----
                                        _this.removeSecretKey(requestSecret_1);
                                        if (opts.resolve) {
                                            resolve(opts.resolve(resp, secretResult_1, additionalContext_1));
                                        }
                                        else {
                                            resolve();
                                        }
                                        repsonseSubscription_1.unsubscribe();
                                    }
                                    else {
                                        // reject -----
                                        _this.removeSecretKey(requestSecret_1);
                                        if (opts.beforeReject) {
                                            opts.beforeReject(resp, secretResult_1, additionalContext_1);
                                        }
                                        repsonseSubscription_1.unsubscribe();
                                        reject(JSON.parse(resp.error));
                                    }
                                }
                            }
                            catch (e) {
                                reject(e);
                            }
                        });
                        // send request -----
                        var req = {
                            requestSecret: requestSecret_1,
                            propertyName: noProperty_1 ? null : secretResult_1.propertyName,
                            type: type,
                            body: opts.body ? opts.body(secretResult_1, additionalContext_1) : null
                        };
                        _this.postMessage(req);
                    }
                    else {
                        reject(new Error(opts.secretError));
                    }
                }
                catch (e) {
                    reject(e);
                }
            }
            else {
                reject(new Error('WorkerClient: the WorkerClient.connect() method must be called before a worker can be accessed'));
            }
        });
        return promise;
    };
    /**
     * A wrapper function around the `Worker.postMessage()` method to catch any serialization errors should they occur
     * @param request the request to be sent to the worker
     */
    WorkerClient.prototype.postMessage = function (request) {
        try {
            this.workerRef.postMessage(request);
        }
        catch (e) {
            throw new Error('Unable to serialize the request from the client to the worker');
        }
    };
    /**
     * A utility function to cast promises
     * @param promise promise to cast
     */
    WorkerClient.prototype.castPromise = function (promise) {
        return promise;
    };
    /**
     * Creates client subscription reference with a subscription and an RxJS subject, adds it to the `observables` dictionary with unique key and then returns the key. Called from the `subscribe()` method.
     * @param propertyName the property name of the worker's RxJS subject that was subscribed to
     * @param next Callback function that is triggered when the subject's `next()` method is called
     * @param error Callback function that is triggered when the subject throws and error
     * @param complete Callback function that is triggered when the subject's `complete()` method is called
     */
    WorkerClient.prototype.createSubscription = function (propertyName, next, error, complete) {
        var key = this.generateSubscriptionKey(propertyName);
        var subject = new Subject();
        var subscription = subject.subscribe(next, error, complete);
        this.observables[key] = { subject: subject, subscription: subscription, propertyName: propertyName, observable: null };
        return key;
    };
    /**
     * Creates client observable reference with a RxJS observable and subject, adds it to the `observables` dictionary with unique key and then returns the key. Called from the `observe()` method.
     * @param propertyName the property name of the worker's RxJS subject that was subscribed to
     */
    WorkerClient.prototype.createObservable = function (propertyName) {
        var key = this.generateSubscriptionKey(propertyName);
        var subject = new Subject();
        this.observables[key] = { subject: subject, subscription: null, propertyName: propertyName, observable: subject.asObservable() };
        return key;
    };
    /**
     * Iterates through the `observables` dictionary to find the associated key for a particular subscription or observable. Returns null if no match is found
     * @param value Subscription or observable for which the dictionary key must be found
     */
    WorkerClient.prototype.findObservableKey = function (value) {
        for (var key in this.observables) {
            if (value instanceof Subscription) {
                if (this.observables[key].subscription === value) {
                    return key;
                }
            }
            else {
                if (this.observables[key].observable === value) {
                    return key;
                }
            }
        }
        return null;
    };
    /**
     * Remove a subscription or observable reference from `observables` dictionary. Removed subscriptions are unsubsribed before destroyed
     * @param subscriptionKey unique key in the `observables` dictionary
     */
    WorkerClient.prototype.removeSubscription = function (subscriptionKey) {
        if (this.observables[subscriptionKey]) {
            if (this.observables[subscriptionKey].subscription) {
                this.observables[subscriptionKey].subscription.unsubscribe();
            }
        }
        delete this.observables[subscriptionKey];
    };
    /**
     * Generates a random key
     * @param propertyName appended as the prefix to the key
     * @param length length of the randomly generated characters
     */
    WorkerClient.prototype.generateKey = function (propertyName, length) {
        return propertyName.toUpperCase() + "_" + Array(length).fill(null).map(function () { return (Math.round(Math.random() * 16)).toString(16); }).join('');
    };
    /**
     * Creates a unique key for a subscription/observable reference for use in the `observables` dictionary. This key allows messages from the worker to be correctly mapped and handled in the client
     * @param propertyName property name of the worker's RxJS subject which is subscribed to. This is attached as a prefix to the unique key
     */
    WorkerClient.prototype.generateSubscriptionKey = function (propertyName) {
        var key = this.generateKey(propertyName, 6);
        while (this.observables[key]) {
            key = this.generateKey(propertyName, 6);
        }
        return key;
    };
    /**
     * Creates a unique key for worker requests ensuring no two keys are avaliable at any time through the `secrets` array. Allows requests to be mapped to responses from
     * the worker
     * @param propertyName property name of the worker's property/method that is being called. This is attached as a prefix to the unique key
     */
    WorkerClient.prototype.generateSecretKey = function (propertyName) {
        propertyName = propertyName ? propertyName : 'client';
        var key = this.generateKey(propertyName, 16);
        while (this.secrets.indexOf(key) !== -1) {
            key = this.generateKey(propertyName, 16);
        }
        this.secrets.push(key);
        return key;
    };
    /**
     * Removes a key from the `secrets` array if it exists
     * @param secret unqiue key to be removed
     */
    WorkerClient.prototype.removeSecretKey = function (secret) {
        if (this.secrets.indexOf(secret) !== -1) {
            this.secrets.splice(this.secrets.indexOf(secret), 1);
        }
    };
    /**
     * Checks if a valid `SecretResult` is returned when a decorated property and/or method of the client instance of the worker class is called.
     *  Returns the secret when valid otherwise returns null
     * @param secretResult the returned value from calling the property or method of a client instance of a worker
     * @param type the worker event type that originated the request
     */
    WorkerClient.prototype.isSecret = function (secretResult, type) {
        if (secretResult) {
            if (secretResult['clientSecret'] && secretResult['propertyName'] && secretResult['type']) {
                if (secretResult['clientSecret'] === this.workerSecret && secretResult['type'] === type) {
                    return secretResult;
                }
            }
        }
        return null;
    };
    /**
     * Creates the event listeners to listen for, and handle, messages recieved through `Worker.onmessage`
     */
    WorkerClient.prototype.registerEvents = function () {
        var _this = this;
        this.responseEvent = new Subject();
        this.observables = {};
        this.workerRef.onmessage = function (ev) {
            switch (ev.data.type) {
                case WorkerEvents.ObservableMessage:
                    var body = ev.data.result;
                    if (_this.observables[body.key]) {
                        switch (body.type) {
                            case WorkerObservableMessageTypes.Next:
                                _this.observables[body.key].subject.next(body.value);
                                break;
                            case WorkerObservableMessageTypes.Error:
                                _this.observables[body.key].subject.error(body.error);
                                break;
                            case WorkerObservableMessageTypes.Complete:
                                _this.observables[body.key].subject.complete();
                        }
                    }
                    break;
                default:
                    _this.responseEvent.next(ev.data);
            }
        };
    };
    return WorkerClient;
}());
export { WorkerClient };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid29ya2VyLWNsaWVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItd2ViLXdvcmtlci9hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL3dvcmtlci1jbGllbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxPQUFPLEVBQUUsWUFBWSxFQUFjLE1BQU0sTUFBTSxDQUFDO0FBRXpELE9BQU8sRUFDa0IsWUFBWSxFQUFFLFdBQVcsRUFDOUMsaUJBQWlCLEVBS2pCLDRCQUE0QixFQUMvQixNQUFNLDJCQUEyQixDQUFDO0FBRW5DLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUd0RDs7OztHQUlHO0FBQ0g7SUErQkk7Ozs7O09BS0c7SUFDSCxzQkFBb0IsVUFBNEIsRUFBVSxRQUF5QixFQUFVLFlBQTZCO1FBQWhFLHlCQUFBLEVBQUEsZ0JBQXlCO1FBQVUsNkJBQUEsRUFBQSxvQkFBNkI7UUFBdEcsZUFBVSxHQUFWLFVBQVUsQ0FBa0I7UUFBVSxhQUFRLEdBQVIsUUFBUSxDQUFpQjtRQUFVLGlCQUFZLEdBQVosWUFBWSxDQUFpQjtJQUMxSCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCw4QkFBTyxHQUFQO1FBQUEsaUJBMEJDO1FBekJHLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ3BCLElBQUksQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO1lBQ2xCLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7WUFDN0MsSUFBSSxDQUFDLE1BQU0sR0FBRyxXQUFXLENBQUMsYUFBYSxDQUFXLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUNqRyxRQUFRLEVBQUUsSUFBSTtnQkFDZCxZQUFZLEVBQUUsSUFBSSxDQUFDLFlBQVk7YUFDbEMsQ0FBQyxDQUFDO1lBRUgsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFR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dmFibGUgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgV29ya2VyQ2xpZW50T2JzZXJ2YWJsZXNEaWN0LCBXb3JrZXJDbGllbnRSZXF1ZXN0T3B0cyB9IGZyb20gJy4vd29ya2VyLWNsaWVudC10eXBlcyc7XHJcbmltcG9ydCB7XHJcbiAgICBXb3JrZXJSZXNwb25zZUV2ZW50LCBXb3JrZXJFdmVudHMsIFdvcmtlclV0aWxzLFxyXG4gICAgV29ya2VyQW5ub3RhdGlvbnMsIE5vbk9ic2VydmFibGVzT25seSwgQWNjZXNzYWJsZU1ldGFEYXRhLCBGdW5jdGlvbnNPbmx5LFxyXG4gICAgQ2FsbGFibGVNZXRhRGF0YSwgT2JzZXJ2YWJsZXNPbmx5LCBXb3JrZXJPYnNlcnZhYmxlVHlwZSwgV29ya2VyUmVxdWVzdEV2ZW50LFxyXG4gICAgU2VjcmV0UmVzdWx0LFxyXG4gICAgV29ya2VyRXZlbnQsXHJcbiAgICBXb3JrZXJPYnNlcnZhYmxlTWVzc2FnZSxcclxuICAgIFdvcmtlck9ic2VydmFibGVNZXNzYWdlVHlwZXNcclxufSBmcm9tICdhbmd1bGFyLXdlYi13b3JrZXIvY29tbW9uJztcclxuaW1wb3J0IHsgV29ya2VyRGVmaW5pdGlvbiB9IGZyb20gJy4vd29ya2VyLm1vZHVsZSc7XHJcbmltcG9ydCB7IENsaWVudFdlYldvcmtlciB9IGZyb20gJy4vY2xpZW50LXdlYi13b3JrZXInO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBhbiBBbmd1bGFyIGFwcCB0byBhY2Nlc3MgdGhlIHByb3BlcnRpZXMsIGNhbGwgdGhlIG1ldGhvZHMgYW5kIHN1YnNjcmliZSB0byB0aGUgZXZlbnRzIGluIGEgd2ViIHdvcmtlciBieSBtYW5hZ2luZ1xyXG4gKiB0aGUgY29tbXVuaWNhdGlvbiBiZXR3ZWVuIHRoZSBhcHAgYW5kIHRoZSB3b3JrZXIuIEFsc28gcHJvdmlkZXMgdGhlIG9wdGlvbiB0byBleGVjdXRlIHRoZSB3b3JrZXIgY29kZSB3aXRoaW4gdGhlIGFwcCBzaG91bGQgdGhlIGJyb3dzZXIgbm90IHN1cHBvcnQgd2ViIHdvcmtlcnMsXHJcbiAqIGFsdGhvdWdoIGludGVuc2l2ZSB3b3JrIG1heSB0aGVuIGJsb2NrIHRoZSBVSS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBXb3JrZXJDbGllbnQ8VD4ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGJyb3dzZXIncyB3b3JrZXIgY2xhc3MgZm9yIHBvc3RpbmcgbWVzc2FnZXMgYW5kIHRlcm1pbmF0aW5nIHRoZSB3b3JrZXJcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB3b3JrZXJSZWY6IFdvcmtlciB8IENsaWVudFdlYldvcmtlcjxUPjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNsaWVudCBpbnN0YW5jZSBvZiB0aGUgd29ya2VyIGNsYXNzXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgd29ya2VyOiBUO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNlY3JldCBrZXkgdGhhdCBtdXN0IGJlIHJldHVybmVkIHdoZW4gZGVjb3JhdGVkIHByb3BlcnRpZXMgYW5kL29yIG1ldGhvZHMgYXJlIGNhbGxlZCBmcm9tIHRoZSBjbGllbnQgaW5zdGFuY2Ugb2YgdGhlIHdvcmtlciBjbGFzc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHdvcmtlclNlY3JldD86IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogQXJyYXkgb2Ygc2VjcmV0IGtleXMgY29udGFpbmluZyB0aGUgYHdvcmtlclNlY3JldGAgYW5kIGBXb3JrZXJSZXF1ZXN0RXZlbnQucmVxdWVzdFNlY3JldGBzIGVuc3VyaW5nIHRoYXQgdGhlcmUgYXJlIG5ldmVyIHR3byBvZiB0aGUgc2FtZSBrZXlzIGF0IGFueSBwb2ludCBpbiB0aW1lXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc2VjcmV0czogc3RyaW5nW107XHJcbiAgICAvKipcclxuICAgICAqIEFuIGV2ZW50IHN1YmplY3QgdGhhdCBpcyB0cmlnZ2VyZWQgZWFjaCB0aW1lIGEgcmVzcG9uc2UgaXMgcmVjaWV2ZWQgZnJvbSBhIGBXb3JrZXJDb250cm9sbGVyYC4gVGhpcyBpcyBzdWJzY3JpYmVkIHRvIGltbWVkaWF0ZWx5IGJlZm9yZSBhbnkgcmVxdWVzdCBpcyBtYWRlIGluIHRoZSBgc2VuZFJlcXVlc3QoKWAgbWV0aG9kLlxyXG4gICAgICogVGhpcyBhbGxvd3MgdGhlIGBXb3JrZXIub25tZXNzYWdlYCBsaXN0ZW5lciB0byBiZSBtYXBwZWQgYmFjayB0byBhbiBhc3luYyBmdW5jdGlvbiBjYWxsIGZyb20gd2hlcmUgdGhlIHJlcXVlc3Qgb3JpZ2luYXRlZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlc3BvbnNlRXZlbnQ6IFN1YmplY3Q8V29ya2VyUmVzcG9uc2VFdmVudDxXb3JrZXJFdmVudHMuQ2FsbGFibGUgfCBXb3JrZXJFdmVudHMuQWNjZXNzYWJsZSB8IFdvcmtlckV2ZW50cy5PYnNlcnZhYmxlIHwgV29ya2VyRXZlbnRzLk9ic2VydmFibGVNZXNzYWdlPj47XHJcbiAgICAvKipcclxuICAgICAqIEEgZGljdGlvbmFyeSBvZiBvYnNlcnZhYmxlIHJlZmVyZW5jZXMgdGhhdCBsaXN0ZW4gZm9yIGV2ZW50cyB0cmlnZ2VyZWQgYnkgdGhlIHdvcmtlciBhZnRlciB0aGV5IGhhdmUgYmVlbiBzdWJzY3JpYmVkIG9yIG9ic2VydmVkIHRocm91Z2ggdGhlIHVzZSBvZiBlaXRoZXIgdGhlIGBzdWJzY3JpYmUoKWAgb3IgYG9ic2VydmVgIG1ldGhvZHNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBvYnNlcnZhYmxlczogV29ya2VyQ2xpZW50T2JzZXJ2YWJsZXNEaWN0O1xyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSB3b3JrZXIgaXMgYWN0aXZlIGFmdGVyIGl0IGlzIGNyZWF0ZWQgd2l0aCB0aGUgYGNvbm5lY3QoKWAgbWV0aG9kIGFuZCBiZWZvcmUgaXQgaGFzIGJlZW4gdGVybWluYXRlZCBieSB0aGUgYGRlc3Ryb3koKWAgbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX2lzQ29ubmVjdGVkOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgV29ya2VyQ2xpZW50YFxyXG4gICAgICogQHBhcmFtIGRlZmluaXRpb24gdGhlIHdvcmtlciBkZWZpbnRpb24gb3JpZ2luYXRpbmcgZnJvbSB0aGUgYXJndW1lbnRzIG9mIHRoZSBgV29ya2VyTW9kdWxlLmZvcldvcmtlcnMoKWAgbWV0aG9kXHJcbiAgICAgKiBAcGFyYW0gcnVuSW5BcHAgd2hldGhlciB0aGUgZXhlY3V0aW9uIG9mIHRoZSB3b3JrZXIgd2lsbCBvY2N1ciBpbiB0aGUgYXBwIG9yIHdpdGhpbiB0aGUgd29ya2VyIHNjcmlwdFxyXG4gICAgICogQHBhcmFtIHJ1bkluQXBwIHdoZXRoZXIgdGhlIGNsaWVudCBpcyB1c2VkIGZvciB1bml0IHRlc3Rpbmcgd2hpY2ggZGV0ZXJtaW5lcyBpZiBzZXJpYWxpemF0aW9uIHNob3VsZCBiZSBtb2NrZWRcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBkZWZpbml0aW9uOiBXb3JrZXJEZWZpbml0aW9uLCBwcml2YXRlIHJ1bkluQXBwOiBib29sZWFuID0gZmFsc2UsIHByaXZhdGUgaXNUZXN0Q2xpZW50OiBib29sZWFuID0gZmFsc2UpIHtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgd29ya2VyIHNjcmlwdCBpbiB0aGUgYnJvd3Nlciwgb3Igd2l0aGluIHRoZSBhcHAsIGFuZCB0cmlnZ2VycyB0aGUgYE9uV29ya2VySW5pdGAgaG9vaywgaWYgaW1wbGVtZW50ZWQuIElmIHRoZSBob29rIGlzIGltcGxlbWVudGVkIHRoZSBwcm9taXNlIHdpbGwgb25seSBiZSByZXNvbHZlZCBvbmNlIGBvbldvcmtlckluaXRgIG1ldGhvZFxyXG4gICAgICogaGFzIGNvbXBsZXRlZCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgaXQgaXMgYXN5bmMgb3Igbm90XHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBtZXRob2QgbXVzdCBjYWxsZWQgYmVmb3JlIGFueSB3b3JrZXIgbWV0aG9kcyBhbmQvb3IgcHJvcGVydGllcyBjYW4gYmUgY2FsbGVkL2FjY2Vzc2VkXHJcbiAgICAgKi9cclxuICAgIGNvbm5lY3QoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pc0Nvbm5lY3RlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnNlY3JldHMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy53b3JrZXJTZWNyZXQgPSB0aGlzLmdlbmVyYXRlU2VjcmV0S2V5KCk7XHJcbiAgICAgICAgICAgIHRoaXMud29ya2VyID0gV29ya2VyVXRpbHMuZ2V0QW5ub3RhdGlvbjxGdW5jdGlvbj4odGhpcy5kZWZpbml0aW9uLndvcmtlciwgV29ya2VyQW5ub3RhdGlvbnMuRmFjdG9yeSkoe1xyXG4gICAgICAgICAgICAgICAgaXNDbGllbnQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjbGllbnRTZWNyZXQ6IHRoaXMud29ya2VyU2VjcmV0XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLnJ1bkluQXBwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndvcmtlclJlZiA9IHRoaXMuZGVmaW5pdGlvbi5pbml0Rm4oKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud29ya2VyUmVmID0gbmV3IENsaWVudFdlYldvcmtlcih0aGlzLmRlZmluaXRpb24ud29ya2VyLCB0aGlzLmlzVGVzdENsaWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50cygpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FzdFByb21pc2U8dm9pZD4odGhpcy5zZW5kUmVxdWVzdChXb3JrZXJFdmVudHMuSW5pdCwge1xyXG4gICAgICAgICAgICAgICAgYm9keTogKCkgPT4gbnVsbCxcclxuICAgICAgICAgICAgICAgIGlzQ29ubmVjdDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHJlc29sdmU6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc0Nvbm5lY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzZWNyZXRFcnJvcjogJ0NvdWxkIG5vdCBpbml0aWFsaXNlIHdvcmtlcidcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlcm1pbmF0ZXMgdGhlIHdvcmtlciBhbmQgdW5zdWJzY3JpYmVzIGZyb20gYW55IHN1YnNjcmlwdGlvbnMgY3JlYXRlZCBmcm9tIHRoZSBgc3Vic2NyaWJlKClgIG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMub2JzZXJ2YWJsZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9ic2VydmFibGVzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVN1YnNjcmlwdGlvbihrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMud29ya2VyUmVmLnRlcm1pbmF0ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnNlY3JldHMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZhYmxlcyA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLndvcmtlciA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzQ29ubmVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgd29ya2VyIGlzIGFjdGl2ZSBhZnRlciBpdCBpcyBjcmVhdGVkIHdpdGggdGhlIGBjb25uZWN0KClgIG1ldGhvZCBhbmQgYmVmb3JlIGl0IGhhcyBiZWVuIHRlcm1pbmF0ZWQgYnkgdGhlIGBkZXN0cm95KClgIG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBnZXQgaXNDb25uZWN0ZWQoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ29ubmVjdGVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgYSB3b3JrZXIgcHJvcGVydHkgdGhhdCBoYXMgYmVlbiBkZWNvcmF0ZWQgd2l0aCBgQEFjY2Vzc2FibGUoKWAuIFVuZGVjb3JhdGVkIHByb3BlcnRpZXMgd2lsbCBjYXVzZSB0aGUgcHJvbWlzZSB0byBiZSByZWplY3RlZFxyXG4gICAgICogQFNlcmlhbGl6ZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBhc3luYyBhd2FpdCBzeW50YXggLS0tXHJcbiAgICAgKiBjb25zdCBuYW1lOiBzdHJpbmcgPSBhd2FpdCBjbGllbnQuZ2V0KHcgPT4gdy5uYW1lKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBwcm9taXNlIHN5bnRheCAtLS1cclxuICAgICAqIGNsaWVudC5nZXQodyA9PiB3Lm5hbWUpLnRoZW4oKG5hbWUpID0+IHtcclxuICAgICAqICAgY29uc29sZS5sb2cobmFtZSk7XHJcbiAgICAgKiB9KS5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgKiAgIGNvbnNvbGUubG9nKGVycik7XHJcbiAgICAgKiB9KTtcclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eSBBIGxhbWRhIGV4cHJlc3Npb24gdGhhdCByZXR1cm5zIHRoZSB0YXJnZXRlZCBwcm9wZXJ0eSBvZiB0aGUgd29ya2VyLiBUaGUgd29ya2VyIGFyZ3VtZW50IGluIHRoZSBleHByZXNzaW9uIG9ubHkgaGFzIHRoZSBwcm9wZXJ0aWVzIG93bmVkIGJ5IHRoZSB3b3JrZXIgY2xhc3MgKG5vIG1ldGhvZHMpXHJcbiAgICAgKiBhbmQgb25seSB0aG9zZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIG5vdCBSeEpTIHN1YmplY3RzXHJcbiAgICAgKi9cclxuICAgIGdldDxQcm9wZXJ0eVR5cGU+KFxyXG4gICAgICAgIHByb3BlcnR5OiAod29ya2VyUHJvcGVydGllczogTm9uT2JzZXJ2YWJsZXNPbmx5PFQ+KSA9PiBQcm9wZXJ0eVR5cGVcclxuICAgICk6IFByb21pc2U8UHJvcGVydHlUeXBlPiB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KFdvcmtlckV2ZW50cy5BY2Nlc3NhYmxlLCB7XHJcbiAgICAgICAgICAgIHdvcmtlclByb3BlcnR5OiBwcm9wZXJ0eSxcclxuICAgICAgICAgICAgYWRkaXRpb25hbENvbmRpdGlvbnM6IFt7XHJcbiAgICAgICAgICAgICAgICBpZjogKHNlY3JldCkgPT4gc2VjcmV0LmJvZHkuZ2V0LFxyXG4gICAgICAgICAgICAgICAgcmVqZWN0OiAoc2VjcmV0KSA9PiBuZXcgRXJyb3IoYFdvcmtlckNsaWVudDogd2lsbCBub3QgYXBwbHkgdGhlIGdldCBtZXRob2QgdG8gdGhlIFwiJHtzZWNyZXQucHJvcGVydHlOYW1lfVwiIHByb3BlcnR5IGJlY2F1c2UgdGhlIGdldCBhY2Nlc3NvciBoYXMgYmVlbiBleHBsaWNpdHkgc2V0IHRvIGZhbHNlYClcclxuICAgICAgICAgICAgfV0sXHJcbiAgICAgICAgICAgIHNlY3JldEVycm9yOiAnV29ya2VyQ2xpZW50OiBvbmx5IHByb3BlcnRpZXMgZGVjb3JhdGVkIHdpdGggQEFjY2Vzc2FibGUoKSBjYW4gYmUgdXNlZCBpbiB0aGUgZ2V0IG1ldGhvZCcsXHJcbiAgICAgICAgICAgIGJvZHk6ICgpID0+IHsgcmV0dXJuIHsgaXNHZXQ6IHRydWUgfTsgfSxcclxuICAgICAgICAgICAgcmVzb2x2ZTogKHJlc3ApID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFEYXRhID0gV29ya2VyVXRpbHMuZ2V0QW5ub3RhdGlvbjxBY2Nlc3NhYmxlTWV0YURhdGFbXT4odGhpcy5kZWZpbml0aW9uLndvcmtlciwgV29ya2VyQW5ub3RhdGlvbnMuQWNjZXNzYWJsZXMpLmZpbHRlcih4ID0+IHgubmFtZSA9PT0gcmVzcC5wcm9wZXJ0eU5hbWUpWzBdO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1ldGFEYXRhLnNoYWxsb3dUcmFuc2Zlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhRGF0YS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRhRGF0YS50eXBlLnByb3RvdHlwZSAmJiByZXNwLnJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcC5yZXN1bHQuX19wcm90b19fID0gbWV0YURhdGEudHlwZS5wcm90b3R5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3AucmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB2YWx1ZSBvZiBhIHdvcmtlciBwcm9wZXJ0eSB0aGF0IGhhcyBiZWVuIGRlY29yYXRlZCB3aXRoIGBAQWNjZXNzYWJsZSgpYC4gVW5kZWNvcmF0ZWQgcHJvcGVydGllcyB3aWxsIGNhdXNlIHRoZSBwcm9taXNlIHRvIGJlIHJlamVjdGVkXHJcbiAgICAgKiBAU2VyaWFsaXplZFxyXG5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBhc3luYyBhd2FpdCBzeW50YXggLS0tXHJcbiAgICAgKiBhd2FpdCBjbGllbnQuc2V0KHcgPT4gdy5uYW1lLCAncGV0ZXInKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBwcm9taXNlIHN5bnRheCAtLS1cclxuICAgICAqIGNsaWVudC5zZXQodyA9PiB3Lm5hbWUsICdwZXRlcicpLnRoZW4oKCkgPT4ge1xyXG4gICAgICogICBjb25zb2xlLmxvZygncHJvcGVydHkgaGFzIGJlZW4gc2V0Jyk7XHJcbiAgICAgKiB9KS5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgKiAgIGNvbnNvbGUubG9nKGVycik7XHJcbiAgICAgKiB9KTtcclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eSBBIGxhbWRhIGV4cHJlc3Npb24gdGhhdCByZXR1cm5zIHRoZSB0YXJnZXRlZCBwcm9wZXJ0eSBvZiB0aGUgd29ya2VyLiBUaGUgd29ya2VyIGFyZ3VtZW50IGluIHRoZSBleHByZXNzaW9uIG9ubHkgaGFzIHRoZSBwcm9wZXJ0aWVzIG93bmVkIGJ5IHRoZSB3b3JrZXIgY2xhc3MgKG5vIG1ldGhvZHMpXHJcbiAgICAgKiBhbmQgb25seSB0aG9zZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIG5vdCBSeEpTIHN1YmplY3RzXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHdoaWNoIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgc2V0IHRvXHJcbiAgICAgKi9cclxuICAgIHNldDxQcm9wZXJ0eVR5cGU+KFxyXG4gICAgICAgIHByb3BlcnR5OiAod29ya2VyUHJvcGVydGllczogTm9uT2JzZXJ2YWJsZXNPbmx5PFQ+KSA9PiBQcm9wZXJ0eVR5cGUsXHJcbiAgICAgICAgdmFsdWU6IFByb3BlcnR5VHlwZVxyXG4gICAgKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FzdFByb21pc2U8dm9pZD4odGhpcy5zZW5kUmVxdWVzdChXb3JrZXJFdmVudHMuQWNjZXNzYWJsZSwge1xyXG4gICAgICAgICAgICB3b3JrZXJQcm9wZXJ0eTogcHJvcGVydHksXHJcbiAgICAgICAgICAgIGFkZGl0aW9uYWxDb25kaXRpb25zOiBbe1xyXG4gICAgICAgICAgICAgICAgaWY6IChzZWNyZXQpID0+IHNlY3JldC5ib2R5LnNldCxcclxuICAgICAgICAgICAgICAgIHJlamVjdDogKHNlY3JldCkgPT4gbmV3IEVycm9yKGBXb3JrZXJDbGllbnQ6IHdpbGwgbm90IGFwcGx5IHRoZSBzZXQgbWV0aG9kIHRvIHRoZSBcIiR7c2VjcmV0LnByb3BlcnR5TmFtZX1cIiBwcm9wZXJ0eSBiZWNhdXNlIHRoZSBzZXQgYWNjZXNzb3IgaGFzIGJlZW4gZXhwbGljaXR5IHNldCB0byBmYWxzZWApXHJcbiAgICAgICAgICAgIH1dLFxyXG4gICAgICAgICAgICBzZWNyZXRFcnJvcjogJ1dvcmtlckNsaWVudDogb25seSBwcm9wZXJ0aWVzIGRlY29yYXRlZCB3aXRoIEBBY2Nlc3NhYmxlKCkgY2FuIGJlIHVzZWQgaW4gdGhlIHNldCBtZXRob2QnLFxyXG4gICAgICAgICAgICBib2R5OiAoKSA9PiB7IHJldHVybiB7IGlzR2V0OiBmYWxzZSwgdmFsdWU6IHZhbHVlIH07IH1cclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxscyBhIG1ldGhvZCBpbiB0aGUgd29ya2VyIGFuZCByZXR1cm5zIGl0cyB2YWx1ZS4gVGhlIGNhbGxlZCBtZXRob2QgY2FuIGJlIGVpdGhlciBzeW5jaHJvbm91cyBvciBhc3luY2hyb25vdXNcclxuICAgICAqIGJ1dCBtdXN0IGJlIGRlY29yYXRlZCB3aXRoIGBAQ2FsbGFibGUoKWAgZWxzZSB0aGUgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkXHJcbiAgICAgKiBAU2VyaWFsaXplZCBBcHBsaWVzIHRvIGJvdGggdGhlIGZ1bmN0aW9uIGFyZ3VtZW50cyBhbmQgdGhlIHJldHVybmVkIHZhbHVlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gYXN5bmMgYXdhaXQgc3ludGF4IC0tLVxyXG4gICAgICogY29uc3QgZnVuY3Rpb25SZXN1bHQ6IFNvbWVSZXN1bHRUeXBlID0gYXdhaXQgY2xpZW50LmNhbGwodyA9PiB3LmRvU29tZVdvcmsoJ3NvbWVBcmd1bWVudCcsIDIxMjMpKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBwcm9taXNlIHN5bnRheCAtLS1cclxuICAgICAqIGNsaWVudC5jYWxsKHcgPT4gdy5kb1NvbWVXb3JrKCdzb21lQXJndW1lbnQnLCAyMTIzKSkudGhlbigocmVzdWx0KSA9PiB7XHJcbiAgICAgKiAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xyXG4gICAgICogfSkuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICogICAgY29uc29sZS5sb2coZXJyKTtcclxuICAgICAqIH0pO1xyXG4gICAgICogQHBhcmFtIHByb3BlcnR5IEEgbGFtZGEgZXhwcmVzc2lvbiB0aGF0IGNhbGxzIHRoZSB3b3JrZXIgbWV0aG9kLiBUaGUgd29ya2VyIGFyZ3VtZW50IGluIHRoZSBleHByZXNzaW9uIG9ubHkgaGFzIHRoZSBtZXRob2RzIG93bmVkIGJ5IHRoZSB3b3JrZXIgY2xhc3MgKG5vdCB0aGUgcHJvcGVydGllcylcclxuICAgICAqL1xyXG4gICAgY2FsbDxSZXR1cm5UeXBlPihcclxuICAgICAgICBjYWxsRm46ICh3b3JrZXJGdW5jdGlvbnM6IEZ1bmN0aW9uc09ubHk8VD4pID0+IFJldHVyblR5cGVcclxuICAgICk6IFJldHVyblR5cGUgZXh0ZW5kcyBQcm9taXNlPGFueT4gPyBSZXR1cm5UeXBlIDogUHJvbWlzZTxSZXR1cm5UeXBlPiB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KFdvcmtlckV2ZW50cy5DYWxsYWJsZSwge1xyXG4gICAgICAgICAgICB3b3JrZXJQcm9wZXJ0eTogY2FsbEZuLFxyXG4gICAgICAgICAgICBzZWNyZXRFcnJvcjogJ1dvcmtlckNsaWVudDogb25seSBtZXRob2RzIGRlY29yYXRlZCB3aXRoIEBDYWxsYWJsZSgpIGNhbiBiZSB1c2VkIGluIHRoZSBjYWxsIG1ldGhvZCcsXHJcbiAgICAgICAgICAgIGJvZHk6IChzZWNyZXQpID0+IHsgcmV0dXJuIHsgYXJndW1lbnRzOiBzZWNyZXQuYm9keS5hcmdzIH07IH0sXHJcbiAgICAgICAgICAgIHJlc29sdmU6IChyZXNwKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhRGF0YSA9IFdvcmtlclV0aWxzLmdldEFubm90YXRpb248Q2FsbGFibGVNZXRhRGF0YVtdPih0aGlzLmRlZmluaXRpb24ud29ya2VyLCBXb3JrZXJBbm5vdGF0aW9ucy5DYWxsYWJsZXMsIFtdKS5maWx0ZXIoeCA9PiB4Lm5hbWUgPT09IHJlc3AucHJvcGVydHlOYW1lKVswXTtcclxuICAgICAgICAgICAgICAgIGlmIChtZXRhRGF0YS5zaGFsbG93VHJhbnNmZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWV0YURhdGEucmV0dXJuVHlwZSA9PT0gUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtlckNsaWVudDogc2hhbGxvd1RyYW5zZmVyIHdpbGwgbm90IGJlIHRydWUgaW4gdGhlIEBDYWxsYWJsZSgpIGRlY29yYXRvciB3aGVuIHRoZSBkZWNvcmF0ZWQgbWV0aG9kIHJldHVybnMgYSBwcm9taXNlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhRGF0YS5yZXR1cm5UeXBlICYmIHJlc3AucmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3AucmVzdWx0Ll9fcHJvdG9fXyA9IG1ldGFEYXRhLnJldHVyblR5cGUucHJvdG90eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwLnJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZXMgdG8gYSB3b3JrZXIncyBSeEpTIHN1YmplY3QsIHdoaWNoIGhhcyBiZWVuIGRlY29yYXRlZCB3aXRoIGBAU3Vic2NyaWJhYmxlKClgLCBhbmQgdGhlbiByZXR1cm5zIHRoaXMgc3Vic2NyaXB0aW9uLlxyXG4gICAgICogIFN1cHBvcnRzIGFsbCBmb3VyIFJ4SlMgc3ViamVjdHMgYmVpbmcgYFN1YmplY3RgLCAgYEJlaGF2aW9yU3ViamVjdGAsIGBSZXBsYXlTdWJqZWN0YCBhbmQgYEFzeW5jU3ViamVjdGAuXHJcbiAgICAgKlxyXG4gICAgICogKipVTlNVQlNDUklCSU5HKipcclxuICAgICAqXHJcbiAgICAgKiBXaGlsZSB0aGUgcmV0dXJuZWQgc3Vic2NyaXB0aW9uIGNhbiBiZSBkZXN0cm95ZWQgd2l0aCBgU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKClgIHRoaXMgaXMgb25seSBkZXN0cm95cyB0aGUgY2xpZW50IHN1YnNjcmlwdGlvbi4gQSBzdWJzY3JpcHRpb24gaXMgYWxzbyBjcmVhdGVkIGluIHRoZSB3b3JrZXIuXHJcbiAgICAgKiBUbyByZWxlYXNlIHRoZSByZXNvdXJjZXMgaW4gYm90aCB0aGUgY2xpZW50IGFuZCB0aGUgd29ya2VyIHRoZSBgV29ya2VyQ2xpZW50LnVuc3Vic2NyaWJlKHN1YnNjcmlwdGlvbilgIG1ldGhvZCBzaG91bGQgYmUgdXNlZC4gVGhlIGBXb3JrZXJDbGllbnQuZGVzdHJveSgpYCBtZXRob2Qgd2lsbFxyXG4gICAgICogZGlzcG9zZSBvZiBhbGwgc3Vic2NyaXB0aW9ucyBjb3JyZWN0bHkuXHJcbiAgICAgKlxyXG4gICAgICogQFNlcmlhbGl6ZWQgVGhpcyBhcHBsaWVzIHRvIG1lc3NhZ2VzIHBvc3RlZCB0aHJvdWdoIGBTdWJqZWN0Lm5leHQoKWBcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBhc3luYyBhd2FpdCBzeW50YXggLS0tXHJcbiAgICAgKiB0aGlzLndvcmtlclN1YnNjcmlwdGlvbiA9IGF3YWl0IGNsaWVudC5zdWJzY3JpYmUodyA9PiB3LnNvbWVFdmVudFN1YmplY3QpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHByb21pc2Ugc3ludGF4IC0tLVxyXG4gICAgICogY2xpZW50LnN1YnNjcmliZSh3ID0+IHcuc29tZUV2ZW50U3ViamVjdCkudGhlbigoc3Vic2NyaXB0aW9uKSA9PiB7XHJcbiAgICAgKiAgICB0aGlzLndvcmtlclN1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvbjtcclxuICAgICAqIH0pLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAqICAgIGNvbnNvbGUubG9nKGVycik7XHJcbiAgICAgKiB9KTtcclxuICAgICAqXHJcbiAgICAgKiAvLyB1bnN1YnNjcmliaW5nIC0tLS0tLS0tXHJcbiAgICAgKiBhd2FpdCBjbGllbnQudW5zdWJzY3JpYmUodGhpcy53b3JrZXJTdWJzY3JpcHRpb24pXHJcbiAgICAgKiBAcGFyYW0gb2JzZXJ2YWJsZSBBIGxhbWRhIGV4cHJlc3Npb24gdGhhdCByZXR1cm5zIHRoZSB0YXJnZXRlZCBSeEpTIHN1YmplY3Qgb2YgdGhlIHdvcmtlci4gVGhlIHdvcmtlciBhcmd1bWVudCBpbiB0aGUgZXhwcmVzc2lvbiBvbmx5IGhhcyB0aGUgcHJvcGVydGllcyBvd25lZCBieSB0aGUgd29ya2VyIGNsYXNzIChubyBtZXRob2RzKVxyXG4gICAgICogYW5kIG9ubHkgdGhvc2UgcHJvcGVydGllcyB0aGF0IGFyZSBSeEpTIHN1YmplY3RzXHJcbiAgICAgKiBAcGFyYW0gbmV4dCBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBzdWJqZWN0J3MgYG5leHQoKWAgbWV0aG9kIGlzIGNhbGxlZCB3aXRoaW4gdGhlIHdvcmtlclxyXG4gICAgICogQHBhcmFtIGVycm9yIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIHN1YmplY3QgdGhyb3dzIGFuZCBlcnJvclxyXG4gICAgICogQHBhcmFtIGNvbXBsZXRlIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIHN1YmplY3QncyBgY29tcGxldGUoKWAgbWV0aG9kIGlzIGNhbGxlZCB3aXRoaW4gdGhlIHdvcmtlclxyXG4gICAgICovXHJcbiAgICBzdWJzY3JpYmU8T2JzZXJ2YWJsZVR5cGU+KFxyXG4gICAgICAgIG9ic2VydmFibGU6ICh3b3JrZXJPYnNlcnZhYmxlczogT2JzZXJ2YWJsZXNPbmx5PFQ+KSA9PiBXb3JrZXJPYnNlcnZhYmxlVHlwZTxPYnNlcnZhYmxlVHlwZT4sXHJcbiAgICAgICAgbmV4dDogKHZhbHVlOiBPYnNlcnZhYmxlVHlwZSkgPT4gdm9pZCxcclxuICAgICAgICBlcnJvcj86IChlcnJvcjogYW55KSA9PiB2b2lkLFxyXG4gICAgICAgIGNvbXBsZXRlPzogKCkgPT4gdm9pZFxyXG4gICAgKTogUHJvbWlzZTxTdWJzY3JpcHRpb24+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYXN0UHJvbWlzZTxTdWJzY3JpcHRpb24+KHRoaXMuc2VuZFJlcXVlc3QoV29ya2VyRXZlbnRzLk9ic2VydmFibGUsIHtcclxuICAgICAgICAgICAgd29ya2VyUHJvcGVydHk6IG9ic2VydmFibGUsXHJcbiAgICAgICAgICAgIHNlY3JldEVycm9yOiAnV29ya2VyQ2xpZW50OiBvbmx5IG1ldGhvZHMgZGVjb3JhdGVkIHdpdGggQENhbGxhYmxlKCkgY2FuIGJlIHVzZWQgaW4gdGhlIGNhbGwgbWV0aG9kJyxcclxuICAgICAgICAgICAgYmVmb3JlUmVxdWVzdDogKHNlY3JldCkgPT4gdGhpcy5jcmVhdGVTdWJzY3JpcHRpb24oc2VjcmV0LnByb3BlcnR5TmFtZSwgbmV4dCwgZXJyb3IsIGNvbXBsZXRlKSxcclxuICAgICAgICAgICAgYm9keTogKHNlY3JldCwga2V5KSA9PiB7IHJldHVybiB7IGlzVW5zdWJzY3JpYmU6IGZhbHNlLCBzdWJzY3JpcHRpb25LZXk6IGtleSB9OyB9LFxyXG4gICAgICAgICAgICByZXNvbHZlOiAocmVzcCwgc2VjcmV0LCBrZXkpID0+IHRoaXMub2JzZXJ2YWJsZXNba2V5XS5zdWJzY3JpcHRpb24sXHJcbiAgICAgICAgICAgIGJlZm9yZVJlamVjdDogKHJlc3AsIHNlY3JldCwga2V5KSA9PiB0aGlzLnJlbW92ZVN1YnNjcmlwdGlvbihrZXkpXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIFJ4SlMgb2JzZXJ2YWJsZSB0aGF0IGlzIGluIHN5bmMgd2l0aCBhIFJ4SlMgc3ViamVjdCB3aXRoaW4gYSB3b3JrZXIuIFRoZSB3b3JrZXIgc3ViamVjdCBtdXN0IGJlIGRlY29yYXRlZCB3aXRoIGBAU3Vic2NyaWJhYmxlKClgIG90aGVyd2lzZSB0aGVcclxuICAgICAqIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZC4gU3VwcG9ydHMgYWxsIGZvdXIgUnhKUyBzdWJqZWN0cyBiZWluZywgYFN1YmplY3RgLCAgYEJlaGF2aW9yU3ViamVjdGAsIGBSZXBsYXlTdWJqZWN0YCBhbmQgYEFzeW5jU3ViamVjdGAuXHJcbiAgICAgKlxyXG4gICAgICogKipVTlNVQlNDUklCSU5HKipcclxuICAgICAqXHJcbiAgICAgKiBXaGlsZSB1bmRlciBub3JtYWwgY2lyY3Vtc3RhbmNlcyB5b3UgZG9uJ3QgbmVlZCB0byB1bnN1YnNjcmliZSBmcm9tIGFuIFJ4SlMgb2JzZXJ2YWJsZSwgd2hlbiBhbiBvYnNlcnZhYmxlIGlzIGNyZWF0ZWQgZnJvbSBhIHdvcmtlciBzdWJqZWN0IGEgc3Vic2NyaXB0aW9uIGlzIGFsc28gY3JlYXRlZCBpbiB0aGUgd29ya2VyLlxyXG4gICAgICogVG8gcmVsZWFzZSB0aGUgcmVzb3VyY2VzIGluIHRoZSB3b3JrZXIgdGhlIGBXb3JrZXJDbGllbnQudW5zdWJzY3JpYmUob2JzZXJ2YWJsZSlgIG1ldGhvZCBzaG91bGQgYmUgdXNlZC4gVGhlIGBXb3JrZXJDbGllbnQuZGVzdHJveSgpYCBtZXRob2Qgd2lsbFxyXG4gICAgICogZGlzcG9zZSBvZiBhbGwgb2JzZXJ2YWJsZXMgY29ycmVjdGx5LlxyXG4gICAgICpcclxuICAgICAqIEBTZXJpYWxpemVkXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gYXN5bmMgYXdhaXQgc3ludGF4IC0tLVxyXG4gICAgICogdGhpcy5vYnNlcnZhYmxlJCA9IGF3YWl0IGNsaWVudC5vYnNlcnZlKHcgPT4gdy5zb21lRXZlbnRTdWJqZWN0KTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBwcm9taXNlIHN5bnRheCAtLS1cclxuICAgICAqIGNsaWVudC5vYnNlcnZlKHcgPT4gdy5zb21lRXZlbnRTdWJqZWN0KS50aGVuKChvYnNlcnZhYmxlKSA9PiB7XHJcbiAgICAgKiAgIHRoaXMub2JzZXJ2YWJsZSQgPSBvYnNlcnZhYmxlO1xyXG4gICAgICogfSkuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICogICAgY29uc29sZS5sb2coZXJyKTtcclxuICAgICAqIH0pO1xyXG4gICAgICpcclxuICAgICAqIC8vIHVuc3Vic2NyaWJpbmcgLS0tLS0tLS1cclxuICAgICAqIGF3YWl0IGNsaWVudC51bnN1YnNjcmliZSh0aGlzLm9ic2VydmFibGUkKVxyXG4gICAgICogQHBhcmFtIG9ic2VydmFibGUgQSBsYW1kYSBleHByZXNzaW9uIHRoYXQgcmV0dXJucyB0aGUgdGFyZ2V0ZWQgUnhKUyBzdWJqZWN0IG9mIHRoZSB3b3JrZXIuIFRoZSB3b3JrZXIgYXJndW1lbnQgaW4gdGhlIGV4cHJlc3Npb24gb25seSBoYXMgdGhlIHByb3BlcnRpZXMgb3duZWQgYnkgdGhlIHdvcmtlciBjbGFzcyAobm8gbWV0aG9kcylcclxuICAgICAqIGFuZCBvbmx5IHRob3NlIHByb3BlcnRpZXMgdGhhdCBhcmUgUnhKUyBzdWJqZWN0c1xyXG4gICAgICovXHJcbiAgICBvYnNlcnZlPE9ic2VydmFibGVUeXBlPihcclxuICAgICAgICBvYnNlcnZhYmxlOiAod29ya2VyT2JzZXJ2YWJsZXM6IE9ic2VydmFibGVzT25seTxUPikgPT4gV29ya2VyT2JzZXJ2YWJsZVR5cGU8T2JzZXJ2YWJsZVR5cGU+LFxyXG4gICAgKTogUHJvbWlzZTxPYnNlcnZhYmxlPE9ic2VydmFibGVUeXBlPj4ge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5jYXN0UHJvbWlzZTxPYnNlcnZhYmxlPE9ic2VydmFibGVUeXBlPj4odGhpcy5zZW5kUmVxdWVzdChXb3JrZXJFdmVudHMuT2JzZXJ2YWJsZSwge1xyXG4gICAgICAgICAgICB3b3JrZXJQcm9wZXJ0eTogb2JzZXJ2YWJsZSxcclxuICAgICAgICAgICAgc2VjcmV0RXJyb3I6ICdXb3JrZXJDbGllbnQ6IG9ubHkgbWV0aG9kcyBkZWNvcmF0ZWQgd2l0aCBAQ2FsbGFibGUoKSBjYW4gYmUgdXNlZCBpbiB0aGUgY2FsbCBtZXRob2QnLFxyXG4gICAgICAgICAgICBiZWZvcmVSZXF1ZXN0OiAoc2VjcmV0KSA9PiB0aGlzLmNyZWF0ZU9ic2VydmFibGUoc2VjcmV0LnByb3BlcnR5TmFtZSksXHJcbiAgICAgICAgICAgIGJvZHk6IChzZWNyZXQsIGtleSkgPT4geyByZXR1cm4geyBpc1Vuc3Vic2NyaWJlOiBmYWxzZSwgc3Vic2NyaXB0aW9uS2V5OiBrZXkgfTsgfSxcclxuICAgICAgICAgICAgcmVzb2x2ZTogKHJlc3AsIHNlY3JldCwga2V5KSA9PiB0aGlzLm9ic2VydmFibGVzW2tleV0ub2JzZXJ2YWJsZSxcclxuICAgICAgICAgICAgYmVmb3JlUmVqZWN0OiAocmVzcCwgc2VjcmV0LCBrZXkpID0+IHRoaXMucmVtb3ZlU3Vic2NyaXB0aW9uKGtleSlcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVbnN1YnNjcmliZXMgZnJvbSBhbiBSeEpTIHN1YnNjcmlwdGlvbiBvciBvYnNlcnZhYmxlIHRoYXQgaGFzIGJlZW4gY3JlYXRlZCBmcm9tIHRoZSBgV29ya2VyQ2xpZW50LnN1YnNjcmliZSgpYCBvciBgV29ya2VyQ2xpZW50Lm9ic2VydmUoKWAgbWV0aG9kcyByZXNwZWN0aXZlbHkuXHJcbiAgICAgKiAgVGhpcyBtZXRob2QgaXMgbmVjY2Vzc2FyeSB0byByZWxlYXNlIHJlc291cmNlcyB3aXRoaW4gdGhlIHdvcmtlci4gQ2FsbGluZyBgV29ya2VyQ2xpZW50LmRlc3RvcnkoKWAgd2lsbCBhbHNvIGRpc3Bvc2Ugb2YgYWxsIG9ic2VydmFibGVzL3N1YnNjcmlwdGlvbnNcclxuICAgICAqIEBwYXJhbSBzdWJzY3JpcHRpb25Pck9ic2VydmFibGUgVGhlIG9ic2VydmFibGUgb3Igc3Vic2NyaXB0aW9uIHRoYXQgbXVzdCBiZSBkaXNwb3NlZCBvZlxyXG4gICAgICovXHJcbiAgICB1bnN1YnNjcmliZShcclxuICAgICAgICBzdWJzY3JpcHRpb25Pck9ic2VydmFibGU6IFN1YnNjcmlwdGlvbiB8IE9ic2VydmFibGU8YW55PlxyXG4gICAgKTogUHJvbWlzZTx2b2lkPiB7XHJcblxyXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZmluZE9ic2VydmFibGVLZXkoc3Vic2NyaXB0aW9uT3JPYnNlcnZhYmxlKTtcclxuICAgICAgICBpZiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5TmFtZTogc3RyaW5nID0gdGhpcy5vYnNlcnZhYmxlc1trZXldLnByb3BlcnR5TmFtZTtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVTdWJzY3JpcHRpb24oa2V5KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FzdFByb21pc2U8dm9pZD4odGhpcy5zZW5kUmVxdWVzdChXb3JrZXJFdmVudHMuT2JzZXJ2YWJsZSwge1xyXG4gICAgICAgICAgICAgICAgd29ya2VyUHJvcGVydHk6IHByb3BlcnR5TmFtZSxcclxuICAgICAgICAgICAgICAgIHNlY3JldEVycm9yOiAnJyxcclxuICAgICAgICAgICAgICAgIGJvZHk6IChzZWNyZXQpID0+IHsgcmV0dXJuIHsgaXNVbnN1YnNjcmliZTogdHJ1ZSwgc3Vic2NyaXB0aW9uS2V5OiBrZXkgfTsgfSxcclxuICAgICAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHJlc29sdmUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBnZW5lcmljIHV0aWxpdHkgZnVuY3Rpb24gZm9yIHNlbmRpbmcgcmVxdWVzdHMgdG8sIGFuZCBoYW5kbGluZyB0aGUgcmVzcG9uc2VzIGZyb20gYSBgV29ya2VyQ29udHJvbGxlcmAgdXNlZCB3aGVuIHRoZSBgcnVuSW5BcHBgIHByb3BlcnR5IGlzIHNldCB0byBgZmFsc2VgXHJcbiAgICAgKiBAcGFyYW0gdHlwZSB0aGUgdHlwZSBvZiB3b3JrZXIgZXZlbnRcclxuICAgICAqIEBwYXJhbSBvcHRzIENvbmZpZ3VyYWJsZSBvcHRpb25zIHRoYXQgZGVmaW5lcyBob3cgdGhlIHJlcXVlc3QgaXMgc2VudCBhbmQgaG93IHRoZSByZXNwb25zZSBpcyBoYW5kbGVkXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc2VuZFJlcXVlc3Q8RXZlbnRUeXBlIGV4dGVuZHMgbnVtYmVyLCBSZXR1cm5UeXBlPihcclxuICAgICAgICB0eXBlOiBFdmVudFR5cGUsXHJcbiAgICAgICAgb3B0czogV29ya2VyQ2xpZW50UmVxdWVzdE9wdHM8VCwgRXZlbnRUeXBlLCBSZXR1cm5UeXBlPlxyXG4gICAgKTogUmV0dXJuVHlwZSBleHRlbmRzIFByb21pc2U8YW55PiA/IFJldHVyblR5cGUgOiBQcm9taXNlPFJldHVyblR5cGU+IHtcclxuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNDb25uZWN0ZWQgfHwgb3B0cy5pc0Nvbm5lY3QpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9Qcm9wZXJ0eSA9IG9wdHMud29ya2VyUHJvcGVydHkgPT09IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWNyZXRSZXN1bHQgPSBub1Byb3BlcnR5ID8gbnVsbCA6IHRoaXMuaXNTZWNyZXQodHlwZW9mIG9wdHMud29ya2VyUHJvcGVydHkgPT09ICdzdHJpbmcnID8gdGhpcy53b3JrZXJbb3B0cy53b3JrZXJQcm9wZXJ0eV0gOiBvcHRzLndvcmtlclByb3BlcnR5KHRoaXMud29ya2VyKSwgdHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlY3JldFJlc3VsdCB8fCBub1Byb3BlcnR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZGl0aW9uYWwgY2hlY2tzIC0tLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5hZGRpdGlvbmFsQ29uZGl0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBvcHQgb2Ygb3B0cy5hZGRpdGlvbmFsQ29uZGl0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0LmlmKHNlY3JldFJlc3VsdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG9wdC5yZWplY3Qoc2VjcmV0UmVzdWx0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZGl0aW9uYWwgZnVuY3Rpb25hbGl0eSAtLS1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFkZGl0aW9uYWxDb250ZXh0OiBhbnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLmJlZm9yZVJlcXVlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxDb250ZXh0ID0gb3B0cy5iZWZvcmVSZXF1ZXN0KHNlY3JldFJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc3BvbnNlIC0tLS1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdFNlY3JldCA9IHRoaXMuZ2VuZXJhdGVTZWNyZXRLZXkoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVwc29uc2VTdWJzY3JpcHRpb24gPSB0aGlzLnJlc3BvbnNlRXZlbnQuc3Vic2NyaWJlKChyZXNwKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpc1ZhbGlkUmVwb25zZSA9IHJlc3AudHlwZSA9PT0gdHlwZSAmJiByZXNwLnJlcXVlc3RTZWNyZXQgPT09IHJlcXVlc3RTZWNyZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZFJlcG9uc2UgPSBub1Byb3BlcnR5ID8gaXNWYWxpZFJlcG9uc2UgOiAoaXNWYWxpZFJlcG9uc2UgJiYgc2VjcmV0UmVzdWx0LnByb3BlcnR5TmFtZSA9PT0gcmVzcC5wcm9wZXJ0eU5hbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZFJlcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNwLmlzRXJyb3IpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXNvbHZlIC0tLS1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlU2VjcmV0S2V5KHJlcXVlc3RTZWNyZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMucmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3B0cy5yZXNvbHZlKHJlc3AsIHNlY3JldFJlc3VsdCwgYWRkaXRpb25hbENvbnRleHQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwc29uc2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVqZWN0IC0tLS0tXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVNlY3JldEtleShyZXF1ZXN0U2VjcmV0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLmJlZm9yZVJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuYmVmb3JlUmVqZWN0KHJlc3AsIHNlY3JldFJlc3VsdCwgYWRkaXRpb25hbENvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwc29uc2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChKU09OLnBhcnNlKHJlc3AuZXJyb3IpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbmQgcmVxdWVzdCAtLS0tLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXE6IFdvcmtlclJlcXVlc3RFdmVudDxFdmVudFR5cGU+ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFNlY3JldDogcmVxdWVzdFNlY3JldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZTogbm9Qcm9wZXJ0eSA/IG51bGwgOiBzZWNyZXRSZXN1bHQucHJvcGVydHlOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IG9wdHMuYm9keSA/IG9wdHMuYm9keShzZWNyZXRSZXN1bHQsIGFkZGl0aW9uYWxDb250ZXh0KSA6IG51bGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3N0TWVzc2FnZShyZXEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3Iob3B0cy5zZWNyZXRFcnJvcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdXb3JrZXJDbGllbnQ6IHRoZSBXb3JrZXJDbGllbnQuY29ubmVjdCgpIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgYSB3b3JrZXIgY2FuIGJlIGFjY2Vzc2VkJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIDxhbnk+cHJvbWlzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgd3JhcHBlciBmdW5jdGlvbiBhcm91bmQgdGhlIGBXb3JrZXIucG9zdE1lc3NhZ2UoKWAgbWV0aG9kIHRvIGNhdGNoIGFueSBzZXJpYWxpemF0aW9uIGVycm9ycyBzaG91bGQgdGhleSBvY2N1clxyXG4gICAgICogQHBhcmFtIHJlcXVlc3QgdGhlIHJlcXVlc3QgdG8gYmUgc2VudCB0byB0aGUgd29ya2VyXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcG9zdE1lc3NhZ2U8RXZlbnRUeXBlIGV4dGVuZHMgbnVtYmVyPihcclxuICAgICAgICByZXF1ZXN0OiBXb3JrZXJSZXF1ZXN0RXZlbnQ8RXZlbnRUeXBlPlxyXG4gICAgKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy53b3JrZXJSZWYucG9zdE1lc3NhZ2UocmVxdWVzdCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBzZXJpYWxpemUgdGhlIHJlcXVlc3QgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSB3b3JrZXInKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSB1dGlsaXR5IGZ1bmN0aW9uIHRvIGNhc3QgcHJvbWlzZXNcclxuICAgICAqIEBwYXJhbSBwcm9taXNlIHByb21pc2UgdG8gY2FzdFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNhc3RQcm9taXNlPFByb21pc2VUeXBlPihcclxuICAgICAgICBwcm9taXNlOiBQcm9taXNlPGFueT5cclxuICAgICk6IFByb21pc2U8UHJvbWlzZVR5cGU+IHtcclxuICAgICAgICByZXR1cm4gPFByb21pc2U8UHJvbWlzZVR5cGU+PnByb21pc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGNsaWVudCBzdWJzY3JpcHRpb24gcmVmZXJlbmNlIHdpdGggYSBzdWJzY3JpcHRpb24gYW5kIGFuIFJ4SlMgc3ViamVjdCwgYWRkcyBpdCB0byB0aGUgYG9ic2VydmFibGVzYCBkaWN0aW9uYXJ5IHdpdGggdW5pcXVlIGtleSBhbmQgdGhlbiByZXR1cm5zIHRoZSBrZXkuIENhbGxlZCBmcm9tIHRoZSBgc3Vic2NyaWJlKClgIG1ldGhvZC5cclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eU5hbWUgdGhlIHByb3BlcnR5IG5hbWUgb2YgdGhlIHdvcmtlcidzIFJ4SlMgc3ViamVjdCB0aGF0IHdhcyBzdWJzY3JpYmVkIHRvXHJcbiAgICAgKiBAcGFyYW0gbmV4dCBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBzdWJqZWN0J3MgYG5leHQoKWAgbWV0aG9kIGlzIGNhbGxlZFxyXG4gICAgICogQHBhcmFtIGVycm9yIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIHN1YmplY3QgdGhyb3dzIGFuZCBlcnJvclxyXG4gICAgICogQHBhcmFtIGNvbXBsZXRlIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIHN1YmplY3QncyBgY29tcGxldGUoKWAgbWV0aG9kIGlzIGNhbGxlZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNyZWF0ZVN1YnNjcmlwdGlvbihcclxuICAgICAgICBwcm9wZXJ0eU5hbWU6IHN0cmluZyxcclxuICAgICAgICBuZXh0PzogKHZhbHVlOiBhbnkpID0+IHZvaWQsXHJcbiAgICAgICAgZXJyb3I/OiAoZXJyb3I6IGFueSkgPT4gdm9pZCxcclxuICAgICAgICBjb21wbGV0ZT86ICgpID0+IHZvaWRcclxuICAgICk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5nZW5lcmF0ZVN1YnNjcmlwdGlvbktleShwcm9wZXJ0eU5hbWUpO1xyXG4gICAgICAgIGNvbnN0IHN1YmplY3QgPSBuZXcgU3ViamVjdDxhbnk+KCk7XHJcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gc3ViamVjdC5zdWJzY3JpYmUobmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcclxuICAgICAgICB0aGlzLm9ic2VydmFibGVzW2tleV0gPSB7IHN1YmplY3Q6IHN1YmplY3QsIHN1YnNjcmlwdGlvbjogc3Vic2NyaXB0aW9uLCBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZSwgb2JzZXJ2YWJsZTogbnVsbCB9O1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGNsaWVudCBvYnNlcnZhYmxlIHJlZmVyZW5jZSB3aXRoIGEgUnhKUyBvYnNlcnZhYmxlIGFuZCBzdWJqZWN0LCBhZGRzIGl0IHRvIHRoZSBgb2JzZXJ2YWJsZXNgIGRpY3Rpb25hcnkgd2l0aCB1bmlxdWUga2V5IGFuZCB0aGVuIHJldHVybnMgdGhlIGtleS4gQ2FsbGVkIGZyb20gdGhlIGBvYnNlcnZlKClgIG1ldGhvZC5cclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eU5hbWUgdGhlIHByb3BlcnR5IG5hbWUgb2YgdGhlIHdvcmtlcidzIFJ4SlMgc3ViamVjdCB0aGF0IHdhcyBzdWJzY3JpYmVkIHRvXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY3JlYXRlT2JzZXJ2YWJsZShcclxuICAgICAgICBwcm9wZXJ0eU5hbWU6IHN0cmluZyxcclxuICAgICk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5nZW5lcmF0ZVN1YnNjcmlwdGlvbktleShwcm9wZXJ0eU5hbWUpO1xyXG4gICAgICAgIGNvbnN0IHN1YmplY3QgPSBuZXcgU3ViamVjdDxhbnk+KCk7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlc1trZXldID0geyBzdWJqZWN0OiBzdWJqZWN0LCBzdWJzY3JpcHRpb246IG51bGwsIHByb3BlcnR5TmFtZTogcHJvcGVydHlOYW1lLCBvYnNlcnZhYmxlOiBzdWJqZWN0LmFzT2JzZXJ2YWJsZSgpIH07XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEl0ZXJhdGVzIHRocm91Z2ggdGhlIGBvYnNlcnZhYmxlc2AgZGljdGlvbmFyeSB0byBmaW5kIHRoZSBhc3NvY2lhdGVkIGtleSBmb3IgYSBwYXJ0aWN1bGFyIHN1YnNjcmlwdGlvbiBvciBvYnNlcnZhYmxlLiBSZXR1cm5zIG51bGwgaWYgbm8gbWF0Y2ggaXMgZm91bmRcclxuICAgICAqIEBwYXJhbSB2YWx1ZSBTdWJzY3JpcHRpb24gb3Igb2JzZXJ2YWJsZSBmb3Igd2hpY2ggdGhlIGRpY3Rpb25hcnkga2V5IG11c3QgYmUgZm91bmRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBmaW5kT2JzZXJ2YWJsZUtleShcclxuICAgICAgICB2YWx1ZTogU3Vic2NyaXB0aW9uIHwgT2JzZXJ2YWJsZTxhbnk+XHJcbiAgICApOiBzdHJpbmcge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMub2JzZXJ2YWJsZXMpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vYnNlcnZhYmxlc1trZXldLnN1YnNjcmlwdGlvbiA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub2JzZXJ2YWJsZXNba2V5XS5vYnNlcnZhYmxlID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYSBzdWJzY3JpcHRpb24gb3Igb2JzZXJ2YWJsZSByZWZlcmVuY2UgZnJvbSBgb2JzZXJ2YWJsZXNgIGRpY3Rpb25hcnkuIFJlbW92ZWQgc3Vic2NyaXB0aW9ucyBhcmUgdW5zdWJzcmliZWQgYmVmb3JlIGRlc3Ryb3llZFxyXG4gICAgICogQHBhcmFtIHN1YnNjcmlwdGlvbktleSB1bmlxdWUga2V5IGluIHRoZSBgb2JzZXJ2YWJsZXNgIGRpY3Rpb25hcnlcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZW1vdmVTdWJzY3JpcHRpb24oXHJcbiAgICAgICAgc3Vic2NyaXB0aW9uS2V5OiBzdHJpbmdcclxuICAgICkge1xyXG4gICAgICAgIGlmICh0aGlzLm9ic2VydmFibGVzW3N1YnNjcmlwdGlvbktleV0pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub2JzZXJ2YWJsZXNbc3Vic2NyaXB0aW9uS2V5XS5zdWJzY3JpcHRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2YWJsZXNbc3Vic2NyaXB0aW9uS2V5XS5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGUgdGhpcy5vYnNlcnZhYmxlc1tzdWJzY3JpcHRpb25LZXldO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIGEgcmFuZG9tIGtleVxyXG4gICAgICogQHBhcmFtIHByb3BlcnR5TmFtZSBhcHBlbmRlZCBhcyB0aGUgcHJlZml4IHRvIHRoZSBrZXlcclxuICAgICAqIEBwYXJhbSBsZW5ndGggbGVuZ3RoIG9mIHRoZSByYW5kb21seSBnZW5lcmF0ZWQgY2hhcmFjdGVyc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdlbmVyYXRlS2V5KFxyXG4gICAgICAgIHByb3BlcnR5TmFtZTogc3RyaW5nLFxyXG4gICAgICAgIGxlbmd0aDogbnVtYmVyXHJcbiAgICApIHtcclxuICAgICAgICByZXR1cm4gYCR7cHJvcGVydHlOYW1lLnRvVXBwZXJDYXNlKCl9XyR7QXJyYXkobGVuZ3RoKS5maWxsKG51bGwpLm1hcCgoKSA9PiAoTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMTYpKS50b1N0cmluZygxNikpLmpvaW4oJycpfWA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgdW5pcXVlIGtleSBmb3IgYSBzdWJzY3JpcHRpb24vb2JzZXJ2YWJsZSByZWZlcmVuY2UgZm9yIHVzZSBpbiB0aGUgYG9ic2VydmFibGVzYCBkaWN0aW9uYXJ5LiBUaGlzIGtleSBhbGxvd3MgbWVzc2FnZXMgZnJvbSB0aGUgd29ya2VyIHRvIGJlIGNvcnJlY3RseSBtYXBwZWQgYW5kIGhhbmRsZWQgaW4gdGhlIGNsaWVudFxyXG4gICAgICogQHBhcmFtIHByb3BlcnR5TmFtZSBwcm9wZXJ0eSBuYW1lIG9mIHRoZSB3b3JrZXIncyBSeEpTIHN1YmplY3Qgd2hpY2ggaXMgc3Vic2NyaWJlZCB0by4gVGhpcyBpcyBhdHRhY2hlZCBhcyBhIHByZWZpeCB0byB0aGUgdW5pcXVlIGtleVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdlbmVyYXRlU3Vic2NyaXB0aW9uS2V5KFxyXG4gICAgICAgIHByb3BlcnR5TmFtZTogc3RyaW5nXHJcbiAgICApOiBzdHJpbmcge1xyXG4gICAgICAgIGxldCBrZXkgPSB0aGlzLmdlbmVyYXRlS2V5KHByb3BlcnR5TmFtZSwgNik7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMub2JzZXJ2YWJsZXNba2V5XSkge1xyXG4gICAgICAgICAgICBrZXkgPSB0aGlzLmdlbmVyYXRlS2V5KHByb3BlcnR5TmFtZSwgNik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgdW5pcXVlIGtleSBmb3Igd29ya2VyIHJlcXVlc3RzIGVuc3VyaW5nIG5vIHR3byBrZXlzIGFyZSBhdmFsaWFibGUgYXQgYW55IHRpbWUgdGhyb3VnaCB0aGUgYHNlY3JldHNgIGFycmF5LiBBbGxvd3MgcmVxdWVzdHMgdG8gYmUgbWFwcGVkIHRvIHJlc3BvbnNlcyBmcm9tXHJcbiAgICAgKiB0aGUgd29ya2VyXHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydHlOYW1lIHByb3BlcnR5IG5hbWUgb2YgdGhlIHdvcmtlcidzIHByb3BlcnR5L21ldGhvZCB0aGF0IGlzIGJlaW5nIGNhbGxlZC4gVGhpcyBpcyBhdHRhY2hlZCBhcyBhIHByZWZpeCB0byB0aGUgdW5pcXVlIGtleVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdlbmVyYXRlU2VjcmV0S2V5KFxyXG4gICAgICAgIHByb3BlcnR5TmFtZT86IHN0cmluZ1xyXG4gICAgKTogc3RyaW5nIHtcclxuICAgICAgICBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWUgPyBwcm9wZXJ0eU5hbWUgOiAnY2xpZW50JztcclxuICAgICAgICBsZXQga2V5ID0gdGhpcy5nZW5lcmF0ZUtleShwcm9wZXJ0eU5hbWUsIDE2KTtcclxuICAgICAgICB3aGlsZSAodGhpcy5zZWNyZXRzLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcclxuICAgICAgICAgICAga2V5ID0gdGhpcy5nZW5lcmF0ZUtleShwcm9wZXJ0eU5hbWUsIDE2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZWNyZXRzLnB1c2goa2V5KTtcclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIGtleSBmcm9tIHRoZSBgc2VjcmV0c2AgYXJyYXkgaWYgaXQgZXhpc3RzXHJcbiAgICAgKiBAcGFyYW0gc2VjcmV0IHVucWl1ZSBrZXkgdG8gYmUgcmVtb3ZlZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlbW92ZVNlY3JldEtleShcclxuICAgICAgICBzZWNyZXQ6IHN0cmluZ1xyXG4gICAgKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VjcmV0cy5pbmRleE9mKHNlY3JldCkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VjcmV0cy5zcGxpY2UodGhpcy5zZWNyZXRzLmluZGV4T2Yoc2VjcmV0KSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGEgdmFsaWQgYFNlY3JldFJlc3VsdGAgaXMgcmV0dXJuZWQgd2hlbiBhIGRlY29yYXRlZCBwcm9wZXJ0eSBhbmQvb3IgbWV0aG9kIG9mIHRoZSBjbGllbnQgaW5zdGFuY2Ugb2YgdGhlIHdvcmtlciBjbGFzcyBpcyBjYWxsZWQuXHJcbiAgICAgKiAgUmV0dXJucyB0aGUgc2VjcmV0IHdoZW4gdmFsaWQgb3RoZXJ3aXNlIHJldHVybnMgbnVsbFxyXG4gICAgICogQHBhcmFtIHNlY3JldFJlc3VsdCB0aGUgcmV0dXJuZWQgdmFsdWUgZnJvbSBjYWxsaW5nIHRoZSBwcm9wZXJ0eSBvciBtZXRob2Qgb2YgYSBjbGllbnQgaW5zdGFuY2Ugb2YgYSB3b3JrZXJcclxuICAgICAqIEBwYXJhbSB0eXBlIHRoZSB3b3JrZXIgZXZlbnQgdHlwZSB0aGF0IG9yaWdpbmF0ZWQgdGhlIHJlcXVlc3RcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBpc1NlY3JldDxTZWNyZXRUeXBlIGV4dGVuZHMgbnVtYmVyPihcclxuICAgICAgICBzZWNyZXRSZXN1bHQ6IGFueSxcclxuICAgICAgICB0eXBlOiBTZWNyZXRUeXBlXHJcbiAgICApOiBTZWNyZXRSZXN1bHQ8U2VjcmV0VHlwZT4ge1xyXG4gICAgICAgIGlmIChzZWNyZXRSZXN1bHQpIHtcclxuICAgICAgICAgICAgaWYgKHNlY3JldFJlc3VsdFsnY2xpZW50U2VjcmV0J10gJiYgc2VjcmV0UmVzdWx0Wydwcm9wZXJ0eU5hbWUnXSAmJiBzZWNyZXRSZXN1bHRbJ3R5cGUnXSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlY3JldFJlc3VsdFsnY2xpZW50U2VjcmV0J10gPT09IHRoaXMud29ya2VyU2VjcmV0ICYmIHNlY3JldFJlc3VsdFsndHlwZSddID09PSB0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxTZWNyZXRSZXN1bHQ8U2VjcmV0VHlwZT4+c2VjcmV0UmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIHRvIGxpc3RlbiBmb3IsIGFuZCBoYW5kbGUsIG1lc3NhZ2VzIHJlY2lldmVkIHRocm91Z2ggYFdvcmtlci5vbm1lc3NhZ2VgXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVnaXN0ZXJFdmVudHMoKSB7XHJcblxyXG4gICAgICAgIHRoaXMucmVzcG9uc2VFdmVudCA9IG5ldyBTdWJqZWN0PFdvcmtlclJlc3BvbnNlRXZlbnQ8V29ya2VyRXZlbnRzLkNhbGxhYmxlPj4oKTtcclxuICAgICAgICB0aGlzLm9ic2VydmFibGVzID0ge307XHJcblxyXG4gICAgICAgIHRoaXMud29ya2VyUmVmLm9ubWVzc2FnZSA9IChldjogV29ya2VyRXZlbnQ8V29ya2VyUmVzcG9uc2VFdmVudDxhbnk+PikgPT4ge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGV2LmRhdGEudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBXb3JrZXJFdmVudHMuT2JzZXJ2YWJsZU1lc3NhZ2U6XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm9keTogV29ya2VyT2JzZXJ2YWJsZU1lc3NhZ2UgPSBldi5kYXRhLnJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vYnNlcnZhYmxlc1tib2R5LmtleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChib2R5LnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgV29ya2VyT2JzZXJ2YWJsZU1lc3NhZ2VUeXBlcy5OZXh0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2YWJsZXNbYm9keS5rZXldLnN1YmplY3QubmV4dChib2R5LnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgV29ya2VyT2JzZXJ2YWJsZU1lc3NhZ2VUeXBlcy5FcnJvcjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmFibGVzW2JvZHkua2V5XS5zdWJqZWN0LmVycm9yKGJvZHkuZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBXb3JrZXJPYnNlcnZhYmxlTWVzc2FnZVR5cGVzLkNvbXBsZXRlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2YWJsZXNbYm9keS5rZXldLnN1YmplY3QuY29tcGxldGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZUV2ZW50Lm5leHQoZXYuZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICB9XHJcblxyXG5cclxufVxyXG4iXX0=