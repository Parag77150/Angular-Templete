import * as tslib_1 from "tslib";
import 'reflect-metadata';
import { WorkerEvents, WorkerUtils, WorkerAnnotations } from 'angular-web-worker/common';
/**
 * Allows the decorated worker method to be called, and its value returned, from the `WorkerClient.call()` method.
 * Can be used on both asynchronous and synchronous methods.
 * @Serialized Functions will not be copied and circular referencing structures will cause errors. This applies to both the function arguments and the value returned by the function
 * @param options Configurable options defining how the decorated method is called from a `WorkerClient`
 */
export function Callable(options) {
    return function (target, propertyKey, descriptor) {
        var opts = { shallowTransfer: false };
        if (options) {
            opts.shallowTransfer = options.shallowTransfer ? true : false;
        }
        WorkerUtils.pushAnnotation(target.constructor, WorkerAnnotations.Callables, {
            name: propertyKey,
            shallowTransfer: opts.shallowTransfer,
            returnType: Reflect.getMetadata('design:returntype', target, propertyKey)
        });
        var originalMethod = descriptor.value;
        descriptor.value = function () {
            var context = this;
            var args = Array.prototype.slice.call(arguments);
            var config = context.__worker_config__;
            if (config) {
                if (config.isClient) {
                    var secret = {
                        clientSecret: context.__worker_config__.clientSecret,
                        type: WorkerEvents.Callable,
                        propertyName: propertyKey,
                        body: {
                            args: args
                        }
                    };
                    return secret;
                }
                else {
                    return originalMethod.call.apply(originalMethod, tslib_1.__spread([context], args));
                }
            }
            else {
                return originalMethod.call.apply(originalMethod, tslib_1.__spread([context], args));
            }
        };
        return descriptor;
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsbGFibGUtZGVjb3JhdG9yLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci13ZWItd29ya2VyLyIsInNvdXJjZXMiOlsibGliL2NhbGxhYmxlLWRlY29yYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxrQkFBa0IsQ0FBQztBQUMxQixPQUFPLEVBQWtDLFlBQVksRUFBZ0IsV0FBVyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFjdkk7Ozs7O0dBS0c7QUFDSCxNQUFNLFVBQVUsUUFBUSxDQUFDLE9BQXNCO0lBRTNDLE9BQU8sVUFBVSxNQUFXLEVBQUUsV0FBbUIsRUFBRSxVQUE4QjtRQUU3RSxJQUFNLElBQUksR0FBRyxFQUFFLGVBQWUsRUFBRSxLQUFLLEVBQUUsQ0FBQztRQUN4QyxJQUFJLE9BQU8sRUFBRTtZQUNULElBQUksQ0FBQyxlQUFlLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7U0FDakU7UUFFRCxXQUFXLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxXQUFXLEVBQUUsaUJBQWlCLENBQUMsU0FBUyxFQUFvQjtZQUMxRixJQUFJLEVBQUUsV0FBVztZQUNqQixlQUFlLEVBQUUsSUFBSSxDQUFDLGVBQWU7WUFDckMsVUFBVSxFQUFFLE9BQU8sQ0FBQyxXQUFXLENBQUMsbUJBQW1CLEVBQUUsTUFBTSxFQUFFLFdBQVcsQ0FBQztTQUM1RSxDQUFDLENBQUM7UUFFSCxJQUFNLGNBQWMsR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDO1FBQ3hDLFVBQVUsQ0FBQyxLQUFLLEdBQUc7WUFDZixJQUFNLE9BQU8sR0FBRyxJQUFJLENBQUM7WUFDckIsSUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ25ELElBQU0sTUFBTSxHQUFpQixPQUFPLENBQUMsaUJBQWlCLENBQUM7WUFDdkQsSUFBSSxNQUFNLEVBQUU7Z0JBQ1IsSUFBSSxNQUFNLENBQUMsUUFBUSxFQUFFO29CQUNqQixJQUFNLE1BQU0sR0FBd0M7d0JBQ2hELFlBQVksRUFBRSxPQUFPLENBQUMsaUJBQWlCLENBQUMsWUFBWTt3QkFDcEQsSUFBSSxFQUFFLFlBQVksQ0FBQyxRQUFRO3dCQUMzQixZQUFZLEVBQUUsV0FBVzt3QkFDekIsSUFBSSxFQUFFOzRCQUNGLElBQUksRUFBRSxJQUFJO3lCQUNiO3FCQUNKLENBQUM7b0JBQ0YsT0FBTyxNQUFNLENBQUM7aUJBQ2pCO3FCQUFNO29CQUNILE9BQU8sY0FBYyxDQUFDLElBQUksT0FBbkIsY0FBYyxvQkFBTSxPQUFPLEdBQUssSUFBSSxHQUFFO2lCQUNoRDthQUNKO2lCQUFNO2dCQUNILE9BQU8sY0FBYyxDQUFDLElBQUksT0FBbkIsY0FBYyxvQkFBTSxPQUFPLEdBQUssSUFBSSxHQUFFO2FBQ2hEO1FBQ0wsQ0FBQyxDQUFDO1FBQ0YsT0FBTyxVQUFVLENBQUM7SUFDdEIsQ0FBQyxDQUFDO0FBQ04sQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAncmVmbGVjdC1tZXRhZGF0YSc7XHJcbmltcG9ydCB7IENhbGxhYmxlTWV0YURhdGEsIFdvcmtlckNvbmZpZywgV29ya2VyRXZlbnRzLCBTZWNyZXRSZXN1bHQsIFdvcmtlclV0aWxzLCBXb3JrZXJBbm5vdGF0aW9ucyB9IGZyb20gJ2FuZ3VsYXItd2ViLXdvcmtlci9jb21tb24nO1xyXG5cclxuLyoqXHJcbiAqIENvbmZpZ3VyYWJsZSBvcHRpb25zIGZvciB0aGUgYEBDYWxsYWJsZSgpYCBkZWNvcmF0b3IsIGRlZmluaW5nIGhvdyB0aGUgZGVjb3JhdGVkIG1ldGhvZCBpcyBjYWxsZWQgZnJvbSBhIGBXb3JrZXJDbGllbnRgLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBDYWxsYWJsZU9wdHMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSBwcm90b3R5cGUgb2YgdGhlIHZhbHVlIHJldHVybmVkIGJ5IHRoZSBkZWNvcmF0ZWQgbWV0aG9kIGlzIHRyYW5zZmVyZWQgYWZ0ZXIgaXQgaGFzIGJlZW4gc2VyaWFsaXplZCBhbmQgdW5zZXJpYWxpemVkIHdoZW4gYnJvdWdodCBiYWNrIHRvIHRoZSBgV29ya2VyQ2xpZW50YFxyXG4gICAgICogQGRlZmF1bHR2YWx1ZSBmYWxzZVxyXG4gICAgICogQEV4cGVyaW1lbnRhbCBoYXMgbGltaXRhdGlvbnNcclxuICAgICAqL1xyXG4gICAgc2hhbGxvd1RyYW5zZmVyPzogYm9vbGVhbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFsbG93cyB0aGUgZGVjb3JhdGVkIHdvcmtlciBtZXRob2QgdG8gYmUgY2FsbGVkLCBhbmQgaXRzIHZhbHVlIHJldHVybmVkLCBmcm9tIHRoZSBgV29ya2VyQ2xpZW50LmNhbGwoKWAgbWV0aG9kLlxyXG4gKiBDYW4gYmUgdXNlZCBvbiBib3RoIGFzeW5jaHJvbm91cyBhbmQgc3luY2hyb25vdXMgbWV0aG9kcy5cclxuICogQFNlcmlhbGl6ZWQgRnVuY3Rpb25zIHdpbGwgbm90IGJlIGNvcGllZCBhbmQgY2lyY3VsYXIgcmVmZXJlbmNpbmcgc3RydWN0dXJlcyB3aWxsIGNhdXNlIGVycm9ycy4gVGhpcyBhcHBsaWVzIHRvIGJvdGggdGhlIGZ1bmN0aW9uIGFyZ3VtZW50cyBhbmQgdGhlIHZhbHVlIHJldHVybmVkIGJ5IHRoZSBmdW5jdGlvblxyXG4gKiBAcGFyYW0gb3B0aW9ucyBDb25maWd1cmFibGUgb3B0aW9ucyBkZWZpbmluZyBob3cgdGhlIGRlY29yYXRlZCBtZXRob2QgaXMgY2FsbGVkIGZyb20gYSBgV29ya2VyQ2xpZW50YFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIENhbGxhYmxlKG9wdGlvbnM/OiBDYWxsYWJsZU9wdHMpIHtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldDogYW55LCBwcm9wZXJ0eUtleTogc3RyaW5nLCBkZXNjcmlwdG9yOiBQcm9wZXJ0eURlc2NyaXB0b3IpIHtcclxuXHJcbiAgICAgICAgY29uc3Qgb3B0cyA9IHsgc2hhbGxvd1RyYW5zZmVyOiBmYWxzZSB9O1xyXG4gICAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIG9wdHMuc2hhbGxvd1RyYW5zZmVyID0gb3B0aW9ucy5zaGFsbG93VHJhbnNmZXIgPyB0cnVlIDogZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBXb3JrZXJVdGlscy5wdXNoQW5ub3RhdGlvbih0YXJnZXQuY29uc3RydWN0b3IsIFdvcmtlckFubm90YXRpb25zLkNhbGxhYmxlcywgPENhbGxhYmxlTWV0YURhdGE+e1xyXG4gICAgICAgICAgICBuYW1lOiBwcm9wZXJ0eUtleSxcclxuICAgICAgICAgICAgc2hhbGxvd1RyYW5zZmVyOiBvcHRzLnNoYWxsb3dUcmFuc2ZlcixcclxuICAgICAgICAgICAgcmV0dXJuVHlwZTogUmVmbGVjdC5nZXRNZXRhZGF0YSgnZGVzaWduOnJldHVybnR5cGUnLCB0YXJnZXQsIHByb3BlcnR5S2V5KVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBvcmlnaW5hbE1ldGhvZCA9IGRlc2NyaXB0b3IudmFsdWU7XHJcbiAgICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICBjb25zdCBjb25maWc6IFdvcmtlckNvbmZpZyA9IGNvbnRleHQuX193b3JrZXJfY29uZmlnX187XHJcbiAgICAgICAgICAgIGlmIChjb25maWcpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb25maWcuaXNDbGllbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWNyZXQ6IFNlY3JldFJlc3VsdDxXb3JrZXJFdmVudHMuQ2FsbGFibGU+ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRTZWNyZXQ6IGNvbnRleHQuX193b3JrZXJfY29uZmlnX18uY2xpZW50U2VjcmV0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBXb3JrZXJFdmVudHMuQ2FsbGFibGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZTogcHJvcGVydHlLZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlY3JldDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsTWV0aG9kLmNhbGwoY29udGV4dCwgLi4uYXJncyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxNZXRob2QuY2FsbChjb250ZXh0LCAuLi5hcmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XHJcbiAgICB9O1xyXG59XHJcbiJdfQ==